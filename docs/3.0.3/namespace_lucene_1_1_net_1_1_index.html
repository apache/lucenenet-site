<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>Lucene.Net: Package Lucene.Net.Index</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="lucene-net-icon-128x128.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Lucene.Net
   &#160;<span id="projectnumber">3.0.3</span>
   </div>
   <div id="projectbrief">Lucene.Net is a .NET port of the Java Lucene Indexing Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="Index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="namespacemembers.html"><span>Package&#160;Functions</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Properties</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_lucene.html">Lucene</a></li><li class="navelem"><a class="el" href="namespace_lucene_1_1_net.html">Net</a></li><li class="navelem"><a class="el" href="namespace_lucene_1_1_net_1_1_index.html">Index</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">Package Lucene.Net.Index</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_lucene_1_1_net_1_1_index_1_1_memory"><td class="memItemLeft" align="right" valign="top">package &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lucene_1_1_net_1_1_index_1_1_memory.html">Memory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_field_enumerator_3_01_t_01_4.html">FieldEnumerator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="class_lucene_1_1_net_1_1_index_1_1_field_enumerator_3_01_t_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_term_doc_enumerator.html">TermDocEnumerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to handle creating a <a class="el" href="interface_lucene_1_1_net_1_1_index_1_1_term_docs.html" title="TermDocs provides an interface for enumerating &lt;document, frequency&gt; pairs for a term. The document portion names each document containing the term. Documents are indicated by number. The frequency portion gives the number of times the term occurred in each document. The pairs are ordered by document number. ">TermDocs</a> and allowing for seeking and enumeration. Used when you have a set of one or moreterms for which you want to enumerate over the documents that contain those terms.  <a href="class_lucene_1_1_net_1_1_index_1_1_term_doc_enumerator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_string_field_enumerator.html">StringFieldEnumerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for enumerating over terms with a string value.  <a href="class_lucene_1_1_net_1_1_index_1_1_string_field_enumerator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_numeric_field_enum_3_01_t_01_4.html">NumericFieldEnum&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base for enumerating over numeric fields.  <a href="class_lucene_1_1_net_1_1_index_1_1_numeric_field_enum_3_01_t_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_int_field_enumerator.html">IntFieldEnumerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for enumerating over all of the terms in an int numeric field.  <a href="class_lucene_1_1_net_1_1_index_1_1_int_field_enumerator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_float_field_enumerator.html">FloatFieldEnumerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for enumerating over all of the terms in a float numeric field.  <a href="class_lucene_1_1_net_1_1_index_1_1_float_field_enumerator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_double_field_enumerator.html">DoubleFieldEnumerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for enumerating over all of the terms in a double numeric field.  <a href="class_lucene_1_1_net_1_1_index_1_1_double_field_enumerator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_long_field_enumerator.html">LongFieldEnumerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for enumerating over all of the terms in a long numeric field.  <a href="class_lucene_1_1_net_1_1_index_1_1_long_field_enumerator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_segments_gen_commit.html">SegmentsGenCommit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that will force an index writer to open an index based on the generation in the segments.gen file as opposed to the highest generation found in a directory listing.  <a href="class_lucene_1_1_net_1_1_index_1_1_segments_gen_commit.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_term_vector_enumerator.html">TermVectorEnumerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to allow for enumerating over the documents in the index to retrieve the term vector for each one.  <a href="class_lucene_1_1_net_1_1_index_1_1_term_vector_enumerator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_empty_vector.html">EmptyVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple TermFreqVector implementation for an empty vector for use with a deleted document or a document that does not have the field that is being enumerated.  <a href="class_lucene_1_1_net_1_1_index_1_1_empty_vector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_abstract_all_term_docs.html">AbstractAllTermDocs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for enumerating all but deleted docs.  <a href="class_lucene_1_1_net_1_1_index_1_1_abstract_all_term_docs.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_all_term_docs.html">AllTermDocs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_buffered_deletes.html">BufferedDeletes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds buffered deletes, by docID, term or query. We hold two instances of this class: one for the deletes prior to the last flush, the other for deletes after the last flush. This is so if we need to abort (discard all buffered docs) we can also discard the buffered deletes yet keep the deletes done during previously flushed segments.  <a href="class_lucene_1_1_net_1_1_index_1_1_buffered_deletes.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_byte_block_pool.html">ByteBlockPool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_byte_slice_reader.html">ByteSliceReader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_byte_slice_writer.html">ByteSliceWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to write byte streams into slices of shared byte[]. This is used by <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_documents_writer.html" title="This class accepts multiple added documents and directly writes a single segment file. It does this more efficiently than creating a single segment per document (with DocumentWriter) and doing standard merges on those segments.">DocumentsWriter</a> to hold the posting list for many terms in RAM.  <a href="class_lucene_1_1_net_1_1_index_1_1_byte_slice_writer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_char_block_pool.html">CharBlockPool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_check_index.html">CheckIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic tool and API to check the health of an index and write a new segments file that removes reference to problematic segments.  <a href="class_lucene_1_1_net_1_1_index_1_1_check_index.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_compound_file_reader.html">CompoundFileReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for accessing a compound stream. This class implements a directory, but is limited to only read operations. Directory methods that would normally modify data throw an exception.  <a href="class_lucene_1_1_net_1_1_index_1_1_compound_file_reader.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_compound_file_writer.html">CompoundFileWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines multiple files into a single compound file. The file format:<br/>
 </p>
<ul>
<li>
VInt fileCount </li>
<li>
{Directory} fileCount entries with the following structure: <ul>
<li>
long dataOffset </li>
<li>
String fileName </li>
</ul>
</li>
<li>
{File Data} fileCount entries with the raw data of the corresponding file </li>
</ul>
 <a href="class_lucene_1_1_net_1_1_index_1_1_compound_file_writer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_concurrent_merge_scheduler.html">ConcurrentMergeScheduler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_merge_scheduler.html" title="Expert: IndexWriter uses an instance implementing this interface to execute the merges selected by a ...">MergeScheduler</a> that runs each merge using a separate thread, up until a maximum number of threads (<a class="el" href="class_lucene_1_1_net_1_1_index_1_1_concurrent_merge_scheduler.html#a00bce375f5065894f2d27c004fdf7bde" title="Gets or sets the max # simultaneous threads that may be running. If a merge is necessary yet we alrea...">MaxThreadCount</a>) at which when a merge is needed, the thread(s) that are updating the index will pause until one or more merges completes. This is a simple way to use concurrency in the indexing process without having to create and manage application level threads.  <a href="class_lucene_1_1_net_1_1_index_1_1_concurrent_merge_scheduler.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_corrupt_index_exception.html">CorruptIndexException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This exception is thrown when <a class="el" href="namespace_lucene.html">Lucene</a> detects an inconsistency in the index.  <a href="class_lucene_1_1_net_1_1_index_1_1_corrupt_index_exception.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_default_skip_list_reader.html">DefaultSkipListReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the skip list reader for the default posting list format that stores positions and payloads.  <a href="class_lucene_1_1_net_1_1_index_1_1_default_skip_list_reader.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_default_skip_list_writer.html">DefaultSkipListWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the skip list writer for the default posting list format that stores positions and payloads.  <a href="class_lucene_1_1_net_1_1_index_1_1_default_skip_list_writer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_directory_reader.html">DirectoryReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_reader.html" title="IndexReader is an abstract class, providing an interface for accessing an index. Search of an index i...">IndexReader</a> which reads indexes with multiple segments. <a href="class_lucene_1_1_net_1_1_index_1_1_directory_reader.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_doc_consumer.html">DocConsumer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_doc_consumer_per_thread.html">DocConsumerPerThread</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_doc_field_consumer.html">DocFieldConsumer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_doc_field_consumer_per_field.html">DocFieldConsumerPerField</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_doc_field_consumer_per_thread.html">DocFieldConsumerPerThread</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_doc_field_consumers.html">DocFieldConsumers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is just a "splitter" class: it lets you wrap two <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_doc_field_consumer.html">DocFieldConsumer</a> instances as a single consumer.  <a href="class_lucene_1_1_net_1_1_index_1_1_doc_field_consumers.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_doc_field_consumers_per_field.html">DocFieldConsumersPerField</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_doc_field_consumers_per_thread.html">DocFieldConsumersPerThread</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_doc_field_processor.html">DocFieldProcessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_doc_consumer.html">DocConsumer</a> that gathers all fields under the same name, and calls per-field consumers to process field by field. This class doesn't doesn't do any "real" work of its own: it just forwards the fields to a <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_doc_field_consumer.html">DocFieldConsumer</a>.  <a href="class_lucene_1_1_net_1_1_index_1_1_doc_field_processor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_doc_field_processor_per_field.html">DocFieldProcessorPerField</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds all per thread, per field state. <a href="class_lucene_1_1_net_1_1_index_1_1_doc_field_processor_per_field.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_doc_field_processor_per_thread.html">DocFieldProcessorPerThread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers all Fieldables for a document under the same name, updates <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_field_infos.html" title="Access to the Fieldable Info file that describes document fields and whether or not they are indexed...">FieldInfos</a>, and calls per-field consumers to process field by field.  <a href="class_lucene_1_1_net_1_1_index_1_1_doc_field_processor_per_thread.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_doc_inverter.html">DocInverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_doc_field_consumer.html">DocFieldConsumer</a> that inverts each field, separately, from a Document, and accepts a InvertedTermsConsumer to process those terms.  <a href="class_lucene_1_1_net_1_1_index_1_1_doc_inverter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_doc_inverter_per_field.html">DocInverterPerField</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds state for inverting all occurrences of a single field in the document. This class doesn't do anything itself; instead, it forwards the tokens produced by analysis to its own consumer (<a class="el" href="class_lucene_1_1_net_1_1_index_1_1_inverted_doc_consumer_per_field.html">InvertedDocConsumerPerField</a>). It also interacts with an endConsumer (<a class="el" href="class_lucene_1_1_net_1_1_index_1_1_inverted_doc_end_consumer_per_field.html">InvertedDocEndConsumerPerField</a>).  <a href="class_lucene_1_1_net_1_1_index_1_1_doc_inverter_per_field.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_doc_inverter_per_thread.html">DocInverterPerThread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_doc_field_consumer.html">DocFieldConsumer</a> that inverts each field, separately, from a Document, and accepts a InvertedTermsConsumer to process those terms.  <a href="class_lucene_1_1_net_1_1_index_1_1_doc_inverter_per_thread.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_documents_writer.html">DocumentsWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class accepts multiple added documents and directly writes a single segment file. It does this more efficiently than creating a single segment per document (with DocumentWriter) and doing standard merges on those segments.  <a href="class_lucene_1_1_net_1_1_index_1_1_documents_writer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_documents_writer_thread_state.html">DocumentsWriterThreadState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_documents_writer.html" title="This class accepts multiple added documents and directly writes a single segment file. It does this more efficiently than creating a single segment per document (with DocumentWriter) and doing standard merges on those segments.">DocumentsWriter</a> to maintain per-thread state. We keep a separate Posting hash and other state for each thread and then merge postings hashes from all threads when writing the segment.  <a href="class_lucene_1_1_net_1_1_index_1_1_documents_writer_thread_state.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_field_info.html">FieldInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_field_infos.html">FieldInfos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the Fieldable Info file that describes document fields and whether or not they are indexed. Each segment has a separate Fieldable Info file. Objects of this class are thread-safe for multiple readers, but only one thread can be adding documents at a time, with no other reader or writer threads accessing this object.  <a href="class_lucene_1_1_net_1_1_index_1_1_field_infos.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_field_invert_state.html">FieldInvertState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class tracks the number and position / offset parameters of terms being added to the index. The information collected in this class is also used to calculate the normalization factor for a field.  <a href="class_lucene_1_1_net_1_1_index_1_1_field_invert_state.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_field_reader_exception.html">FieldReaderException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="class_lucene_1_1_net_1_1_index_1_1_field_reader_exception.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_field_sorted_term_vector_mapper.html">FieldSortedTermVectorMapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each Field, store a sorted collection of <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_term_vector_entry.html" title="Convenience class for holding TermVector information.">TermVectorEntry</a>s This is not thread-safe.  <a href="class_lucene_1_1_net_1_1_index_1_1_field_sorted_term_vector_mapper.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_fields_reader.html">FieldsReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class responsible for access to stored document fields. It uses &lt;segment&gt;.fdt and &lt;segment&gt;.fdx; files.  <a href="class_lucene_1_1_net_1_1_index_1_1_fields_reader.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_fields_writer.html">FieldsWriter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_filter_index_reader.html">FilterIndexReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_filter_index_reader.html" title="A FilterIndexReader contains another IndexReader, which it uses as its basic source of data...">FilterIndexReader</a></code> contains another <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_reader.html" title="IndexReader is an abstract class, providing an interface for accessing an index. Search of an index i...">IndexReader</a>, which it uses as its basic source of data, possibly transforming the data along the way or providing additional functionality. The class <code><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_filter_index_reader.html" title="A FilterIndexReader contains another IndexReader, which it uses as its basic source of data...">FilterIndexReader</a></code> itself simply implements all abstract methods of <code><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_reader.html" title="IndexReader is an abstract class, providing an interface for accessing an index. Search of an index i...">IndexReader</a></code> with versions that pass all requests to the contained index reader. Subclasses of <code><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_filter_index_reader.html" title="A FilterIndexReader contains another IndexReader, which it uses as its basic source of data...">FilterIndexReader</a></code> may further override some of these methods and may also provide additional methods and fields.  <a href="class_lucene_1_1_net_1_1_index_1_1_filter_index_reader.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_format_postings_docs_consumer.html">FormatPostingsDocsConsumer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">NOTE: this API is experimental and will likely change <a href="class_lucene_1_1_net_1_1_index_1_1_format_postings_docs_consumer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_format_postings_docs_writer.html">FormatPostingsDocsWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumes doc and freq, writing them using the current index file format  <a href="class_lucene_1_1_net_1_1_index_1_1_format_postings_docs_writer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_format_postings_fields_consumer.html">FormatPostingsFieldsConsumer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract API that consumes terms, doc, freq, prox and payloads postings. Concrete implementations of this actually do "something" with the postings (write it into the index in a specific format).  <a href="class_lucene_1_1_net_1_1_index_1_1_format_postings_fields_consumer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_format_postings_fields_writer.html">FormatPostingsFieldsWriter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_format_postings_positions_consumer.html">FormatPostingsPositionsConsumer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_format_postings_positions_writer.html">FormatPostingsPositionsWriter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_format_postings_terms_consumer.html">FormatPostingsTermsConsumer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">NOTE: this API is experimental and will likely change <a href="class_lucene_1_1_net_1_1_index_1_1_format_postings_terms_consumer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_format_postings_terms_writer.html">FormatPostingsTermsWriter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_freq_prox_field_merge_state.html">FreqProxFieldMergeState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_documents_writer.html" title="This class accepts multiple added documents and directly writes a single segment file. It does this more efficiently than creating a single segment per document (with DocumentWriter) and doing standard merges on those segments.">DocumentsWriter</a> to merge the postings from multiple ThreadStates when creating a segment  <a href="class_lucene_1_1_net_1_1_index_1_1_freq_prox_field_merge_state.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_freq_prox_terms_writer.html">FreqProxTermsWriter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_freq_prox_terms_writer_per_field.html">FreqProxTermsWriterPerField</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_freq_prox_terms_writer_per_thread.html">FreqProxTermsWriterPerThread</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_commit.html">IndexCommit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: represents a single commit into an index as seen by the <a class="el" href="interface_lucene_1_1_net_1_1_index_1_1_index_deletion_policy.html" title="Expert: policy for deletion of stale index commits.">IndexDeletionPolicy</a> or <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_reader.html" title="IndexReader is an abstract class, providing an interface for accessing an index. Search of an index i...">IndexReader</a>. <a href="class_lucene_1_1_net_1_1_index_1_1_index_commit.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_lucene_1_1_net_1_1_index_1_1_index_deletion_policy.html">IndexDeletionPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: policy for deletion of stale <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_commit.html">index commits</a>.  <a href="interface_lucene_1_1_net_1_1_index_1_1_index_deletion_policy.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_file_deleter.html">IndexFileDeleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="class_lucene_1_1_net_1_1_index_1_1_index_file_deleter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_file_name_filter.html">IndexFileNameFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filename filter that accept filenames and extensions only created by <a class="el" href="namespace_lucene.html">Lucene</a>.  <a href="class_lucene_1_1_net_1_1_index_1_1_index_file_name_filter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_file_names.html">IndexFileNames</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful constants representing filenames and extensions used by lucene <a href="class_lucene_1_1_net_1_1_index_1_1_index_file_names.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_reader.html">IndexReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_reader.html" title="IndexReader is an abstract class, providing an interface for accessing an index. Search of an index i...">IndexReader</a> is an abstract class, providing an interface for accessing an index. <a class="el" href="namespace_lucene_1_1_net_1_1_search.html">Search</a> of an index is done entirely through this abstract interface, so that any subclass which implements it is searchable. Concrete subclasses of <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_reader.html" title="IndexReader is an abstract class, providing an interface for accessing an index. Search of an index i...">IndexReader</a> are usually constructed with a call to one of the static <code>open()</code> methods, e.g. <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_reader.html#ad51f1feca975e447b6486d01ed24e1ea" title="Returns an IndexReader reading the index in the given Directory. You should pass readOnly=true, since it gives much better concurrent performance, unless you intend to do write operations (delete documents or change norms) with the reader. ">Open(Lucene.Net.Store.Directory, bool)</a> For efficiency, in this API documents are often referred to via <em>document numbers</em>, non-negative integers which each name a unique document in the index. These document numbers are ephemeral&ndash;they may change as documents are added to and deleted from an index. Clients should thus not rely on a given document having the same number between sessions. An <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_reader.html" title="IndexReader is an abstract class, providing an interface for accessing an index. Search of an index i...">IndexReader</a> can be opened on a directory for which an <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a> is opened already, but it cannot be used to delete documents from the index then. <b>NOTE</b>: for backwards API compatibility, several methods are not listed as abstract, but have no useful implementations in this base class and instead always throw UnsupportedOperationException. Subclasses are strongly encouraged to override these methods, but in many cases may not need to. <b>NOTE</b>: as of 2.4, it's possible to open a read-only <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_reader.html" title="IndexReader is an abstract class, providing an interface for accessing an index. Search of an index i...">IndexReader</a> using the static open methods that accepts the boolean readOnly parameter. Such a reader has better better concurrency as it's not necessary to synchronize on the isDeleted method. You must explicitly specify false if you want to make changes with the resulting <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_reader.html" title="IndexReader is an abstract class, providing an interface for accessing an index. Search of an index i...">IndexReader</a>. <a class="anchor" id="thread-safety"></a><b>NOTE</b>: <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_reader.html" title="IndexReader is an abstract class, providing an interface for accessing an index. Search of an index i...">IndexReader</a> instances are completely thread safe, meaning multiple threads can call any of its methods, concurrently. If your application requires external synchronization, you should <b>not</b> synchronize on the <code><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_reader.html" title="IndexReader is an abstract class, providing an interface for accessing an index. Search of an index i...">IndexReader</a></code> instance; use your own (non-Lucene) objects instead.  <a href="class_lucene_1_1_net_1_1_index_1_1_index_reader.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_writer.html">IndexWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <code><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a></code> creates and maintains an index. The <code>create</code> argument to the <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_writer.html#af4620c14320934601058e0e9cac9bfab">constructor</a> determines whether a new index is created, or whether an existing index is opened. Note that you can open an index with <code>create=true</code> even while readers are using the index. The old readers will continue to search the "point in time" snapshot they had opened, and won't see the newly created index until they re-open. There are also <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a126123a1a5cdecf263e45e5a36369457">constructors</a> with no <code>create</code> argument which will create a new index if there is not already an index at the provided path and otherwise open the existing index.In either case, documents are added with <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a000da5a984e6cce2aee03cbaf121a53f" title="Adds a document to this index. If the document contains more than SetMaxFieldLength(int) terms for a ...">AddDocument(Document)</a> and removed with <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a07b556766e1a2a68836906f3d66ffc27" title="Deletes the document(s) containing term.">DeleteDocuments(Term)</a> or <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a2d79488123fefa3e4bbda53b94ae3e89" title="Deletes the document(s) matching the provided query.">DeleteDocuments(Query)</a>. A document can be updated with <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a3667a5f5d4cffeb250ed20c2da19178b" title="Updates a document by first deleting the document(s) containing term and then adding the new document...">UpdateDocument(Term, Document)</a> (which just deletes and then adds the entire document). When finished adding, deleting and updating documents, <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_writer.html#abe4383aeee76431a2b30b10e5ffb4b87" title="Commits all changes to an index and closes all associated files. Note that this may be a costly opera...">Close()</a> should be called.<a class="anchor" id="flush"></a> These changes are buffered in memory and periodically flushed to the <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a3b1c7cb1f5060b72d2cd346870525c3c" title="Returns the Directory used by this index. ">Directory</a> (during the above method calls). A flush is triggered when there are enough buffered deletes (see <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a6ba86647b33915ad12d588238fbd996e" title="Determines the minimal number of delete terms required before the buffered in-memory delete terms are...">SetMaxBufferedDeleteTerms</a>) or enough added documents since the last flush, whichever is sooner. For the added documents, flushing is triggered either by RAM usage of the documents (see <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_writer.html#aee00b6cfce82c5e8e7eb088afbfcd465" title="Determines the amount of RAM that may be used for buffering added documents and deletions before they...">SetRAMBufferSizeMB</a>) or the number of added documents. The default is to flush when RAM usage hits 16 MB. For best indexing speed you should flush by RAM usage with a large RAM buffer. Note that flushing just moves the internal buffered state in <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a> into the index, but these changes are not visible to <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_reader.html" title="IndexReader is an abstract class, providing an interface for accessing an index. Search of an index i...">IndexReader</a> until either <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_writer.html#ad1df12452bb45f153d9d06e1c160e2ff" title="Commits all pending changes (added &amp; deleted documents, optimizations, segment merges, added indexes, etc.) to the index, and syncs all referenced index files, such that a reader will see the changes and the index updates will survive an OS or machine crash or power loss. Note that this does not wait for any running background merges to finish. This may be a costly operation, so you should test the cost in your application and do it only when really necessary.">Commit()</a> or <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_writer.html#abe4383aeee76431a2b30b10e5ffb4b87" title="Commits all changes to an index and closes all associated files. Note that this may be a costly opera...">Close()</a> is called. A flush may also trigger one or more segment merges which by default run with a background thread so as not to block the addDocument calls (see <a href="#mergePolicy">below</a> for changing the <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_merge_scheduler.html" title="Expert: IndexWriter uses an instance implementing this interface to execute the merges selected by a ...">MergeScheduler</a>). If an index will not have more documents added for a while and optimal search performance is desired, then either the full <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a19cfeeb684bdfee1802e51fcb9d49559" title="Requests an &quot;optimize&quot; operation on an index, priming the index for the fastest available search...">Optimize()</a> method or partial <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a214dc271d1438e9072dda4cf33962ec7" title="Optimize the index down to &lt;= maxNumSegments. If maxNumSegments==1 then this is the same as Optimize(...">Optimize(int)</a> method should be called before the index is closed. Opening an <code><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a></code> creates a lock file for the directory in use. Trying to open another <code><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a></code> on the same directory will lead to a <a class="el" href="_index_writer_8cs.html#a681d344289754da86d367afaac7bd3d7">LockObtainFailedException</a>. The <a class="el" href="_index_writer_8cs.html#a681d344289754da86d367afaac7bd3d7">LockObtainFailedException</a> is also thrown if an <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_reader.html" title="IndexReader is an abstract class, providing an interface for accessing an index. Search of an index i...">IndexReader</a> on the same directory is used to delete documents from the index. <a href="class_lucene_1_1_net_1_1_index_1_1_index_writer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_int_block_pool.html">IntBlockPool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_inverted_doc_consumer.html">InvertedDocConsumer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_inverted_doc_consumer_per_field.html">InvertedDocConsumerPerField</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_inverted_doc_consumer_per_thread.html">InvertedDocConsumerPerThread</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_inverted_doc_end_consumer.html">InvertedDocEndConsumer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_inverted_doc_end_consumer_per_field.html">InvertedDocEndConsumerPerField</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_inverted_doc_end_consumer_per_thread.html">InvertedDocEndConsumerPerThread</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_keep_only_last_commit_deletion_policy.html">KeepOnlyLastCommitDeletionPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="interface_lucene_1_1_net_1_1_index_1_1_index_deletion_policy.html" title="Expert: policy for deletion of stale index commits.">IndexDeletionPolicy</a> implementation that keeps only the most recent commit and immediately removes all prior commits after a new commit is done. This is the default deletion policy.  <a href="class_lucene_1_1_net_1_1_index_1_1_keep_only_last_commit_deletion_policy.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_log_byte_size_merge_policy.html">LogByteSizeMergePolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_log_merge_policy.html" title="This class implements a MergePolicy that tries to merge segments into levels of exponentially increas...">LogMergePolicy</a> that measures size of a segment as the total byte size of the segment's files.  <a href="class_lucene_1_1_net_1_1_index_1_1_log_byte_size_merge_policy.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_log_doc_merge_policy.html">LogDocMergePolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_log_merge_policy.html" title="This class implements a MergePolicy that tries to merge segments into levels of exponentially increas...">LogMergePolicy</a> that measures size of a segment as the number of documents (not taking deletions into account).  <a href="class_lucene_1_1_net_1_1_index_1_1_log_doc_merge_policy.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_log_merge_policy.html">LogMergePolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_merge_policy.html" title="Expert: a MergePolicy determines the sequence of primitive merge operations to be used for overall me...">MergePolicy</a> that tries to merge segments into levels of exponentially increasing size, where each level has fewer segments than the value of the merge factor. Whenever extra segments (beyond the merge factor upper bound) are encountered, all segments within the level are merged. You can get or set the merge factor using <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_log_merge_policy.html#a7b619621da6f4aff4deb17be8ab5f97b" title="Gets or sets how often segment indices are merged by addDocument(). With smaller values, less RAM is used while indexing, and searches on unoptimized indices are faster, but indexing speed is slower. With larger values, more RAM is used during indexing, and while searches on unoptimized indices are slower, indexing is faster. Thus larger values (&gt; 10) are best for batch index creation, and smaller values (&lt; 10) for indices that are interactively maintained. ">MergeFactor</a> and <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_log_merge_policy.html#a7b619621da6f4aff4deb17be8ab5f97b" title="Gets or sets how often segment indices are merged by addDocument(). With smaller values, less RAM is used while indexing, and searches on unoptimized indices are faster, but indexing speed is slower. With larger values, more RAM is used during indexing, and while searches on unoptimized indices are slower, indexing is faster. Thus larger values (&gt; 10) are best for batch index creation, and smaller values (&lt; 10) for indices that are interactively maintained. ">MergeFactor</a> respectively. <a href="class_lucene_1_1_net_1_1_index_1_1_log_merge_policy.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_merge_doc_i_d_remapper.html">MergeDocIDRemapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remaps docIDs after a merge has completed, where the merged segments had at least one deletion. This is used to renumber the buffered deletes in <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a> when a merge of segments with deletions commits.  <a href="class_lucene_1_1_net_1_1_index_1_1_merge_doc_i_d_remapper.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_merge_policy.html">MergePolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: a <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_merge_policy.html" title="Expert: a MergePolicy determines the sequence of primitive merge operations to be used for overall me...">MergePolicy</a> determines the sequence of primitive merge operations to be used for overall merge and optimize operations. <a href="class_lucene_1_1_net_1_1_index_1_1_merge_policy.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_merge_scheduler.html">MergeScheduler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a> uses an instance implementing this interface to execute the merges selected by a <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_merge_policy.html" title="Expert: a MergePolicy determines the sequence of primitive merge operations to be used for overall me...">MergePolicy</a>. The default <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_merge_scheduler.html" title="Expert: IndexWriter uses an instance implementing this interface to execute the merges selected by a ...">MergeScheduler</a> is <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_concurrent_merge_scheduler.html" title="A MergeScheduler that runs each merge using a separate thread, up until a maximum number of threads (...">ConcurrentMergeScheduler</a>. <a href="class_lucene_1_1_net_1_1_index_1_1_merge_scheduler.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_multi_level_skip_list_reader.html">MultiLevelSkipListReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This abstract class reads skip lists with multiple levels.  <a href="class_lucene_1_1_net_1_1_index_1_1_multi_level_skip_list_reader.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_multi_level_skip_list_writer.html">MultiLevelSkipListWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This abstract class writes skip lists with multiple levels.  <a href="class_lucene_1_1_net_1_1_index_1_1_multi_level_skip_list_writer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_multiple_term_positions.html">MultipleTermPositions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows you to iterate over the <a class="el" href="interface_lucene_1_1_net_1_1_index_1_1_term_positions.html" title="TermPositions provides an interface for enumerating the &lt;document, frequency, &lt;position&gt;* &gt; tuples fo...">TermPositions</a> for multiple <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_term.html" title="A Term represents a word from text. This is the unit of search. It is composed of two elements...">Term</a>s as a single <a class="el" href="interface_lucene_1_1_net_1_1_index_1_1_term_positions.html" title="TermPositions provides an interface for enumerating the &lt;document, frequency, &lt;position&gt;* &gt; tuples fo...">TermPositions</a>.  <a href="class_lucene_1_1_net_1_1_index_1_1_multiple_term_positions.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_multi_reader.html">MultiReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_reader.html" title="IndexReader is an abstract class, providing an interface for accessing an index. Search of an index i...">IndexReader</a> which reads multiple indexes, appending their content.  <a href="class_lucene_1_1_net_1_1_index_1_1_multi_reader.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_norms_writer.html">NormsWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes norms. Each thread X field accumulates the norms for the doc/fields it saw, then the flush method below merges all of these together into a single _X.nrm file.  <a href="class_lucene_1_1_net_1_1_index_1_1_norms_writer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_norms_writer_per_field.html">NormsWriterPerField</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Taps into <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_doc_inverter.html" title="This is a DocFieldConsumer that inverts each field, separately, from a Document, and accepts a Invert...">DocInverter</a>, as an <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_inverted_doc_end_consumer.html">InvertedDocEndConsumer</a>, which is called at the end of inverting each field. We just look at the length for the field (docState.length) and record the norm.  <a href="class_lucene_1_1_net_1_1_index_1_1_norms_writer_per_field.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_norms_writer_per_thread.html">NormsWriterPerThread</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_parallel_reader.html">ParallelReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_reader.html" title="IndexReader is an abstract class, providing an interface for accessing an index. Search of an index i...">IndexReader</a> which reads multiple, parallel indexes. Each index added must have the same number of documents, but typically each contains different fields. Each document contains the union of the fields of all documents with the same document number. When searching, matches for a query term are from the first index added that has the field.  <a href="class_lucene_1_1_net_1_1_index_1_1_parallel_reader.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_payload.html">Payload</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_payload.html" title="A Payload is metadata that can be stored together with each occurrence of a term. This metadata is st...">Payload</a> is metadata that can be stored together with each occurrence of a term. This metadata is stored inline in the posting list of the specific term. To store payloads in the index a <a class="el" href="_attribute_source_8cs.html#a205730fc8c2839cf92051d131140dae0">TokenStream</a> has to be used that produces payload data. Use <a class="el" href="interface_lucene_1_1_net_1_1_index_1_1_term_positions.html#adbfebfa3b7a2bd01f3ba0eede68ea964" title="Returns the length of the payload at the current term position. This is invalid until NextPosition() ...">TermPositions.PayloadLength</a> and <a class="el" href="interface_lucene_1_1_net_1_1_index_1_1_term_positions.html#ad3740df833e76a4850d88eaab68a9629" title="Returns the payload data at the current term position. This is invalid until NextPosition() is called...">TermPositions.GetPayload(byte[], int)</a> to retrieve the payloads from the index.<br/>
  <a href="class_lucene_1_1_net_1_1_index_1_1_payload.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_position_based_term_vector_mapper.html">PositionBasedTermVectorMapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each Field, store position by position information. It ignores frequency information This is not thread-safe.  <a href="class_lucene_1_1_net_1_1_index_1_1_position_based_term_vector_mapper.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_raw_posting_list.html">RawPostingList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base class for an in-memory posting list, keyed by a Token. <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_terms_hash.html" title="This class implements InvertedDocConsumer, which is passed each token produced by the analyzer on eac...">TermsHash</a> maintains a hash table holding one instance of this per unique Token. Consumers of <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_terms_hash.html" title="This class implements InvertedDocConsumer, which is passed each token produced by the analyzer on eac...">TermsHash</a> (<a class="el" href="class_lucene_1_1_net_1_1_index_1_1_terms_hash_consumer.html">TermsHashConsumer</a>) must subclass this class with its own concrete class. FreqProxTermsWriter.PostingList is a private inner class used for the freq/prox postings, and TermVectorsTermsWriter.PostingList is a private inner class used to hold TermVectors postings.  <a href="class_lucene_1_1_net_1_1_index_1_1_raw_posting_list.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_read_only_directory_reader.html">ReadOnlyDirectoryReader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_read_only_segment_reader.html">ReadOnlySegmentReader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_reusable_string_reader.html">ReusableStringReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_documents_writer.html" title="This class accepts multiple added documents and directly writes a single segment file. It does this more efficiently than creating a single segment per document (with DocumentWriter) and doing standard merges on those segments.">DocumentsWriter</a> to implemented a StringReader that can be reset to a new string; we use this when tokenizing the string value from a Field.  <a href="class_lucene_1_1_net_1_1_index_1_1_reusable_string_reader.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_segment_info.html">SegmentInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about a segment such as it's name, directory, and files related to the segment.  <a href="class_lucene_1_1_net_1_1_index_1_1_segment_info.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_segment_infos.html">SegmentInfos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A collection of segmentInfo objects with methods for operating on those segments in relation to the file system.  <a href="class_lucene_1_1_net_1_1_index_1_1_segment_infos.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_segment_merge_info.html">SegmentMergeInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_segment_merge_queue.html">SegmentMergeQueue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_segment_merger.html">SegmentMerger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_segment_merger.html" title="The SegmentMerger class combines two or more Segments, represented by an IndexReader (Add...">SegmentMerger</a> class combines two or more Segments, represented by an <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_reader.html" title="IndexReader is an abstract class, providing an interface for accessing an index. Search of an index i...">IndexReader</a> (<a class="el" href="class_lucene_1_1_net_1_1_index_1_1_segment_merger.html#a0f3e8f23783a2846d224c8c6c4316556" title="Add an IndexReader to the collection of readers that are to be merged">Add</a>, into a single Segment. After adding the appropriate readers, call the merge method to combine the segments. If the compoundFile flag is set, then the segments will be merged into a compound file.  <a href="class_lucene_1_1_net_1_1_index_1_1_segment_merger.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_segment_reader.html">SegmentReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>NOTE:</b> This API is new and still experimental (subject to change suddenly in the next release) <a href="class_lucene_1_1_net_1_1_index_1_1_segment_reader.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>SegmentTermDocs</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>SegmentTermEnum</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>SegmentTermPositions</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_segment_term_position_vector.html">SegmentTermPositionVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_segment_term_vector.html">SegmentTermVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_segment_write_state.html">SegmentWriteState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_serial_merge_scheduler.html">SerialMergeScheduler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_merge_scheduler.html" title="Expert: IndexWriter uses an instance implementing this interface to execute the merges selected by a ...">MergeScheduler</a> that simply does each merge sequentially, using the current thread.  <a href="class_lucene_1_1_net_1_1_index_1_1_serial_merge_scheduler.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_snapshot_deletion_policy.html">SnapshotDeletionPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="interface_lucene_1_1_net_1_1_index_1_1_index_deletion_policy.html" title="Expert: policy for deletion of stale index commits.">IndexDeletionPolicy</a> that wraps around any other <a class="el" href="interface_lucene_1_1_net_1_1_index_1_1_index_deletion_policy.html" title="Expert: policy for deletion of stale index commits.">IndexDeletionPolicy</a> and adds the ability to hold and later release a single "snapshot" of an index. While the snapshot is held, the <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a> will not remove any files associated with it even if the index is otherwise being actively, arbitrarily changed. Because we wrap another arbitrary <a class="el" href="interface_lucene_1_1_net_1_1_index_1_1_index_deletion_policy.html" title="Expert: policy for deletion of stale index commits.">IndexDeletionPolicy</a>, this gives you the freedom to continue using whatever <a class="el" href="interface_lucene_1_1_net_1_1_index_1_1_index_deletion_policy.html" title="Expert: policy for deletion of stale index commits.">IndexDeletionPolicy</a> you would normally want to use with your index. Note that you can re-use a single instance of <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_snapshot_deletion_policy.html" title="A IndexDeletionPolicy that wraps around any other IndexDeletionPolicy and adds the ability to hold an...">SnapshotDeletionPolicy</a> across multiple writers as long as they are against the same index Directory. Any snapshot held when a writer is closed will "survive" when the next writer is opened.  <a href="class_lucene_1_1_net_1_1_index_1_1_snapshot_deletion_policy.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_sorted_term_vector_mapper.html">SortedTermVectorMapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_lucene_1_1_net_1_1_store.html">Store</a> a sorted collection of <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_term_vector_entry.html" title="Convenience class for holding TermVector information.">Lucene.Net.Index.TermVectorEntry</a>s. Collects all term information into a single, SortedSet. <br/>
 NOTE: This Mapper ignores all Field information for the Document. This means that if you are using offset/positions you will not know what Fields they correlate with. <br/>
 This is not thread-safe  <a href="class_lucene_1_1_net_1_1_index_1_1_sorted_term_vector_mapper.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_stale_reader_exception.html">StaleReaderException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This exception is thrown when an <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_reader.html" title="IndexReader is an abstract class, providing an interface for accessing an index. Search of an index i...">IndexReader</a> tries to make changes to the index (via <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_reader.html#a3b7fd13e4df23385d13d129a361e632e" title="Deletes the document numbered docNum. Once a document is deleted it will not appear in TermDocs or Te...">IndexReader.DeleteDocument</a> , <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_reader.html#aa45508588151dc9292027f8a88a5abb4" title="Undeletes all documents currently marked as deleted in this index.">IndexReader.UndeleteAll</a> or IndexReader.SetNorm(int,string,float)) but changes have already been committed to the index since this reader was instantiated. When this happens you must open a new reader on the current index to make the changes.  <a href="class_lucene_1_1_net_1_1_index_1_1_stale_reader_exception.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_stored_fields_writer.html">StoredFieldsWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_doc_field_consumer.html">DocFieldConsumer</a> that writes stored fields.  <a href="class_lucene_1_1_net_1_1_index_1_1_stored_fields_writer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_stored_fields_writer_per_thread.html">StoredFieldsWriterPerThread</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_term.html">Term</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_term.html" title="A Term represents a word from text. This is the unit of search. It is composed of two elements...">Term</a> represents a word from text. This is the unit of search. It is composed of two elements, the text of the word, as a string, and the name of the field that the text occured in, an interned string. Note that terms may represent more than words from text fields, but also things like dates, email addresses, urls, etc.  <a href="class_lucene_1_1_net_1_1_index_1_1_term.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_term_buffer.html">TermBuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_lucene_1_1_net_1_1_index_1_1_term_docs.html">TermDocs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="interface_lucene_1_1_net_1_1_index_1_1_term_docs.html" title="TermDocs provides an interface for enumerating &lt;document, frequency&gt; pairs for a term. The document portion names each document containing the term. Documents are indicated by number. The frequency portion gives the number of times the term occurred in each document. The pairs are ordered by document number. ">TermDocs</a> provides an interface for enumerating &lt;document, frequency&gt; pairs for a term. The document portion names each document containing the term. <a class="el" href="namespace_lucene_1_1_net_1_1_documents.html">Documents</a> are indicated by number. The frequency portion gives the number of times the term occurred in each document. The pairs are ordered by document number.  <a href="interface_lucene_1_1_net_1_1_index_1_1_term_docs.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_term_enum.html">TermEnum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for enumerating terms. <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_term.html" title="A Term represents a word from text. This is the unit of search. It is composed of two elements...">Term</a> enumerations are always ordered by Term.compareTo(). Each term in the enumeration is greater than all that precede it.  <a href="class_lucene_1_1_net_1_1_index_1_1_term_enum.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_lucene_1_1_net_1_1_index_1_1_i_term_freq_vector.html">ITermFreqVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to stored term vector of a document field. The vector consists of the name of the field, an array of the terms tha occur in the field of the <a class="el" href="class_lucene_1_1_net_1_1_documents_1_1_document.html" title="Documents are the unit of indexing and search.">Lucene.Net.Documents.Document</a> and a parallel array of frequencies. Thus, getTermFrequencies()[5] corresponds with the frequency of getTerms()[5], assuming there are at least 5 terms in the Document.  <a href="interface_lucene_1_1_net_1_1_index_1_1_i_term_freq_vector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_term_info.html">TermInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_term_info.html" title="A TermInfo is the record of information stored for a term.">TermInfo</a> is the record of information stored for a term. <a href="class_lucene_1_1_net_1_1_index_1_1_term_info.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_term_infos_reader.html">TermInfosReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This stores a monotonically increasing set of &lt;<a class="el" href="class_lucene_1_1_net_1_1_index_1_1_term.html" title="A Term represents a word from text. This is the unit of search. It is composed of two elements...">Term</a>, <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_term_info.html" title="A TermInfo is the record of information stored for a term.">TermInfo</a>&gt; pairs in a Directory. Pairs are accessed either by <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_term.html" title="A Term represents a word from text. This is the unit of search. It is composed of two elements...">Term</a> or by ordinal position the set.  <a href="class_lucene_1_1_net_1_1_index_1_1_term_infos_reader.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_term_infos_writer.html">TermInfosWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This stores a monotonically increasing set of &lt;<a class="el" href="class_lucene_1_1_net_1_1_index_1_1_term.html" title="A Term represents a word from text. This is the unit of search. It is composed of two elements...">Term</a>, <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_term_info.html" title="A TermInfo is the record of information stored for a term.">TermInfo</a>&gt; pairs in a Directory. A TermInfos can be written once, in order.  <a href="class_lucene_1_1_net_1_1_index_1_1_term_infos_writer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_lucene_1_1_net_1_1_index_1_1_term_positions.html">TermPositions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="interface_lucene_1_1_net_1_1_index_1_1_term_positions.html" title="TermPositions provides an interface for enumerating the &lt;document, frequency, &lt;position&gt;* &gt; tuples fo...">TermPositions</a> provides an interface for enumerating the &lt;document, frequency, &lt;position&gt;* &gt; tuples for a term. The document and frequency are the same as for a <a class="el" href="interface_lucene_1_1_net_1_1_index_1_1_term_docs.html" title="TermDocs provides an interface for enumerating &lt;document, frequency&gt; pairs for a term. The document portion names each document containing the term. Documents are indicated by number. The frequency portion gives the number of times the term occurred in each document. The pairs are ordered by document number. ">TermDocs</a>. The positions portion lists the ordinal positions of each occurrence of a term in a document.  <a href="interface_lucene_1_1_net_1_1_index_1_1_term_positions.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_lucene_1_1_net_1_1_index_1_1_term_position_vector.html">TermPositionVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends <code>TermFreqVector</code> to provide additional information about positions in which each of the terms is found. A <a class="el" href="interface_lucene_1_1_net_1_1_index_1_1_term_position_vector.html" title="Extends TermFreqVector to provide additional information about positions in which each of the terms i...">TermPositionVector</a> not necessarily contains both positions and offsets, but at least one of these arrays exists.  <a href="interface_lucene_1_1_net_1_1_index_1_1_term_position_vector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_terms_hash.html">TermsHash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_inverted_doc_consumer.html">InvertedDocConsumer</a>, which is passed each token produced by the analyzer on each field. It stores these tokens in a hash table, and allocates separate byte streams per token. Consumers of this class, eg <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_freq_prox_terms_writer.html">FreqProxTermsWriter</a> and <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_term_vectors_terms_writer.html">TermVectorsTermsWriter</a> , write their own byte streams under each term.  <a href="class_lucene_1_1_net_1_1_index_1_1_terms_hash.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_terms_hash_consumer.html">TermsHashConsumer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_terms_hash_consumer_per_field.html">TermsHashConsumerPerField</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement this class to plug into the <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_terms_hash.html" title="This class implements InvertedDocConsumer, which is passed each token produced by the analyzer on eac...">TermsHash</a> processor, which inverts and stores Tokens into a hash table and provides an API for writing bytes into multiple streams for each unique Token.  <a href="class_lucene_1_1_net_1_1_index_1_1_terms_hash_consumer_per_field.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_terms_hash_consumer_per_thread.html">TermsHashConsumerPerThread</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_terms_hash_per_field.html">TermsHashPerField</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_terms_hash_per_thread.html">TermsHashPerThread</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_term_vector_entry.html">TermVectorEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience class for holding TermVector information. <a href="class_lucene_1_1_net_1_1_index_1_1_term_vector_entry.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_term_vector_entry_freq_sorted_comparator.html">TermVectorEntryFreqSortedComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_term_vector_entry.html" title="Convenience class for holding TermVector information.">Lucene.Net.Index.TermVectorEntry</a>s first by frequency and then by the term (case-sensitive)  <a href="class_lucene_1_1_net_1_1_index_1_1_term_vector_entry_freq_sorted_comparator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_term_vector_mapper.html">TermVectorMapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_term_vector_mapper.html" title="The TermVectorMapper can be used to map Term Vectors into your own structure instead of the parallel ...">TermVectorMapper</a> can be used to map <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_term.html" title="A Term represents a word from text. This is the unit of search. It is composed of two elements...">Term</a> Vectors into your own structure instead of the parallel array structure used by <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_index_reader.html#a93ef270cec13352696660ca154d4a1be" title="Return a term frequency vector for the specified document and field. The returned vector contains ter...">Lucene.Net.Index.IndexReader.GetTermFreqVector(int,String)</a>. It is up to the implementation to make sure it is thread-safe.  <a href="class_lucene_1_1_net_1_1_index_1_1_term_vector_mapper.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lucene_1_1_net_1_1_index_1_1_term_vector_offset_info.html">TermVectorOffsetInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="struct_lucene_1_1_net_1_1_index_1_1_term_vector_offset_info.html" title="The TermVectorOffsetInfo class holds information pertaining to a Term in a Lucene.Net.Index.TermPositionVector&#39;s offset information. This offset information is the character offset as set during the Analysis phase (and thus may not be the actual offset in the original content). ">TermVectorOffsetInfo</a> class holds information pertaining to a <a class="el" href="class_lucene_1_1_net_1_1_index_1_1_term.html" title="A Term represents a word from text. This is the unit of search. It is composed of two elements...">Term</a> in a <a class="el" href="interface_lucene_1_1_net_1_1_index_1_1_term_position_vector.html" title="Extends TermFreqVector to provide additional information about positions in which each of the terms i...">Lucene.Net.Index.TermPositionVector</a>'s offset information. This offset information is the character offset as set during the <a class="el" href="namespace_lucene_1_1_net_1_1_analysis.html">Analysis</a> phase (and thus may not be the actual offset in the original content).  <a href="struct_lucene_1_1_net_1_1_index_1_1_term_vector_offset_info.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_term_vectors_reader.html">TermVectorsReader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_parallel_array_term_vector_mapper.html">ParallelArrayTermVectorMapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Models the existing parallel array structure <a href="class_lucene_1_1_net_1_1_index_1_1_parallel_array_term_vector_mapper.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_term_vectors_terms_writer.html">TermVectorsTermsWriter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_term_vectors_terms_writer_per_field.html">TermVectorsTermsWriterPerField</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_term_vectors_terms_writer_per_thread.html">TermVectorsTermsWriterPerThread</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_index_1_1_term_vectors_writer.html">TermVectorsWriter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a1249a979c8084c669bad82742bca8a63"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lucene_1_1_net_1_1_index.html#a1249a979c8084c669bad82742bca8a63">FieldParser</a> { <a class="el" href="namespace_lucene_1_1_net_1_1_index.html#a1249a979c8084c669bad82742bca8a63a27118326006d3829667a400ad23d5d98">String</a>, 
<a class="el" href="namespace_lucene_1_1_net_1_1_index.html#a1249a979c8084c669bad82742bca8a63a87322391cc6e8948ce9fd5d6cb84fced">Numeric</a>
 }</td></tr>
<tr class="memdesc:a1249a979c8084c669bad82742bca8a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of parser for the value of the term.  <a href="namespace_lucene_1_1_net_1_1_index.html#a1249a979c8084c669bad82742bca8a63">More...</a><br/></td></tr>
<tr class="separator:a1249a979c8084c669bad82742bca8a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a1249a979c8084c669bad82742bca8a63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_lucene_1_1_net_1_1_index.html#a1249a979c8084c669bad82742bca8a63">Lucene.Net.Index.FieldParser</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of parser for the value of the term. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a1249a979c8084c669bad82742bca8a63a27118326006d3829667a400ad23d5d98"></a>String</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a1249a979c8084c669bad82742bca8a63a87322391cc6e8948ce9fd5d6cb84fced"></a>Numeric</em>&nbsp;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_field_enumerator_8cs_source.html#l00031">31</a> of file <a class="el" href="_field_enumerator_8cs_source.html">FieldEnumerator.cs</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 3 2013 02:12:49 for Lucene.Net by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3
</small></address>
</body>
</html>
