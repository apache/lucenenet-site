<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>Lucene.Net: Lucene.Net.Index.IndexWriter Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../lucene-net-icon-128x128.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Lucene.Net
   &#160;<span id="projectnumber">3.0.3</span>
   </div>
   <div id="projectbrief">Lucene.Net is a port of the Lucene search engine library, written in C# and targeted at .NET runtime users.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="../../classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="../../hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../df/d7a/namespace_lucene.html">Lucene</a></li><li class="navelem"><a class="el" href="../../d3/dd0/namespace_lucene_1_1_net.html">Net</a></li><li class="navelem"><a class="el" href="../../da/d43/namespace_lucene_1_1_net_1_1_index.html">Index</a></li><li class="navelem"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html">IndexWriter</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="../../db/de7/class_lucene_1_1_net_1_1_index_1_1_index_writer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Lucene.Net.Index.IndexWriter Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An <code><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a></code> creates and maintains an index. The <code>create</code> argument to the <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#af4620c14320934601058e0e9cac9bfab">constructor</a> determines whether a new index is created, or whether an existing index is opened. Note that you can open an index with <code>create=true</code> even while readers are using the index. The old readers will continue to search the "point in time" snapshot they had opened, and won't see the newly created index until they re-open. There are also <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a126123a1a5cdecf263e45e5a36369457">constructors</a> with no <code>create</code> argument which will create a new index if there is not already an index at the provided path and otherwise open the existing index.In either case, documents are added with <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a000da5a984e6cce2aee03cbaf121a53f" title="Adds a document to this index. If the document contains more than SetMaxFieldLength(int) terms for a ...">AddDocument(Document)</a> and removed with <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a07b556766e1a2a68836906f3d66ffc27" title="Deletes the document(s) containing term.">DeleteDocuments(Term)</a> or <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a2d79488123fefa3e4bbda53b94ae3e89" title="Deletes the document(s) matching the provided query.">DeleteDocuments(Query)</a>. A document can be updated with <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a3667a5f5d4cffeb250ed20c2da19178b" title="Updates a document by first deleting the document(s) containing term and then adding the new document...">UpdateDocument(Term, Document)</a> (which just deletes and then adds the entire document). When finished adding, deleting and updating documents, <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#abe4383aeee76431a2b30b10e5ffb4b87" title="Commits all changes to an index and closes all associated files. Note that this may be a costly opera...">Close()</a> should be called.<a class="anchor" id="flush"></a> These changes are buffered in memory and periodically flushed to the <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a3b1c7cb1f5060b72d2cd346870525c3c" title="Returns the Directory used by this index. ">Directory</a> (during the above method calls). A flush is triggered when there are enough buffered deletes (see <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a6ba86647b33915ad12d588238fbd996e" title="Determines the minimal number of delete terms required before the buffered in-memory delete terms are...">SetMaxBufferedDeleteTerms</a>) or enough added documents since the last flush, whichever is sooner. For the added documents, flushing is triggered either by RAM usage of the documents (see <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#aee00b6cfce82c5e8e7eb088afbfcd465" title="Determines the amount of RAM that may be used for buffering added documents and deletions before they...">SetRAMBufferSizeMB</a>) or the number of added documents. The default is to flush when RAM usage hits 16 MB. For best indexing speed you should flush by RAM usage with a large RAM buffer. Note that flushing just moves the internal buffered state in <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a> into the index, but these changes are not visible to <a class="el" href="../../d6/d27/class_lucene_1_1_net_1_1_index_1_1_index_reader.html" title="IndexReader is an abstract class, providing an interface for accessing an index. Search of an index i...">IndexReader</a> until either <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#ad1df12452bb45f153d9d06e1c160e2ff" title="Commits all pending changes (added &amp; deleted documents, optimizations, segment merges, added indexes, etc.) to the index, and syncs all referenced index files, such that a reader will see the changes and the index updates will survive an OS or machine crash or power loss. Note that this does not wait for any running background merges to finish. This may be a costly operation, so you should test the cost in your application and do it only when really necessary.">Commit()</a> or <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#abe4383aeee76431a2b30b10e5ffb4b87" title="Commits all changes to an index and closes all associated files. Note that this may be a costly opera...">Close()</a> is called. A flush may also trigger one or more segment merges which by default run with a background thread so as not to block the addDocument calls (see <a href="../../#mergePolicy">below</a> for changing the <a class="el" href="../../d9/d30/class_lucene_1_1_net_1_1_index_1_1_merge_scheduler.html" title="Expert: IndexWriter uses an instance implementing this interface to execute the merges selected by a ...">MergeScheduler</a>). If an index will not have more documents added for a while and optimal search performance is desired, then either the full <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a19cfeeb684bdfee1802e51fcb9d49559" title="Requests an &quot;optimize&quot; operation on an index, priming the index for the fastest available search...">Optimize()</a> method or partial <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a214dc271d1438e9072dda4cf33962ec7" title="Optimize the index down to &lt;= maxNumSegments. If maxNumSegments==1 then this is the same as Optimize(...">Optimize(int)</a> method should be called before the index is closed. Opening an <code><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a></code> creates a lock file for the directory in use. Trying to open another <code><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a></code> on the same directory will lead to a <a class="el" href="../../d0/d90/_index_writer_8cs.html#a681d344289754da86d367afaac7bd3d7">LockObtainFailedException</a>. The <a class="el" href="../../d0/d90/_index_writer_8cs.html#a681d344289754da86d367afaac7bd3d7">LockObtainFailedException</a> is also thrown if an <a class="el" href="../../d6/d27/class_lucene_1_1_net_1_1_index_1_1_index_reader.html" title="IndexReader is an abstract class, providing an interface for accessing an index. Search of an index i...">IndexReader</a> on the same directory is used to delete documents from the index. 
 <a href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#details">More...</a></p>

<p>Inherits IDisposable.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/ddd/class_lucene_1_1_net_1_1_index_1_1_index_writer_1_1_index_reader_warmer.html">IndexReaderWarmer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a57044cd06b7b2b00bb33a08ad666d4c5" title="Expert: returns a readonly reader, covering all committed as well as un-committed changes to the inde...">GetReader()</a> has been called (ie, this writer is in near real-time mode), then after a merge completes, this class can be invoked to warm the reader on the newly merged segment, before the merge commits. This is not required for near real-time search, but will reduce search latency on opening a new near real-time reader after a merge completes.  <a href="../../de/ddd/class_lucene_1_1_net_1_1_index_1_1_index_writer_1_1_index_reader_warmer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d33/class_lucene_1_1_net_1_1_index_1_1_index_writer_1_1_max_field_length.html">MaxFieldLength</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies maximum field length (in number of tokens/terms) in <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a> constructors. <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a91be1a71d5a51f7232dc2b6f5e021d9e" title="The maximum number of terms that will be indexed for a single field in a document. This limits the amount of memory required for indexing, so that collections with very large files will not crash the indexing process by running out of memory. This setting refers to the number of running terms, not to the number of different terms.Note: this silently truncates large documents, excluding from the index all terms that occur further in the document. If you know your source documents are large, be sure to set this value high enough to accomodate the expected size. If you set it to Integer.MAX_VALUE, then the only limit is your memory, but you should anticipate an OutOfMemoryError.By default, no more than DEFAULT_MAX_FIELD_LENGTH terms will be indexed for a field. ">SetMaxFieldLength(int)</a> overrides the value set by the constructor.  <a href="../../d4/d33/class_lucene_1_1_net_1_1_index_1_1_index_writer_1_1_max_field_length.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>ReaderPool</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds shared <a class="el" href="../../dc/d8f/class_lucene_1_1_net_1_1_index_1_1_segment_reader.html" title="NOTE: This API is new and still experimental (subject to change suddenly in the next release)...">SegmentReader</a> instances. <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a> uses SegmentReaders for 1) applying deletes, 2) doing merges, 3) handing out a real-time reader. This pool reuses instances of the SegmentReaders in all these places if it is in "near real-time mode" (getReader() has been called on this instance). <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a57044cd06b7b2b00bb33a08ad666d4c5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d6/d27/class_lucene_1_1_net_1_1_index_1_1_index_reader.html">IndexReader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a57044cd06b7b2b00bb33a08ad666d4c5">GetReader</a> ()</td></tr>
<tr class="memdesc:a57044cd06b7b2b00bb33a08ad666d4c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: returns a readonly reader, covering all committed as well as un-committed changes to the index. This provides "near real-time" searching, in that changes made during an <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a> session can be quickly made available for searching without closing the writer nor calling <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#ad1df12452bb45f153d9d06e1c160e2ff" title="Commits all pending changes (added &amp; deleted documents, optimizations, segment merges, added indexes, etc.) to the index, and syncs all referenced index files, such that a reader will see the changes and the index updates will survive an OS or machine crash or power loss. Note that this does not wait for any running background merges to finish. This may be a costly operation, so you should test the cost in your application and do it only when really necessary.">Commit()</a>.  <a href="#a57044cd06b7b2b00bb33a08ad666d4c5"></a><br/></td></tr>
<tr class="separator:a57044cd06b7b2b00bb33a08ad666d4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60833a517b62ccfc10647c42b3e37b6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d6/d27/class_lucene_1_1_net_1_1_index_1_1_index_reader.html">IndexReader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#ac60833a517b62ccfc10647c42b3e37b6">GetReader</a> (int termInfosIndexDivisor)</td></tr>
<tr class="memdesc:ac60833a517b62ccfc10647c42b3e37b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: like <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a57044cd06b7b2b00bb33a08ad666d4c5" title="Expert: returns a readonly reader, covering all committed as well as un-committed changes to the inde...">GetReader()</a>, except you can specify which termInfosIndexDivisor should be used for any newly opened readers.  <a href="#ac60833a517b62ccfc10647c42b3e37b6"></a><br/></td></tr>
<tr class="separator:ac60833a517b62ccfc10647c42b3e37b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb4982d5f53568e301068a3eb9e8b86"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#aaeb4982d5f53568e301068a3eb9e8b86">NumDeletedDocs</a> (<a class="el" href="../../d7/d6c/class_lucene_1_1_net_1_1_index_1_1_segment_info.html">SegmentInfo</a> info)</td></tr>
<tr class="memdesc:aaeb4982d5f53568e301068a3eb9e8b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the number of deleted docs for a pooled reader. If the reader isn't being pooled, the segmentInfo's delCount is returned.  <a href="#aaeb4982d5f53568e301068a3eb9e8b86"></a><br/></td></tr>
<tr class="separator:aaeb4982d5f53568e301068a3eb9e8b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3bfaa57bd4eaded7e16e2da30639a1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a1d3bfaa57bd4eaded7e16e2da30639a1">Message</a> (System.String message)</td></tr>
<tr class="memdesc:a1d3bfaa57bd4eaded7e16e2da30639a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a message to the infoStream (if non-null), prefixed with the identifying information for this writer and the thread that's calling it.  <a href="#a1d3bfaa57bd4eaded7e16e2da30639a1"></a><br/></td></tr>
<tr class="separator:a1d3bfaa57bd4eaded7e16e2da30639a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5695d47fe4b1e23ad339fd3e543e3a86"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a5695d47fe4b1e23ad339fd3e543e3a86">SetSimilarity</a> (<a class="el" href="../../d7/d70/_documents_writer_8cs.html#a5431a3a4edd067eec50ca39b5ea99c31">Similarity</a> similarity)</td></tr>
<tr class="memdesc:a5695d47fe4b1e23ad339fd3e543e3a86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: Set the Similarity implementation used by this <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a>.  <a href="#a5695d47fe4b1e23ad339fd3e543e3a86"></a><br/></td></tr>
<tr class="separator:a5695d47fe4b1e23ad339fd3e543e3a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4620c14320934601058e0e9cac9bfab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#af4620c14320934601058e0e9cac9bfab">IndexWriter</a> (<a class="el" href="../../dd/df1/_syns2_index_8cs.html#aada057080323f6e867d8f9c189276716">Directory</a> d, <a class="el" href="../../dd/d53/_more_like_this_8cs.html#a7f807a855319cb4e1efa0e1fcd2a537f">Analyzer</a> a, bool create, <a class="el" href="../../d4/d33/class_lucene_1_1_net_1_1_index_1_1_index_writer_1_1_max_field_length.html">MaxFieldLength</a> mfl)</td></tr>
<tr class="memdesc:af4620c14320934601058e0e9cac9bfab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a> for the index in <code>d</code>. Text will be analyzed with <code>a</code>. If <code>create</code> is true, then a new, empty index will be created in <code>d</code>, replacing the index already there, if any.  <a href="#af4620c14320934601058e0e9cac9bfab"></a><br/></td></tr>
<tr class="separator:af4620c14320934601058e0e9cac9bfab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a126123a1a5cdecf263e45e5a36369457"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a126123a1a5cdecf263e45e5a36369457">IndexWriter</a> (<a class="el" href="../../dd/df1/_syns2_index_8cs.html#aada057080323f6e867d8f9c189276716">Directory</a> d, <a class="el" href="../../dd/d53/_more_like_this_8cs.html#a7f807a855319cb4e1efa0e1fcd2a537f">Analyzer</a> a, <a class="el" href="../../d4/d33/class_lucene_1_1_net_1_1_index_1_1_index_writer_1_1_max_field_length.html">MaxFieldLength</a> mfl)</td></tr>
<tr class="memdesc:a126123a1a5cdecf263e45e5a36369457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a> for the index in <code>d</code>, first creating it if it does not already exist.  <a href="#a126123a1a5cdecf263e45e5a36369457"></a><br/></td></tr>
<tr class="separator:a126123a1a5cdecf263e45e5a36369457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f995f005ff8ec6e2130a46613127765"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a3f995f005ff8ec6e2130a46613127765">IndexWriter</a> (<a class="el" href="../../dd/df1/_syns2_index_8cs.html#aada057080323f6e867d8f9c189276716">Directory</a> d, <a class="el" href="../../dd/d53/_more_like_this_8cs.html#a7f807a855319cb4e1efa0e1fcd2a537f">Analyzer</a> a, <a class="el" href="../../d7/d90/interface_lucene_1_1_net_1_1_index_1_1_index_deletion_policy.html">IndexDeletionPolicy</a> deletionPolicy, <a class="el" href="../../d4/d33/class_lucene_1_1_net_1_1_index_1_1_index_writer_1_1_max_field_length.html">MaxFieldLength</a> mfl)</td></tr>
<tr class="memdesc:a3f995f005ff8ec6e2130a46613127765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: constructs an <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a> with a custom <a class="el" href="../../d7/d90/interface_lucene_1_1_net_1_1_index_1_1_index_deletion_policy.html" title="Expert: policy for deletion of stale index commits.">IndexDeletionPolicy</a> , for the index in <code>d</code>, first creating it if it does not already exist. Text will be analyzed with <code>a</code>.  <a href="#a3f995f005ff8ec6e2130a46613127765"></a><br/></td></tr>
<tr class="separator:a3f995f005ff8ec6e2130a46613127765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116bca44ae8e99e740aa8cfdc06da545"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a116bca44ae8e99e740aa8cfdc06da545">IndexWriter</a> (<a class="el" href="../../dd/df1/_syns2_index_8cs.html#aada057080323f6e867d8f9c189276716">Directory</a> d, <a class="el" href="../../dd/d53/_more_like_this_8cs.html#a7f807a855319cb4e1efa0e1fcd2a537f">Analyzer</a> a, bool create, <a class="el" href="../../d7/d90/interface_lucene_1_1_net_1_1_index_1_1_index_deletion_policy.html">IndexDeletionPolicy</a> deletionPolicy, <a class="el" href="../../d4/d33/class_lucene_1_1_net_1_1_index_1_1_index_writer_1_1_max_field_length.html">MaxFieldLength</a> mfl)</td></tr>
<tr class="memdesc:a116bca44ae8e99e740aa8cfdc06da545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: constructs an <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a> with a custom <a class="el" href="../../d7/d90/interface_lucene_1_1_net_1_1_index_1_1_index_deletion_policy.html" title="Expert: policy for deletion of stale index commits.">IndexDeletionPolicy</a> , for the index in <code>d</code>. Text will be analyzed with <code>a</code>. If <code>create</code> is true, then a new, empty index will be created in <code>d</code>, replacing the index already there, if any.  <a href="#a116bca44ae8e99e740aa8cfdc06da545"></a><br/></td></tr>
<tr class="separator:a116bca44ae8e99e740aa8cfdc06da545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3e2d8418a8ddef9758d4cedfa89c7b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a5b3e2d8418a8ddef9758d4cedfa89c7b">IndexWriter</a> (<a class="el" href="../../dd/df1/_syns2_index_8cs.html#aada057080323f6e867d8f9c189276716">Directory</a> d, <a class="el" href="../../dd/d53/_more_like_this_8cs.html#a7f807a855319cb4e1efa0e1fcd2a537f">Analyzer</a> a, <a class="el" href="../../d7/d90/interface_lucene_1_1_net_1_1_index_1_1_index_deletion_policy.html">IndexDeletionPolicy</a> deletionPolicy, <a class="el" href="../../d4/d33/class_lucene_1_1_net_1_1_index_1_1_index_writer_1_1_max_field_length.html">MaxFieldLength</a> mfl, <a class="el" href="../../d8/de7/class_lucene_1_1_net_1_1_index_1_1_index_commit.html">IndexCommit</a> commit)</td></tr>
<tr class="memdesc:a5b3e2d8418a8ddef9758d4cedfa89c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: constructs an <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a> on specific commit point, with a custom <a class="el" href="../../d7/d90/interface_lucene_1_1_net_1_1_index_1_1_index_deletion_policy.html" title="Expert: policy for deletion of stale index commits.">IndexDeletionPolicy</a>, for the index in <code>d</code>. Text will be analyzed with <code>a</code>.  <a href="#a5b3e2d8418a8ddef9758d4cedfa89c7b"></a><br/></td></tr>
<tr class="separator:a5b3e2d8418a8ddef9758d4cedfa89c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f94df68d90885575f2cc7df66b8f1d6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a6f94df68d90885575f2cc7df66b8f1d6">SetMergePolicy</a> (<a class="el" href="../../d2/dce/class_lucene_1_1_net_1_1_index_1_1_merge_policy.html">MergePolicy</a> mp)</td></tr>
<tr class="memdesc:a6f94df68d90885575f2cc7df66b8f1d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: set the merge policy used by this writer. <a href="#a6f94df68d90885575f2cc7df66b8f1d6"></a><br/></td></tr>
<tr class="separator:a6f94df68d90885575f2cc7df66b8f1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba977b2dd3a5da8dd171515c166ded27"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#aba977b2dd3a5da8dd171515c166ded27">SetMergeScheduler</a> (<a class="el" href="../../d9/d30/class_lucene_1_1_net_1_1_index_1_1_merge_scheduler.html">MergeScheduler</a> mergeScheduler)</td></tr>
<tr class="memdesc:aba977b2dd3a5da8dd171515c166ded27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: set the merge scheduler used by this writer. <a href="#aba977b2dd3a5da8dd171515c166ded27"></a><br/></td></tr>
<tr class="separator:aba977b2dd3a5da8dd171515c166ded27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91be1a71d5a51f7232dc2b6f5e021d9e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a91be1a71d5a51f7232dc2b6f5e021d9e">SetMaxFieldLength</a> (int maxFieldLength)</td></tr>
<tr class="memdesc:a91be1a71d5a51f7232dc2b6f5e021d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of terms that will be indexed for a single field in a document. This limits the amount of memory required for indexing, so that collections with very large files will not crash the indexing process by running out of memory. This setting refers to the number of running terms, not to the number of different terms.<b>Note:</b> this silently truncates large documents, excluding from the index all terms that occur further in the document. If you know your source documents are large, be sure to set this value high enough to accomodate the expected size. If you set it to Integer.MAX_VALUE, then the only limit is your memory, but you should anticipate an OutOfMemoryError.By default, no more than <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a7295b9b97b02ed5a179bbc3778f10e57" title="Default value is 10,000. Change using SetMaxFieldLength(int).">DEFAULT_MAX_FIELD_LENGTH</a> terms will be indexed for a field.  <a href="#a91be1a71d5a51f7232dc2b6f5e021d9e"></a><br/></td></tr>
<tr class="separator:a91be1a71d5a51f7232dc2b6f5e021d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d51d131b3e0351dff04357fb0ee9c51"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a2d51d131b3e0351dff04357fb0ee9c51">GetMaxFieldLength</a> ()</td></tr>
<tr class="memdesc:a2d51d131b3e0351dff04357fb0ee9c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of terms that will be indexed for a single field in a document.  <a href="#a2d51d131b3e0351dff04357fb0ee9c51"></a><br/></td></tr>
<tr class="separator:a2d51d131b3e0351dff04357fb0ee9c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af3f9039f7a75a70ee9e496ff4a6460"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a0af3f9039f7a75a70ee9e496ff4a6460">SetMaxBufferedDocs</a> (int maxBufferedDocs)</td></tr>
<tr class="memdesc:a0af3f9039f7a75a70ee9e496ff4a6460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the minimal number of documents required before the buffered in-memory documents are flushed as a new Segment. Large values generally gives faster indexing.  <a href="#a0af3f9039f7a75a70ee9e496ff4a6460"></a><br/></td></tr>
<tr class="separator:a0af3f9039f7a75a70ee9e496ff4a6460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd14299c479299920fbf759782e7c0a6"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#acd14299c479299920fbf759782e7c0a6">GetMaxBufferedDocs</a> ()</td></tr>
<tr class="memdesc:acd14299c479299920fbf759782e7c0a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of buffered added documents that will trigger a flush if enabled.  <a href="#acd14299c479299920fbf759782e7c0a6"></a><br/></td></tr>
<tr class="separator:acd14299c479299920fbf759782e7c0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee00b6cfce82c5e8e7eb088afbfcd465"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#aee00b6cfce82c5e8e7eb088afbfcd465">SetRAMBufferSizeMB</a> (double mb)</td></tr>
<tr class="memdesc:aee00b6cfce82c5e8e7eb088afbfcd465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the amount of RAM that may be used for buffering added documents and deletions before they are flushed to the Directory. Generally for faster indexing performance it's best to flush by RAM usage instead of document count and use as large a RAM buffer as you can.  <a href="#aee00b6cfce82c5e8e7eb088afbfcd465"></a><br/></td></tr>
<tr class="separator:aee00b6cfce82c5e8e7eb088afbfcd465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1590a85413d530f8e86b014325e00cac"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a1590a85413d530f8e86b014325e00cac">GetRAMBufferSizeMB</a> ()</td></tr>
<tr class="memdesc:a1590a85413d530f8e86b014325e00cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value set by <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#aee00b6cfce82c5e8e7eb088afbfcd465" title="Determines the amount of RAM that may be used for buffering added documents and deletions before they...">SetRAMBufferSizeMB</a> if enabled. <a href="#a1590a85413d530f8e86b014325e00cac"></a><br/></td></tr>
<tr class="separator:a1590a85413d530f8e86b014325e00cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba86647b33915ad12d588238fbd996e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a6ba86647b33915ad12d588238fbd996e">SetMaxBufferedDeleteTerms</a> (int maxBufferedDeleteTerms)</td></tr>
<tr class="memdesc:a6ba86647b33915ad12d588238fbd996e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the minimal number of delete terms required before the buffered in-memory delete terms are applied and flushed. If there are documents buffered in memory at the time, they are merged and a new segment is created.Disabled by default (writer flushes by RAM usage). <a href="#a6ba86647b33915ad12d588238fbd996e"></a><br/></td></tr>
<tr class="separator:a6ba86647b33915ad12d588238fbd996e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97789ec602d14712bd0e109a5959f435"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a97789ec602d14712bd0e109a5959f435">GetMaxBufferedDeleteTerms</a> ()</td></tr>
<tr class="memdesc:a97789ec602d14712bd0e109a5959f435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of buffered deleted terms that will trigger a flush if enabled.  <a href="#a97789ec602d14712bd0e109a5959f435"></a><br/></td></tr>
<tr class="separator:a97789ec602d14712bd0e109a5959f435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce005e0f128225cc6abb481099aa6d9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#adce005e0f128225cc6abb481099aa6d9">SetInfoStream</a> (System.IO.StreamWriter infoStream)</td></tr>
<tr class="memdesc:adce005e0f128225cc6abb481099aa6d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">If non-null, information about merges, deletes and a message when maxFieldLength is reached will be printed to this.  <a href="#adce005e0f128225cc6abb481099aa6d9"></a><br/></td></tr>
<tr class="separator:adce005e0f128225cc6abb481099aa6d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4383aeee76431a2b30b10e5ffb4b87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#abe4383aeee76431a2b30b10e5ffb4b87">Close</a> ()</td></tr>
<tr class="memdesc:abe4383aeee76431a2b30b10e5ffb4b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commits all changes to an index and closes all associated files. Note that this may be a costly operation, so, try to re-use a single writer instead of closing and opening a new one. See <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#ad1df12452bb45f153d9d06e1c160e2ff" title="Commits all pending changes (added &amp; deleted documents, optimizations, segment merges, added indexes, etc.) to the index, and syncs all referenced index files, such that a reader will see the changes and the index updates will survive an OS or machine crash or power loss. Note that this does not wait for any running background merges to finish. This may be a costly operation, so you should test the cost in your application and do it only when really necessary.">Commit()</a> for caveats about write caching done by some IO devices.  <a href="#abe4383aeee76431a2b30b10e5ffb4b87"></a><br/></td></tr>
<tr class="separator:abe4383aeee76431a2b30b10e5ffb4b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc0fe31cda04b23756dacd6d16e091a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a9cc0fe31cda04b23756dacd6d16e091a">Dispose</a> ()</td></tr>
<tr class="memdesc:a9cc0fe31cda04b23756dacd6d16e091a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commits all changes to an index and closes all associated files. Note that this may be a costly operation, so, try to re-use a single writer instead of closing and opening a new one. See <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#ad1df12452bb45f153d9d06e1c160e2ff" title="Commits all pending changes (added &amp; deleted documents, optimizations, segment merges, added indexes, etc.) to the index, and syncs all referenced index files, such that a reader will see the changes and the index updates will survive an OS or machine crash or power loss. Note that this does not wait for any running background merges to finish. This may be a costly operation, so you should test the cost in your application and do it only when really necessary.">Commit()</a> for caveats about write caching done by some IO devices.  <a href="#a9cc0fe31cda04b23756dacd6d16e091a"></a><br/></td></tr>
<tr class="separator:a9cc0fe31cda04b23756dacd6d16e091a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64da2894d280a7b238b54a8cb0c04116"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a64da2894d280a7b238b54a8cb0c04116">Dispose</a> (bool waitForMerges)</td></tr>
<tr class="memdesc:a64da2894d280a7b238b54a8cb0c04116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the index with or without waiting for currently running merges to finish. This is only meaningful when using a <a class="el" href="../../d9/d30/class_lucene_1_1_net_1_1_index_1_1_merge_scheduler.html" title="Expert: IndexWriter uses an instance implementing this interface to execute the merges selected by a ...">MergeScheduler</a> that runs merges in background threads.  <a href="#a64da2894d280a7b238b54a8cb0c04116"></a><br/></td></tr>
<tr class="separator:a64da2894d280a7b238b54a8cb0c04116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24977b3c172ea49d2d66098885dcf63d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a24977b3c172ea49d2d66098885dcf63d">Close</a> (bool waitForMerges)</td></tr>
<tr class="memdesc:a24977b3c172ea49d2d66098885dcf63d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the index with or without waiting for currently running merges to finish. This is only meaningful when using a <a class="el" href="../../d9/d30/class_lucene_1_1_net_1_1_index_1_1_merge_scheduler.html" title="Expert: IndexWriter uses an instance implementing this interface to execute the merges selected by a ...">MergeScheduler</a> that runs merges in background threads.  <a href="#a24977b3c172ea49d2d66098885dcf63d"></a><br/></td></tr>
<tr class="separator:a24977b3c172ea49d2d66098885dcf63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad550b4d48b97e3304fca067b9ba8bbf2"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#ad550b4d48b97e3304fca067b9ba8bbf2">MaxDoc</a> ()</td></tr>
<tr class="memdesc:ad550b4d48b97e3304fca067b9ba8bbf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns total number of docs in this index, including docs not yet flushed (still in the RAM buffer), not counting deletions.  <a href="#ad550b4d48b97e3304fca067b9ba8bbf2"></a><br/></td></tr>
<tr class="separator:ad550b4d48b97e3304fca067b9ba8bbf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb6189992e060b9049c505a5d2ba71a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#adfb6189992e060b9049c505a5d2ba71a">NumDocs</a> ()</td></tr>
<tr class="memdesc:adfb6189992e060b9049c505a5d2ba71a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns total number of docs in this index, including docs not yet flushed (still in the RAM buffer), and including deletions. <b>NOTE:</b> buffered deletions are not counted. If you really need these to be counted you should call <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#ad1df12452bb45f153d9d06e1c160e2ff" title="Commits all pending changes (added &amp; deleted documents, optimizations, segment merges, added indexes, etc.) to the index, and syncs all referenced index files, such that a reader will see the changes and the index updates will survive an OS or machine crash or power loss. Note that this does not wait for any running background merges to finish. This may be a costly operation, so you should test the cost in your application and do it only when really necessary.">Commit()</a> first.  <a href="#adfb6189992e060b9049c505a5d2ba71a"></a><br/></td></tr>
<tr class="separator:adfb6189992e060b9049c505a5d2ba71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae9e478226238bff6eb549912b25149"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a8ae9e478226238bff6eb549912b25149">HasDeletions</a> ()</td></tr>
<tr class="separator:a8ae9e478226238bff6eb549912b25149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000da5a984e6cce2aee03cbaf121a53f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a000da5a984e6cce2aee03cbaf121a53f">AddDocument</a> (<a class="el" href="../../dd/d53/_more_like_this_8cs.html#a2ad6aef8641c7b7a6cf9277f7d54b2cd">Document</a> doc)</td></tr>
<tr class="memdesc:a000da5a984e6cce2aee03cbaf121a53f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a document to this index. If the document contains more than <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a91be1a71d5a51f7232dc2b6f5e021d9e" title="The maximum number of terms that will be indexed for a single field in a document. This limits the amount of memory required for indexing, so that collections with very large files will not crash the indexing process by running out of memory. This setting refers to the number of running terms, not to the number of different terms.Note: this silently truncates large documents, excluding from the index all terms that occur further in the document. If you know your source documents are large, be sure to set this value high enough to accomodate the expected size. If you set it to Integer.MAX_VALUE, then the only limit is your memory, but you should anticipate an OutOfMemoryError.By default, no more than DEFAULT_MAX_FIELD_LENGTH terms will be indexed for a field. ">SetMaxFieldLength(int)</a> terms for a given field, the remainder are discarded.  <a href="#a000da5a984e6cce2aee03cbaf121a53f"></a><br/></td></tr>
<tr class="separator:a000da5a984e6cce2aee03cbaf121a53f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8afce956be92f2864822aa9c88ea687"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#ae8afce956be92f2864822aa9c88ea687">AddDocument</a> (<a class="el" href="../../dd/d53/_more_like_this_8cs.html#a2ad6aef8641c7b7a6cf9277f7d54b2cd">Document</a> doc, <a class="el" href="../../dd/d53/_more_like_this_8cs.html#a7f807a855319cb4e1efa0e1fcd2a537f">Analyzer</a> analyzer)</td></tr>
<tr class="memdesc:ae8afce956be92f2864822aa9c88ea687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a document to this index, using the provided analyzer instead of the value of <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a5fb5084a704bb4b22096429e21262d61" title="Returns the analyzer used by this index. ">Analyzer</a>. If the document contains more than <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a91be1a71d5a51f7232dc2b6f5e021d9e" title="The maximum number of terms that will be indexed for a single field in a document. This limits the amount of memory required for indexing, so that collections with very large files will not crash the indexing process by running out of memory. This setting refers to the number of running terms, not to the number of different terms.Note: this silently truncates large documents, excluding from the index all terms that occur further in the document. If you know your source documents are large, be sure to set this value high enough to accomodate the expected size. If you set it to Integer.MAX_VALUE, then the only limit is your memory, but you should anticipate an OutOfMemoryError.By default, no more than DEFAULT_MAX_FIELD_LENGTH terms will be indexed for a field. ">SetMaxFieldLength(int)</a> terms for a given field, the remainder are discarded.  <a href="#ae8afce956be92f2864822aa9c88ea687"></a><br/></td></tr>
<tr class="separator:ae8afce956be92f2864822aa9c88ea687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b556766e1a2a68836906f3d66ffc27"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a07b556766e1a2a68836906f3d66ffc27">DeleteDocuments</a> (<a class="el" href="../../d3/daf/class_lucene_1_1_net_1_1_index_1_1_term.html">Term</a> term)</td></tr>
<tr class="memdesc:a07b556766e1a2a68836906f3d66ffc27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the document(s) containing <code>term</code>.  <a href="#a07b556766e1a2a68836906f3d66ffc27"></a><br/></td></tr>
<tr class="separator:a07b556766e1a2a68836906f3d66ffc27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08fce328d97b7c50e6080f684f76b726"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a08fce328d97b7c50e6080f684f76b726">DeleteDocuments</a> (params <a class="el" href="../../d3/daf/class_lucene_1_1_net_1_1_index_1_1_term.html">Term</a>[] terms)</td></tr>
<tr class="memdesc:a08fce328d97b7c50e6080f684f76b726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the document(s) containing any of the terms. All deletes are flushed at the same time.  <a href="#a08fce328d97b7c50e6080f684f76b726"></a><br/></td></tr>
<tr class="separator:a08fce328d97b7c50e6080f684f76b726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d79488123fefa3e4bbda53b94ae3e89"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a2d79488123fefa3e4bbda53b94ae3e89">DeleteDocuments</a> (<a class="el" href="../../dd/d53/_more_like_this_8cs.html#accbc7c5687907350ba0e2681b41e1b0d">Query</a> query)</td></tr>
<tr class="memdesc:a2d79488123fefa3e4bbda53b94ae3e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the document(s) matching the provided query.  <a href="#a2d79488123fefa3e4bbda53b94ae3e89"></a><br/></td></tr>
<tr class="separator:a2d79488123fefa3e4bbda53b94ae3e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a7d5700d30a575128de41e9f362eb1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a64a7d5700d30a575128de41e9f362eb1">DeleteDocuments</a> (params <a class="el" href="../../dd/d53/_more_like_this_8cs.html#accbc7c5687907350ba0e2681b41e1b0d">Query</a>[] queries)</td></tr>
<tr class="memdesc:a64a7d5700d30a575128de41e9f362eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the document(s) matching any of the provided queries. All deletes are flushed at the same time.  <a href="#a64a7d5700d30a575128de41e9f362eb1"></a><br/></td></tr>
<tr class="separator:a64a7d5700d30a575128de41e9f362eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3667a5f5d4cffeb250ed20c2da19178b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a3667a5f5d4cffeb250ed20c2da19178b">UpdateDocument</a> (<a class="el" href="../../d3/daf/class_lucene_1_1_net_1_1_index_1_1_term.html">Term</a> term, <a class="el" href="../../dd/d53/_more_like_this_8cs.html#a2ad6aef8641c7b7a6cf9277f7d54b2cd">Document</a> doc)</td></tr>
<tr class="memdesc:a3667a5f5d4cffeb250ed20c2da19178b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates a document by first deleting the document(s) containing <code>term</code> and then adding the new document. The delete and then add are atomic as seen by a reader on the same index (flush may happen only after the add).  <a href="#a3667a5f5d4cffeb250ed20c2da19178b"></a><br/></td></tr>
<tr class="separator:a3667a5f5d4cffeb250ed20c2da19178b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153cb58ae0d05e8c46a617dabb7db188"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a153cb58ae0d05e8c46a617dabb7db188">UpdateDocument</a> (<a class="el" href="../../d3/daf/class_lucene_1_1_net_1_1_index_1_1_term.html">Term</a> term, <a class="el" href="../../dd/d53/_more_like_this_8cs.html#a2ad6aef8641c7b7a6cf9277f7d54b2cd">Document</a> doc, <a class="el" href="../../dd/d53/_more_like_this_8cs.html#a7f807a855319cb4e1efa0e1fcd2a537f">Analyzer</a> analyzer)</td></tr>
<tr class="memdesc:a153cb58ae0d05e8c46a617dabb7db188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates a document by first deleting the document(s) containing <code>term</code> and then adding the new document. The delete and then add are atomic as seen by a reader on the same index (flush may happen only after the add).  <a href="#a153cb58ae0d05e8c46a617dabb7db188"></a><br/></td></tr>
<tr class="separator:a153cb58ae0d05e8c46a617dabb7db188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5231c186c9b1d64b30d9a7b1e0d666c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a5231c186c9b1d64b30d9a7b1e0d666c0">GetDocCount</a> (int i)</td></tr>
<tr class="separator:a5231c186c9b1d64b30d9a7b1e0d666c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19cfeeb684bdfee1802e51fcb9d49559"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a19cfeeb684bdfee1802e51fcb9d49559">Optimize</a> ()</td></tr>
<tr class="memdesc:a19cfeeb684bdfee1802e51fcb9d49559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests an "optimize" operation on an index, priming the index for the fastest available search. Traditionally this has meant merging all segments into a single segment as is done in the default merge policy, but individaul merge policies may implement optimize in different ways.  <a href="#a19cfeeb684bdfee1802e51fcb9d49559"></a><br/></td></tr>
<tr class="separator:a19cfeeb684bdfee1802e51fcb9d49559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214dc271d1438e9072dda4cf33962ec7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a214dc271d1438e9072dda4cf33962ec7">Optimize</a> (int maxNumSegments)</td></tr>
<tr class="memdesc:a214dc271d1438e9072dda4cf33962ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize the index down to &lt;= maxNumSegments. If maxNumSegments==1 then this is the same as <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a19cfeeb684bdfee1802e51fcb9d49559" title="Requests an &quot;optimize&quot; operation on an index, priming the index for the fastest available search...">Optimize()</a> <a href="#a214dc271d1438e9072dda4cf33962ec7"></a><br/></td></tr>
<tr class="separator:a214dc271d1438e9072dda4cf33962ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a270bc05ce32b6021952d4fcd785a76c4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a270bc05ce32b6021952d4fcd785a76c4">Optimize</a> (bool doWait)</td></tr>
<tr class="memdesc:a270bc05ce32b6021952d4fcd785a76c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just like <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a19cfeeb684bdfee1802e51fcb9d49559" title="Requests an &quot;optimize&quot; operation on an index, priming the index for the fastest available search...">Optimize()</a>, except you can specify whether the call should block until the optimize completes. This is only meaningful with a <a class="el" href="../../d9/d30/class_lucene_1_1_net_1_1_index_1_1_merge_scheduler.html" title="Expert: IndexWriter uses an instance implementing this interface to execute the merges selected by a ...">MergeScheduler</a> that is able to run merges in background threads.  <a href="#a270bc05ce32b6021952d4fcd785a76c4"></a><br/></td></tr>
<tr class="separator:a270bc05ce32b6021952d4fcd785a76c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af115559461b738571538b7a6da2fc1ae"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#af115559461b738571538b7a6da2fc1ae">Optimize</a> (int maxNumSegments, bool doWait)</td></tr>
<tr class="memdesc:af115559461b738571538b7a6da2fc1ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just like <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a214dc271d1438e9072dda4cf33962ec7" title="Optimize the index down to &lt;= maxNumSegments. If maxNumSegments==1 then this is the same as Optimize(...">Optimize(int)</a>, except you can specify whether the call should block until the optimize completes. This is only meaningful with a <a class="el" href="../../d9/d30/class_lucene_1_1_net_1_1_index_1_1_merge_scheduler.html" title="Expert: IndexWriter uses an instance implementing this interface to execute the merges selected by a ...">MergeScheduler</a> that is able to run merges in background threads.  <a href="#af115559461b738571538b7a6da2fc1ae"></a><br/></td></tr>
<tr class="separator:af115559461b738571538b7a6da2fc1ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69c8dc2c6f40ecc8e92d0de02b17840"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#ab69c8dc2c6f40ecc8e92d0de02b17840">ExpungeDeletes</a> (bool doWait)</td></tr>
<tr class="memdesc:ab69c8dc2c6f40ecc8e92d0de02b17840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just like <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#aea5dfc7746eb73b6d44d1ab738cdab59" title="Expunges all deletes from the index. When an index has many document deletions (or updates to existin...">ExpungeDeletes()</a>, except you can specify whether the call should block until the operation completes. This is only meaningful with a <a class="el" href="../../d9/d30/class_lucene_1_1_net_1_1_index_1_1_merge_scheduler.html" title="Expert: IndexWriter uses an instance implementing this interface to execute the merges selected by a ...">MergeScheduler</a> that is able to run merges in background threads.  <a href="#ab69c8dc2c6f40ecc8e92d0de02b17840"></a><br/></td></tr>
<tr class="separator:ab69c8dc2c6f40ecc8e92d0de02b17840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5dfc7746eb73b6d44d1ab738cdab59"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#aea5dfc7746eb73b6d44d1ab738cdab59">ExpungeDeletes</a> ()</td></tr>
<tr class="memdesc:aea5dfc7746eb73b6d44d1ab738cdab59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expunges all deletes from the index. When an index has many document deletions (or updates to existing documents), it's best to either call optimize or expungeDeletes to remove all unused data in the index associated with the deleted documents. To see how many deletions you have pending in your index, call <a class="el" href="../../d6/d27/class_lucene_1_1_net_1_1_index_1_1_index_reader.html#a8ca390814a8df63b33d2221348b61552" title="Returns the number of deleted documents. ">IndexReader.NumDeletedDocs</a> This saves disk space and memory usage while searching. expungeDeletes should be somewhat faster than optimize since it does not insist on reducing the index to a single segment (though, this depends on the <a class="el" href="../../d2/dce/class_lucene_1_1_net_1_1_index_1_1_merge_policy.html" title="Expert: a MergePolicy determines the sequence of primitive merge operations to be used for overall me...">MergePolicy</a>; see <a class="el" href="../../d2/dce/class_lucene_1_1_net_1_1_index_1_1_merge_policy.html#a88ec89d1914e64f08aa0031174a7b792" title="Determine what set of merge operations is necessary in order to expunge all deletes from the index...">Index.MergePolicy.FindMergesToExpungeDeletes</a>.). Note that this call does not first commit any buffered documents, so you must do so yourself if necessary. See also </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#ab69c8dc2c6f40ecc8e92d0de02b17840" title="Just like ExpungeDeletes(), except you can specify whether the call should block until the operation ...">ExpungeDeletes(bool)</a></dd></dl>
 <a href="#aea5dfc7746eb73b6d44d1ab738cdab59"></a><br/></td></tr>
<tr class="separator:aea5dfc7746eb73b6d44d1ab738cdab59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056e7a7776e7b57e85a7357d0f31d355"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a056e7a7776e7b57e85a7357d0f31d355">MaybeMerge</a> ()</td></tr>
<tr class="memdesc:a056e7a7776e7b57e85a7357d0f31d355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: asks the mergePolicy whether any merges are necessary now and if so, runs the requested merges and then iterate (test again if merges are needed) until no more merges are returned by the mergePolicy.  <a href="#a056e7a7776e7b57e85a7357d0f31d355"></a><br/></td></tr>
<tr class="separator:a056e7a7776e7b57e85a7357d0f31d355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6585064853f33355bf4b450ec88fd727"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a6585064853f33355bf4b450ec88fd727">Rollback</a> ()</td></tr>
<tr class="memdesc:a6585064853f33355bf4b450ec88fd727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the <code><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a></code> without committing any changes that have occurred since the last commit (or since it was opened, if commit hasn't been called). This removes any temporary files that had been created, after which the state of the index will be the same as it was when commit() was last called or when this writer was first opened. This also clears a previous call to <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a654d4db76a39dc6f888315b60c7f1455" title="Expert: prepare for commit.">PrepareCommit()</a>.  <a href="#a6585064853f33355bf4b450ec88fd727"></a><br/></td></tr>
<tr class="separator:a6585064853f33355bf4b450ec88fd727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3adb3b86d0b00ab2ba73ecfd81f418ef"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a3adb3b86d0b00ab2ba73ecfd81f418ef">DeleteAll</a> ()</td></tr>
<tr class="memdesc:a3adb3b86d0b00ab2ba73ecfd81f418ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all documents in the index.  <a href="#a3adb3b86d0b00ab2ba73ecfd81f418ef"></a><br/></td></tr>
<tr class="separator:a3adb3b86d0b00ab2ba73ecfd81f418ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6bf166ec1ec56a12311150b63670b0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#aec6bf166ec1ec56a12311150b63670b0">WaitForMerges</a> ()</td></tr>
<tr class="memdesc:aec6bf166ec1ec56a12311150b63670b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for any currently outstanding merges to finish.  <a href="#aec6bf166ec1ec56a12311150b63670b0"></a><br/></td></tr>
<tr class="separator:aec6bf166ec1ec56a12311150b63670b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e1537958bf485ce9d1195b2eece3cc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#ab6e1537958bf485ce9d1195b2eece3cc">AddIndexesNoOptimize</a> (params <a class="el" href="../../dd/df1/_syns2_index_8cs.html#aada057080323f6e867d8f9c189276716">Directory</a>[] dirs)</td></tr>
<tr class="memdesc:ab6e1537958bf485ce9d1195b2eece3cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges all segments from an array of indexes into this index.  <a href="#ab6e1537958bf485ce9d1195b2eece3cc"></a><br/></td></tr>
<tr class="separator:ab6e1537958bf485ce9d1195b2eece3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0b1546bb8fee0480823dee19046f45"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a9b0b1546bb8fee0480823dee19046f45">AddIndexes</a> (params <a class="el" href="../../d6/d27/class_lucene_1_1_net_1_1_index_1_1_index_reader.html">IndexReader</a>[] readers)</td></tr>
<tr class="memdesc:a9b0b1546bb8fee0480823dee19046f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges the provided indexes into this index. After this completes, the index is optimized. The provided IndexReaders are not closed. <a href="#a9b0b1546bb8fee0480823dee19046f45"></a><br/></td></tr>
<tr class="separator:a9b0b1546bb8fee0480823dee19046f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654d4db76a39dc6f888315b60c7f1455"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a654d4db76a39dc6f888315b60c7f1455">PrepareCommit</a> ()</td></tr>
<tr class="memdesc:a654d4db76a39dc6f888315b60c7f1455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: prepare for commit.  <a href="#a654d4db76a39dc6f888315b60c7f1455"></a><br/></td></tr>
<tr class="separator:a654d4db76a39dc6f888315b60c7f1455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1df12452bb45f153d9d06e1c160e2ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#ad1df12452bb45f153d9d06e1c160e2ff">Commit</a> ()</td></tr>
<tr class="memdesc:ad1df12452bb45f153d9d06e1c160e2ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commits all pending changes (added &amp; deleted documents, optimizations, segment merges, added indexes, etc.) to the index, and syncs all referenced index files, such that a reader will see the changes and the index updates will survive an OS or machine crash or power loss. Note that this does not wait for any running background merges to finish. This may be a costly operation, so you should test the cost in your application and do it only when really necessary. <a href="#ad1df12452bb45f153d9d06e1c160e2ff"></a><br/></td></tr>
<tr class="separator:ad1df12452bb45f153d9d06e1c160e2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba869eef21db681571a29c004118a09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a1ba869eef21db681571a29c004118a09">Commit</a> (IDictionary&lt; string, string &gt; commitUserData)</td></tr>
<tr class="memdesc:a1ba869eef21db681571a29c004118a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commits all changes to the index, specifying a commitUserData Map (String -&gt; String). This just calls PrepareCommit(IDictionary{string, string}) (if you didn't already call it) and then FinishCommit.  <a href="#a1ba869eef21db681571a29c004118a09"></a><br/></td></tr>
<tr class="separator:a1ba869eef21db681571a29c004118a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6efcea17970d2822fc08945bab36439e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a6efcea17970d2822fc08945bab36439e">Flush</a> (bool triggerMerge, bool flushDocStores, bool flushDeletes)</td></tr>
<tr class="memdesc:a6efcea17970d2822fc08945bab36439e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush all in-memory buffered udpates (adds and deletes) to the Directory.  <a href="#a6efcea17970d2822fc08945bab36439e"></a><br/></td></tr>
<tr class="separator:a6efcea17970d2822fc08945bab36439e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab99319eb9efee0c6ca719a1bb6a0c5c"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#aab99319eb9efee0c6ca719a1bb6a0c5c">RamSizeInBytes</a> ()</td></tr>
<tr class="memdesc:aab99319eb9efee0c6ca719a1bb6a0c5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: Return the total size of all index files currently cached in memory. Useful for size management with flushRamDocs()  <a href="#aab99319eb9efee0c6ca719a1bb6a0c5c"></a><br/></td></tr>
<tr class="separator:aab99319eb9efee0c6ca719a1bb6a0c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7607d45f20ecd78ede37f9f2adca8569"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a7607d45f20ecd78ede37f9f2adca8569">NumRamDocs</a> ()</td></tr>
<tr class="memdesc:a7607d45f20ecd78ede37f9f2adca8569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: Return the number of documents currently buffered in RAM.  <a href="#a7607d45f20ecd78ede37f9f2adca8569"></a><br/></td></tr>
<tr class="separator:a7607d45f20ecd78ede37f9f2adca8569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b566ac9c2e1fa55dd50758d2a2216ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a7b566ac9c2e1fa55dd50758d2a2216ab">Merge_ForNUnit</a> (<a class="el" href="../../d5/de7/class_lucene_1_1_net_1_1_index_1_1_merge_policy_1_1_one_merge.html">MergePolicy.OneMerge</a> merge)</td></tr>
<tr class="separator:a7b566ac9c2e1fa55dd50758d2a2216ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60a31363679597a308914e11de0e6b1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d7/d6c/class_lucene_1_1_net_1_1_index_1_1_segment_info.html">SegmentInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#af60a31363679597a308914e11de0e6b1">NewestSegment</a> ()</td></tr>
<tr class="separator:af60a31363679597a308914e11de0e6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19dbab4393010c63c8a8e97080359dee"><td class="memItemLeft" align="right" valign="top">virtual System.String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a19dbab4393010c63c8a8e97080359dee">SegString</a> ()</td></tr>
<tr class="separator:a19dbab4393010c63c8a8e97080359dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15457a4f8494c68602a5bba5b1ad0d86"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a15457a4f8494c68602a5bba5b1ad0d86">TestPoint</a> (System.String name)</td></tr>
<tr class="separator:a15457a4f8494c68602a5bba5b1ad0d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a759669255f82e89072a9249cd131c1da"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a759669255f82e89072a9249cd131c1da">IsLocked</a> (<a class="el" href="../../dd/df1/_syns2_index_8cs.html#aada057080323f6e867d8f9c189276716">Directory</a> directory)</td></tr>
<tr class="memdesc:a759669255f82e89072a9249cd131c1da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> iff the index in the named directory is currently locked.  <a href="#a759669255f82e89072a9249cd131c1da"></a><br/></td></tr>
<tr class="separator:a759669255f82e89072a9249cd131c1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee14d6d2f1a94a7e67e0cdc58ff373d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#acee14d6d2f1a94a7e67e0cdc58ff373d">Unlock</a> (<a class="el" href="../../dd/df1/_syns2_index_8cs.html#aada057080323f6e867d8f9c189276716">Directory</a> directory)</td></tr>
<tr class="memdesc:acee14d6d2f1a94a7e67e0cdc58ff373d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forcibly unlocks the index in the named directory. Caution: this should only be used by failure recovery code, when it is known that no other process nor thread is in fact currently accessing this index.  <a href="#acee14d6d2f1a94a7e67e0cdc58ff373d"></a><br/></td></tr>
<tr class="separator:acee14d6d2f1a94a7e67e0cdc58ff373d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a315ae29ddea7027ec4b573acf7be850a"><td class="memItemLeft" align="right" valign="top">const System.String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a315ae29ddea7027ec4b573acf7be850a">WRITE_LOCK_NAME</a> = &quot;write.lock&quot;</td></tr>
<tr class="memdesc:a315ae29ddea7027ec4b573acf7be850a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the write lock in the index. <a href="#a315ae29ddea7027ec4b573acf7be850a"></a><br/></td></tr>
<tr class="separator:a315ae29ddea7027ec4b573acf7be850a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9f145da7f3ab3eb6bc74eef5de9c50"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#afb9f145da7f3ab3eb6bc74eef5de9c50">DISABLE_AUTO_FLUSH</a> = - 1</td></tr>
<tr class="memdesc:afb9f145da7f3ab3eb6bc74eef5de9c50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value to denote a flush trigger is disabled <a href="#afb9f145da7f3ab3eb6bc74eef5de9c50"></a><br/></td></tr>
<tr class="separator:afb9f145da7f3ab3eb6bc74eef5de9c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7226e029bdd37e6cf049a5495d75bddf"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a7226e029bdd37e6cf049a5495d75bddf">DEFAULT_RAM_BUFFER_SIZE_MB</a> = 16.0</td></tr>
<tr class="memdesc:a7226e029bdd37e6cf049a5495d75bddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default value is 16 MB (which means flush when buffered docs consume 16 MB RAM). Change using <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#aee00b6cfce82c5e8e7eb088afbfcd465" title="Determines the amount of RAM that may be used for buffering added documents and deletions before they...">SetRAMBufferSizeMB</a>.  <a href="#a7226e029bdd37e6cf049a5495d75bddf"></a><br/></td></tr>
<tr class="separator:a7226e029bdd37e6cf049a5495d75bddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7295b9b97b02ed5a179bbc3778f10e57"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a7295b9b97b02ed5a179bbc3778f10e57">DEFAULT_MAX_FIELD_LENGTH</a> = 10000</td></tr>
<tr class="memdesc:a7295b9b97b02ed5a179bbc3778f10e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default value is 10,000. Change using <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a91be1a71d5a51f7232dc2b6f5e021d9e" title="The maximum number of terms that will be indexed for a single field in a document. This limits the amount of memory required for indexing, so that collections with very large files will not crash the indexing process by running out of memory. This setting refers to the number of running terms, not to the number of different terms.Note: this silently truncates large documents, excluding from the index all terms that occur further in the document. If you know your source documents are large, be sure to set this value high enough to accomodate the expected size. If you set it to Integer.MAX_VALUE, then the only limit is your memory, but you should anticipate an OutOfMemoryError.By default, no more than DEFAULT_MAX_FIELD_LENGTH terms will be indexed for a field. ">SetMaxFieldLength(int)</a>. <a href="#a7295b9b97b02ed5a179bbc3778f10e57"></a><br/></td></tr>
<tr class="separator:a7295b9b97b02ed5a179bbc3778f10e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e73c423d6fa320f8592b96d5833dac4"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a6e73c423d6fa320f8592b96d5833dac4">DEFAULT_TERM_INDEX_INTERVAL</a> = 128</td></tr>
<tr class="memdesc:a6e73c423d6fa320f8592b96d5833dac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default value is 128. Change using <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a08bd108b86cc51879645de74c878afa7" title="Expert: Gets or sets the interval between indexed terms. Large values cause less memory to be used by...">TermIndexInterval</a>. <a href="#a6e73c423d6fa320f8592b96d5833dac4"></a><br/></td></tr>
<tr class="separator:a6e73c423d6fa320f8592b96d5833dac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a860de8d252b7555bf02d5adeaa90a2d2"><td class="memItemLeft" align="right" valign="top">static long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a860de8d252b7555bf02d5adeaa90a2d2">WRITE_LOCK_TIMEOUT</a> = 1000</td></tr>
<tr class="memdesc:a860de8d252b7555bf02d5adeaa90a2d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default value for the write lock timeout (1,000). <a href="#a860de8d252b7555bf02d5adeaa90a2d2"></a><br/></td></tr>
<tr class="separator:a860de8d252b7555bf02d5adeaa90a2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa97bda7523a7160f1ee61a4fecb98dcf"><td class="memItemLeft" align="right" valign="top">static readonly int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#aa97bda7523a7160f1ee61a4fecb98dcf">DEFAULT_MAX_BUFFERED_DOCS</a> = <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#afb9f145da7f3ab3eb6bc74eef5de9c50">DISABLE_AUTO_FLUSH</a></td></tr>
<tr class="memdesc:aa97bda7523a7160f1ee61a4fecb98dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disabled by default (because <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a> flushes by RAM usage by default). Change using <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a0af3f9039f7a75a70ee9e496ff4a6460" title="Determines the minimal number of documents required before the buffered in-memory documents are flush...">SetMaxBufferedDocs(int)</a>.  <a href="#aa97bda7523a7160f1ee61a4fecb98dcf"></a><br/></td></tr>
<tr class="separator:aa97bda7523a7160f1ee61a4fecb98dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176a18e0e398195b6cb1d2526559063a"><td class="memItemLeft" align="right" valign="top">static readonly int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a176a18e0e398195b6cb1d2526559063a">DEFAULT_MAX_BUFFERED_DELETE_TERMS</a> = <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#afb9f145da7f3ab3eb6bc74eef5de9c50">DISABLE_AUTO_FLUSH</a></td></tr>
<tr class="memdesc:a176a18e0e398195b6cb1d2526559063a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disabled by default (because <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a> flushes by RAM usage by default). Change using <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a6ba86647b33915ad12d588238fbd996e" title="Determines the minimal number of delete terms required before the buffered in-memory delete terms are...">SetMaxBufferedDeleteTerms(int)</a>.  <a href="#a176a18e0e398195b6cb1d2526559063a"></a><br/></td></tr>
<tr class="separator:a176a18e0e398195b6cb1d2526559063a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dab15a94436a74deaf7d1f609d2563f"><td class="memItemLeft" align="right" valign="top">static readonly int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a5dab15a94436a74deaf7d1f609d2563f">MAX_TERM_LENGTH</a></td></tr>
<tr class="memdesc:a5dab15a94436a74deaf7d1f609d2563f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute hard maximum length for a term. If a term arrives from the analyzer longer than this length, it is skipped and a message is printed to infoStream, if set (see <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#adce005e0f128225cc6abb481099aa6d9" title="If non-null, information about merges, deletes and a message when maxFieldLength is reached will be p...">SetInfoStream</a>).  <a href="#a5dab15a94436a74deaf7d1f609d2563f"></a><br/></td></tr>
<tr class="separator:a5dab15a94436a74deaf7d1f609d2563f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a3604153c1f92199cab0ac152ff9f145d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a3604153c1f92199cab0ac152ff9f145d">Dispose</a> (bool disposing, bool waitForMerges)</td></tr>
<tr class="separator:a3604153c1f92199cab0ac152ff9f145d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f54eec8794d78ffc58c9ad8939ffa2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a38f54eec8794d78ffc58c9ad8939ffa2">DoAfterFlush</a> ()</td></tr>
<tr class="separator:a38f54eec8794d78ffc58c9ad8939ffa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaead441a4456916c6f129c1de7b36d04"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#aaead441a4456916c6f129c1de7b36d04">DoBeforeFlush</a> ()</td></tr>
<tr class="separator:aaead441a4456916c6f129c1de7b36d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a36aac4bd54d03505193f5679f1298df6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a36aac4bd54d03505193f5679f1298df6">UseCompoundFile</a><code> [get, set]</code></td></tr>
<tr class="memdesc:a36aac4bd54d03505193f5679f1298df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets or sets the current setting of whether newly flushed segments will use the compound file format. Note that this just returns the value previously set with setUseCompoundFile(boolean), or the default value (true). You cannot use this to query the status of previously flushed segments. <a href="#a36aac4bd54d03505193f5679f1298df6"></a><br/></td></tr>
<tr class="separator:a36aac4bd54d03505193f5679f1298df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f133271bb3f57361cd4036b4d136233"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d7/d70/_documents_writer_8cs.html#a5431a3a4edd067eec50ca39b5ea99c31">Similarity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a2f133271bb3f57361cd4036b4d136233">Similarity</a><code> [get]</code></td></tr>
<tr class="memdesc:a2f133271bb3f57361cd4036b4d136233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: Return the Similarity implementation used by this <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a>.  <a href="#a2f133271bb3f57361cd4036b4d136233"></a><br/></td></tr>
<tr class="separator:a2f133271bb3f57361cd4036b4d136233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08bd108b86cc51879645de74c878afa7"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a08bd108b86cc51879645de74c878afa7">TermIndexInterval</a><code> [get, set]</code></td></tr>
<tr class="memdesc:a08bd108b86cc51879645de74c878afa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: Gets or sets the interval between indexed terms. Large values cause less memory to be used by <a class="el" href="../../d6/d27/class_lucene_1_1_net_1_1_index_1_1_index_reader.html" title="IndexReader is an abstract class, providing an interface for accessing an index. Search of an index i...">IndexReader</a>, but slow random-access to terms. Small values cause more memory to be used by an <a class="el" href="../../d6/d27/class_lucene_1_1_net_1_1_index_1_1_index_reader.html" title="IndexReader is an abstract class, providing an interface for accessing an index. Search of an index i...">IndexReader</a>, and speed random-access to terms.  <a href="#a08bd108b86cc51879645de74c878afa7"></a><br/></td></tr>
<tr class="separator:a08bd108b86cc51879645de74c878afa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6533cdba6fc8ca76c61c1c85bfc400d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d2/dce/class_lucene_1_1_net_1_1_index_1_1_merge_policy.html">MergePolicy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#ab6533cdba6fc8ca76c61c1c85bfc400d">MergePolicy</a><code> [get]</code></td></tr>
<tr class="memdesc:ab6533cdba6fc8ca76c61c1c85bfc400d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: returns the current <a class="el" href="../../d2/dce/class_lucene_1_1_net_1_1_index_1_1_merge_policy.html" title="Expert: a MergePolicy determines the sequence of primitive merge operations to be used for overall me...">MergePolicy</a> in use by this writer. <a href="#ab6533cdba6fc8ca76c61c1c85bfc400d"></a><br/></td></tr>
<tr class="separator:ab6533cdba6fc8ca76c61c1c85bfc400d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f8f717fb0f9b7cc6e549988eaff05c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d9/d30/class_lucene_1_1_net_1_1_index_1_1_merge_scheduler.html">MergeScheduler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a52f8f717fb0f9b7cc6e549988eaff05c">MergeScheduler</a><code> [get]</code></td></tr>
<tr class="memdesc:a52f8f717fb0f9b7cc6e549988eaff05c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: returns the current <a class="el" href="../../d2/dce/class_lucene_1_1_net_1_1_index_1_1_merge_policy.html" title="Expert: a MergePolicy determines the sequence of primitive merge operations to be used for overall me...">MergePolicy</a> in use by this writer.  <a href="#a52f8f717fb0f9b7cc6e549988eaff05c"></a><br/></td></tr>
<tr class="separator:a52f8f717fb0f9b7cc6e549988eaff05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d23a10865edb3459475dd48d4d90c16"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a2d23a10865edb3459475dd48d4d90c16">MaxMergeDocs</a><code> [get, set]</code></td></tr>
<tr class="memdesc:a2d23a10865edb3459475dd48d4d90c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets or sets the largest segment (measured by document count) that may be merged with other segments. Small values (e.g., less than 10,000) are best for interactive indexing, as this limits the length of pauses while indexing to a few seconds. Larger values are best for batched indexing and speedier searches. The default value is int.MaxValue. Note that this method is a convenience method: it just calls mergePolicy.getMaxMergeDocs as long as mergePolicy is an instance of <a class="el" href="../../db/d3e/class_lucene_1_1_net_1_1_index_1_1_log_merge_policy.html" title="This class implements a MergePolicy that tries to merge segments into levels of exponentially increas...">LogMergePolicy</a>. Otherwise an IllegalArgumentException is thrown. <a href="#a2d23a10865edb3459475dd48d4d90c16"></a><br/></td></tr>
<tr class="separator:a2d23a10865edb3459475dd48d4d90c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c11aedfb44fe470060747f46655ec50"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a4c11aedfb44fe470060747f46655ec50">ReaderTermsIndexDivisor</a><code> [get, set]</code></td></tr>
<tr class="separator:a4c11aedfb44fe470060747f46655ec50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e99233c275fbaf89ce4f71e0d22269"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a90e99233c275fbaf89ce4f71e0d22269">MergeFactor</a><code> [get, set]</code></td></tr>
<tr class="memdesc:a90e99233c275fbaf89ce4f71e0d22269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets or sets the number of segments that are merged at once and also controls the total number of segments allowed to accumulate in the index. Determines how often segment indices are merged by addDocument(). With smaller values, less RAM is used while indexing, and searches on unoptimized indices are faster, but indexing speed is slower. With larger values, more RAM is used during indexing, and while searches on unoptimized indices are slower, indexing is faster. Thus larger values (&gt; 10) are best for batch index creation, and smaller values (&lt; 10) for indices that are interactively maintained.  <a href="#a90e99233c275fbaf89ce4f71e0d22269"></a><br/></td></tr>
<tr class="separator:a90e99233c275fbaf89ce4f71e0d22269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d4b0ded13c15df91f8a61bd8625590"><td class="memItemLeft" align="right" valign="top">static StreamWriter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#ad0d4b0ded13c15df91f8a61bd8625590">DefaultInfoStream</a><code> [get, set]</code></td></tr>
<tr class="memdesc:ad0d4b0ded13c15df91f8a61bd8625590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets or sets the default info stream. If non-null, this will be the default infoStream used by a newly instantiated <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a>.  <a href="#ad0d4b0ded13c15df91f8a61bd8625590"></a><br/></td></tr>
<tr class="separator:ad0d4b0ded13c15df91f8a61bd8625590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e46eb19436b37c6d38284106816732d"><td class="memItemLeft" align="right" valign="top">virtual StreamWriter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a5e46eb19436b37c6d38284106816732d">InfoStream</a><code> [get]</code></td></tr>
<tr class="memdesc:a5e46eb19436b37c6d38284106816732d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current infoStream in use by this writer. <a href="#a5e46eb19436b37c6d38284106816732d"></a><br/></td></tr>
<tr class="separator:a5e46eb19436b37c6d38284106816732d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac169fab8e4b1bb5f6167521bc3a012ba"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#ac169fab8e4b1bb5f6167521bc3a012ba">Verbose</a><code> [get]</code></td></tr>
<tr class="memdesc:ac169fab8e4b1bb5f6167521bc3a012ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if verbosing is enabled (i.e., infoStream != null).  <a href="#ac169fab8e4b1bb5f6167521bc3a012ba"></a><br/></td></tr>
<tr class="separator:ac169fab8e4b1bb5f6167521bc3a012ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88765a6d0199ffe5b45d6fdedcaa0a92"><td class="memItemLeft" align="right" valign="top">virtual long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a88765a6d0199ffe5b45d6fdedcaa0a92">WriteLockTimeout</a><code> [get, set]</code></td></tr>
<tr class="memdesc:a88765a6d0199ffe5b45d6fdedcaa0a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets or sets allowed timeout when acquiring the write lock. <a href="#a88765a6d0199ffe5b45d6fdedcaa0a92"></a><br/></td></tr>
<tr class="separator:a88765a6d0199ffe5b45d6fdedcaa0a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25c05c7cbbf50fbf5a6dd18f9008245"><td class="memItemLeft" align="right" valign="top">static long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#ae25c05c7cbbf50fbf5a6dd18f9008245">DefaultWriteLockTimeout</a><code> [get, set]</code></td></tr>
<tr class="memdesc:ae25c05c7cbbf50fbf5a6dd18f9008245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets or sets the default (for any instance of <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a>) maximum time to wait for a write lock (in milliseconds).  <a href="#ae25c05c7cbbf50fbf5a6dd18f9008245"></a><br/></td></tr>
<tr class="separator:ae25c05c7cbbf50fbf5a6dd18f9008245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1c7cb1f5060b72d2cd346870525c3c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../dd/df1/_syns2_index_8cs.html#aada057080323f6e867d8f9c189276716">Directory</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a3b1c7cb1f5060b72d2cd346870525c3c">Directory</a><code> [get]</code></td></tr>
<tr class="memdesc:a3b1c7cb1f5060b72d2cd346870525c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Directory used by this index.  <a href="#a3b1c7cb1f5060b72d2cd346870525c3c"></a><br/></td></tr>
<tr class="separator:a3b1c7cb1f5060b72d2cd346870525c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb5084a704bb4b22096429e21262d61"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../dd/d53/_more_like_this_8cs.html#a7f807a855319cb4e1efa0e1fcd2a537f">Analyzer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a5fb5084a704bb4b22096429e21262d61">Analyzer</a><code> [get]</code></td></tr>
<tr class="memdesc:a5fb5084a704bb4b22096429e21262d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the analyzer used by this index.  <a href="#a5fb5084a704bb4b22096429e21262d61"></a><br/></td></tr>
<tr class="separator:a5fb5084a704bb4b22096429e21262d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316e18a963f39495c3fb6c73f16c905b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../de/ddd/class_lucene_1_1_net_1_1_index_1_1_index_writer_1_1_index_reader_warmer.html">IndexReaderWarmer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a316e18a963f39495c3fb6c73f16c905b">MergedSegmentWarmer</a><code> [get, set]</code></td></tr>
<tr class="memdesc:a316e18a963f39495c3fb6c73f16c905b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets or sets the merged segment warmer. See <a class="el" href="../../de/ddd/class_lucene_1_1_net_1_1_index_1_1_index_writer_1_1_index_reader_warmer.html" title="If GetReader() has been called (ie, this writer is in near real-time mode), then after a merge comple...">IndexReaderWarmer</a>  <a href="#a316e18a963f39495c3fb6c73f16c905b"></a><br/></td></tr>
<tr class="separator:a316e18a963f39495c3fb6c73f16c905b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An <code><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a></code> creates and maintains an index. </p>
<p>The <code>create</code> argument to the <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#af4620c14320934601058e0e9cac9bfab">constructor</a> determines whether a new index is created, or whether an existing index is opened. Note that you can open an index with <code>create=true</code> even while readers are using the index. The old readers will continue to search the "point in time" snapshot they had opened, and won't see the newly created index until they re-open. There are also <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a126123a1a5cdecf263e45e5a36369457">constructors</a> with no <code>create</code> argument which will create a new index if there is not already an index at the provided path and otherwise open the existing index.</p>
<p>In either case, documents are added with <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a000da5a984e6cce2aee03cbaf121a53f" title="Adds a document to this index. If the document contains more than SetMaxFieldLength(int) terms for a ...">AddDocument(Document)</a> and removed with <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a07b556766e1a2a68836906f3d66ffc27" title="Deletes the document(s) containing term.">DeleteDocuments(Term)</a> or <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a2d79488123fefa3e4bbda53b94ae3e89" title="Deletes the document(s) matching the provided query.">DeleteDocuments(Query)</a>. A document can be updated with <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a3667a5f5d4cffeb250ed20c2da19178b" title="Updates a document by first deleting the document(s) containing term and then adding the new document...">UpdateDocument(Term, Document)</a> (which just deletes and then adds the entire document). When finished adding, deleting and updating documents, <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#abe4383aeee76431a2b30b10e5ffb4b87" title="Commits all changes to an index and closes all associated files. Note that this may be a costly opera...">Close()</a> should be called.</p>
<p><a class="anchor" id="flush"></a> </p>
<p>These changes are buffered in memory and periodically flushed to the <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a3b1c7cb1f5060b72d2cd346870525c3c" title="Returns the Directory used by this index. ">Directory</a> (during the above method calls). A flush is triggered when there are enough buffered deletes (see <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a6ba86647b33915ad12d588238fbd996e" title="Determines the minimal number of delete terms required before the buffered in-memory delete terms are...">SetMaxBufferedDeleteTerms</a>) or enough added documents since the last flush, whichever is sooner. For the added documents, flushing is triggered either by RAM usage of the documents (see <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#aee00b6cfce82c5e8e7eb088afbfcd465" title="Determines the amount of RAM that may be used for buffering added documents and deletions before they...">SetRAMBufferSizeMB</a>) or the number of added documents. The default is to flush when RAM usage hits 16 MB. For best indexing speed you should flush by RAM usage with a large RAM buffer. Note that flushing just moves the internal buffered state in <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a> into the index, but these changes are not visible to <a class="el" href="../../d6/d27/class_lucene_1_1_net_1_1_index_1_1_index_reader.html" title="IndexReader is an abstract class, providing an interface for accessing an index. Search of an index i...">IndexReader</a> until either <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#ad1df12452bb45f153d9d06e1c160e2ff" title="Commits all pending changes (added &amp; deleted documents, optimizations, segment merges, added indexes, etc.) to the index, and syncs all referenced index files, such that a reader will see the changes and the index updates will survive an OS or machine crash or power loss. Note that this does not wait for any running background merges to finish. This may be a costly operation, so you should test the cost in your application and do it only when really necessary.">Commit()</a> or <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#abe4383aeee76431a2b30b10e5ffb4b87" title="Commits all changes to an index and closes all associated files. Note that this may be a costly opera...">Close()</a> is called. A flush may also trigger one or more segment merges which by default run with a background thread so as not to block the addDocument calls (see <a href="../../#mergePolicy">below</a> for changing the <a class="el" href="../../d9/d30/class_lucene_1_1_net_1_1_index_1_1_merge_scheduler.html" title="Expert: IndexWriter uses an instance implementing this interface to execute the merges selected by a ...">MergeScheduler</a>). </p>
<p>If an index will not have more documents added for a while and optimal search performance is desired, then either the full <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a19cfeeb684bdfee1802e51fcb9d49559" title="Requests an &quot;optimize&quot; operation on an index, priming the index for the fastest available search...">Optimize()</a> method or partial <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a214dc271d1438e9072dda4cf33962ec7" title="Optimize the index down to &lt;= maxNumSegments. If maxNumSegments==1 then this is the same as Optimize(...">Optimize(int)</a> method should be called before the index is closed. </p>
<p>Opening an <code><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a></code> creates a lock file for the directory in use. Trying to open another <code><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a></code> on the same directory will lead to a <a class="el" href="../../d0/d90/_index_writer_8cs.html#a681d344289754da86d367afaac7bd3d7">LockObtainFailedException</a>. The <a class="el" href="../../d0/d90/_index_writer_8cs.html#a681d344289754da86d367afaac7bd3d7">LockObtainFailedException</a> is also thrown if an <a class="el" href="../../d6/d27/class_lucene_1_1_net_1_1_index_1_1_index_reader.html" title="IndexReader is an abstract class, providing an interface for accessing an index. Search of an index i...">IndexReader</a> on the same directory is used to delete documents from the index.</p>
<p><a class="anchor" id="deletionPolicy"></a> </p>
<p>Expert: <code><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a></code> allows an optional <a class="el" href="../../d7/d90/interface_lucene_1_1_net_1_1_index_1_1_index_deletion_policy.html" title="Expert: policy for deletion of stale index commits.">IndexDeletionPolicy</a> implementation to be specified. You can use this to control when prior commits are deleted from the index. The default policy is <a class="el" href="../../d8/d88/class_lucene_1_1_net_1_1_index_1_1_keep_only_last_commit_deletion_policy.html" title="This IndexDeletionPolicy implementation that keeps only the most recent commit and immediately remove...">KeepOnlyLastCommitDeletionPolicy</a> which removes all prior commits as soon as a new commit is done (this matches behavior before 2.2). Creating your own policy can allow you to explicitly keep previous "point in time" commits alive in the index for some time, to allow readers to refresh to the new commit without having the old commit deleted out from under them. This is necessary on filesystems like NFS that do not support "delete on last
 close" semantics, which <a class="el" href="../../df/d7a/namespace_lucene.html">Lucene</a>'s "point in time" search normally relies on. </p>
<p><a class="anchor" id="mergePolicy"></a> </p>
<p>Expert: <code><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a></code> allows you to separately change the <a class="el" href="../../d2/dce/class_lucene_1_1_net_1_1_index_1_1_merge_policy.html" title="Expert: a MergePolicy determines the sequence of primitive merge operations to be used for overall me...">MergePolicy</a> and the <a class="el" href="../../d9/d30/class_lucene_1_1_net_1_1_index_1_1_merge_scheduler.html" title="Expert: IndexWriter uses an instance implementing this interface to execute the merges selected by a ...">MergeScheduler</a>. The <a class="el" href="../../d2/dce/class_lucene_1_1_net_1_1_index_1_1_merge_policy.html" title="Expert: a MergePolicy determines the sequence of primitive merge operations to be used for overall me...">MergePolicy</a> is invoked whenever there are changes to the segments in the index. Its role is to select which merges to do, if any, and return a <a class="el" href="../../dc/d78/class_lucene_1_1_net_1_1_index_1_1_merge_policy_1_1_merge_specification.html" title="A MergeSpecification instance provides the information necessary to perform multiple merges...">Index.MergePolicy.MergeSpecification</a> describing the merges. It also selects merges to do for optimize(). (The default is <a class="el" href="../../de/d2f/class_lucene_1_1_net_1_1_index_1_1_log_byte_size_merge_policy.html" title="This is a LogMergePolicy that measures size of a segment as the total byte size of the segment&#39;s file...">LogByteSizeMergePolicy</a>. Then, the <a class="el" href="../../d9/d30/class_lucene_1_1_net_1_1_index_1_1_merge_scheduler.html" title="Expert: IndexWriter uses an instance implementing this interface to execute the merges selected by a ...">MergeScheduler</a> is invoked with the requested merges and it decides when and how to run the merges. The default is <a class="el" href="../../d7/d45/class_lucene_1_1_net_1_1_index_1_1_concurrent_merge_scheduler.html" title="A MergeScheduler that runs each merge using a separate thread, up until a maximum number of threads (...">ConcurrentMergeScheduler</a>. </p>
<p><a class="anchor" id="OOME"></a></p>
<p><b>NOTE</b>: if you hit an OutOfMemoryError then <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a> will quietly record this fact and block all future segment commits. This is a defensive measure in case any internal state (buffered documents and deletions) were corrupted. Any subsequent calls to <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#ad1df12452bb45f153d9d06e1c160e2ff" title="Commits all pending changes (added &amp; deleted documents, optimizations, segment merges, added indexes, etc.) to the index, and syncs all referenced index files, such that a reader will see the changes and the index updates will survive an OS or machine crash or power loss. Note that this does not wait for any running background merges to finish. This may be a costly operation, so you should test the cost in your application and do it only when really necessary.">Commit()</a> will throw an IllegalStateException. The only course of action is to call <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#abe4383aeee76431a2b30b10e5ffb4b87" title="Commits all changes to an index and closes all associated files. Note that this may be a costly opera...">Close()</a>, which internally will call <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a6585064853f33355bf4b450ec88fd727" title="Close the IndexWriter without committing any changes that have occurred since the last commit (or sin...">Rollback()</a> , to undo any changes to the index since the last commit. You can also just call <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a6585064853f33355bf4b450ec88fd727" title="Close the IndexWriter without committing any changes that have occurred since the last commit (or sin...">Rollback()</a> directly.</p>
<p><a class="anchor" id="thread-safety"></a></p>
<p><b>NOTE</b>: <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a> instances are completely thread safe, meaning multiple threads can call any of its methods, concurrently. If your application requires external synchronization, you should <b>not</b> synchronize on the <code><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a></code> instance as this may cause deadlock; use your own (non-Lucene) objects instead. </p>
<p><b>NOTE:</b> if you call <code>Thread.Interrupt()</code> on a thread that's within <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a>, <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a> will try to catch this (eg, if it's in a Wait() or Thread.Sleep()), and will then throw the unchecked exception System.Threading.ThreadInterruptedException and <b>clear</b> the interrupt status on the thread</p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l00160">160</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af4620c14320934601058e0e9cac9bfab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Lucene.Net.Index.IndexWriter.IndexWriter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/df1/_syns2_index_8cs.html#aada057080323f6e867d8f9c189276716">Directory</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d53/_more_like_this_8cs.html#a7f807a855319cb4e1efa0e1fcd2a537f">Analyzer</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>create</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d33/class_lucene_1_1_net_1_1_index_1_1_index_writer_1_1_max_field_length.html">MaxFieldLength</a>&#160;</td>
          <td class="paramname"><em>mfl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a> for the index in <code>d</code>. Text will be analyzed with <code>a</code>. If <code>create</code> is true, then a new, empty index will be created in <code>d</code>, replacing the index already there, if any. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>the index directory </td></tr>
    <tr><td class="paramname">a</td><td>the analyzer to use </td></tr>
    <tr><td class="paramname">create</td><td><code>true</code> to create the index or overwrite the existing one; <code>false</code> to append to the existing index </td></tr>
    <tr><td class="paramname">mfl</td><td>Maximum field length in number of terms/tokens: LIMITED, UNLIMITED, or user-specified via the <a class="el" href="../../d4/d33/class_lucene_1_1_net_1_1_index_1_1_index_writer_1_1_max_field_length.html" title="Specifies maximum field length (in number of tokens/terms) in IndexWriter constructors. SetMaxFieldLength(int) overrides the value set by the constructor. ">MaxFieldLength</a> constructor. </td></tr>
  </table>
  </dd>
</dl>
<p>&lt;throws&gt; <a class="el" href="../../d6/d74/class_lucene_1_1_net_1_1_index_1_1_corrupt_index_exception.html" title="This exception is thrown when Lucene detects an inconsistency in the index. ">CorruptIndexException</a> if the index is corrupt &lt;/throws&gt; &lt;throws&gt; LockObtainFailedException if another writer &lt;/throws&gt; </p>
<p>has this index open (<code>write.lock</code> could not be obtained) </p>
<p>&lt;throws&gt; IOException if the directory cannot be read/written to, or &lt;/throws&gt; </p>
<p>if it does not exist and <code>create</code> is <code>false</code> or if there is any other low-level IO error </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l01015">1015</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a126123a1a5cdecf263e45e5a36369457"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Lucene.Net.Index.IndexWriter.IndexWriter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/df1/_syns2_index_8cs.html#aada057080323f6e867d8f9c189276716">Directory</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d53/_more_like_this_8cs.html#a7f807a855319cb4e1efa0e1fcd2a537f">Analyzer</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d33/class_lucene_1_1_net_1_1_index_1_1_index_writer_1_1_max_field_length.html">MaxFieldLength</a>&#160;</td>
          <td class="paramname"><em>mfl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a> for the index in <code>d</code>, first creating it if it does not already exist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>the index directory </td></tr>
    <tr><td class="paramname">a</td><td>the analyzer to use </td></tr>
    <tr><td class="paramname">mfl</td><td>Maximum field length in number of terms/tokens: LIMITED, UNLIMITED, or user-specified via the <a class="el" href="../../d4/d33/class_lucene_1_1_net_1_1_index_1_1_index_writer_1_1_max_field_length.html" title="Specifies maximum field length (in number of tokens/terms) in IndexWriter constructors. SetMaxFieldLength(int) overrides the value set by the constructor. ">MaxFieldLength</a> constructor. </td></tr>
  </table>
  </dd>
</dl>
<p>&lt;throws&gt; <a class="el" href="../../d6/d74/class_lucene_1_1_net_1_1_index_1_1_corrupt_index_exception.html" title="This exception is thrown when Lucene detects an inconsistency in the index. ">CorruptIndexException</a> if the index is corrupt &lt;/throws&gt; &lt;throws&gt; LockObtainFailedException if another writer &lt;/throws&gt; </p>
<p>has this index open (<code>write.lock</code> could not be obtained) </p>
<p>&lt;throws&gt; IOException if the directory cannot be &lt;/throws&gt; </p>
<p>read/written to or if there is any other low-level IO error </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l01042">1042</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a3f995f005ff8ec6e2130a46613127765"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Lucene.Net.Index.IndexWriter.IndexWriter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/df1/_syns2_index_8cs.html#aada057080323f6e867d8f9c189276716">Directory</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d53/_more_like_this_8cs.html#a7f807a855319cb4e1efa0e1fcd2a537f">Analyzer</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d7/d90/interface_lucene_1_1_net_1_1_index_1_1_index_deletion_policy.html">IndexDeletionPolicy</a>&#160;</td>
          <td class="paramname"><em>deletionPolicy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d33/class_lucene_1_1_net_1_1_index_1_1_index_writer_1_1_max_field_length.html">MaxFieldLength</a>&#160;</td>
          <td class="paramname"><em>mfl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expert: constructs an <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a> with a custom <a class="el" href="../../d7/d90/interface_lucene_1_1_net_1_1_index_1_1_index_deletion_policy.html" title="Expert: policy for deletion of stale index commits.">IndexDeletionPolicy</a> , for the index in <code>d</code>, first creating it if it does not already exist. Text will be analyzed with <code>a</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>the index directory </td></tr>
    <tr><td class="paramname">a</td><td>the analyzer to use </td></tr>
    <tr><td class="paramname">deletionPolicy</td><td>see <a href="../../#deletionPolicy">above</a> </td></tr>
    <tr><td class="paramname">mfl</td><td>whether or not to limit field lengths </td></tr>
  </table>
  </dd>
</dl>
<p>&lt;throws&gt; <a class="el" href="../../d6/d74/class_lucene_1_1_net_1_1_index_1_1_corrupt_index_exception.html" title="This exception is thrown when Lucene detects an inconsistency in the index. ">CorruptIndexException</a> if the index is corrupt &lt;/throws&gt; &lt;throws&gt; LockObtainFailedException if another writer &lt;/throws&gt; </p>
<p>has this index open (<code>write.lock</code> could not be obtained) </p>
<p>&lt;throws&gt; IOException if the directory cannot be &lt;/throws&gt; </p>
<p>read/written to or if there is any other low-level IO error </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l01071">1071</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a116bca44ae8e99e740aa8cfdc06da545"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Lucene.Net.Index.IndexWriter.IndexWriter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/df1/_syns2_index_8cs.html#aada057080323f6e867d8f9c189276716">Directory</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d53/_more_like_this_8cs.html#a7f807a855319cb4e1efa0e1fcd2a537f">Analyzer</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>create</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d7/d90/interface_lucene_1_1_net_1_1_index_1_1_index_deletion_policy.html">IndexDeletionPolicy</a>&#160;</td>
          <td class="paramname"><em>deletionPolicy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d33/class_lucene_1_1_net_1_1_index_1_1_index_writer_1_1_max_field_length.html">MaxFieldLength</a>&#160;</td>
          <td class="paramname"><em>mfl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expert: constructs an <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a> with a custom <a class="el" href="../../d7/d90/interface_lucene_1_1_net_1_1_index_1_1_index_deletion_policy.html" title="Expert: policy for deletion of stale index commits.">IndexDeletionPolicy</a> , for the index in <code>d</code>. Text will be analyzed with <code>a</code>. If <code>create</code> is true, then a new, empty index will be created in <code>d</code>, replacing the index already there, if any. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>the index directory </td></tr>
    <tr><td class="paramname">a</td><td>the analyzer to use </td></tr>
    <tr><td class="paramname">create</td><td><code>true</code> to create the index or overwrite the existing one; <code>false</code> to append to the existing index </td></tr>
    <tr><td class="paramname">deletionPolicy</td><td>see <a href="../../#deletionPolicy">above</a> </td></tr>
    <tr><td class="paramname">mfl</td><td><a class="el" href="../../d4/d33/class_lucene_1_1_net_1_1_index_1_1_index_writer_1_1_max_field_length.html" title="Specifies maximum field length (in number of tokens/terms) in IndexWriter constructors. SetMaxFieldLength(int) overrides the value set by the constructor. ">Lucene.Net.Index.IndexWriter.MaxFieldLength</a>, whether or not to limit field lengths. Value is in number of terms/tokens </td></tr>
  </table>
  </dd>
</dl>
<p>&lt;throws&gt; <a class="el" href="../../d6/d74/class_lucene_1_1_net_1_1_index_1_1_corrupt_index_exception.html" title="This exception is thrown when Lucene detects an inconsistency in the index. ">CorruptIndexException</a> if the index is corrupt &lt;/throws&gt; &lt;throws&gt; LockObtainFailedException if another writer &lt;/throws&gt; </p>
<p>has this index open (<code>write.lock</code> could not be obtained) </p>
<p>&lt;throws&gt; IOException if the directory cannot be read/written to, or &lt;/throws&gt; </p>
<p>if it does not exist and <code>create</code> is <code>false</code> or if there is any other low-level IO error </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l01107">1107</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a5b3e2d8418a8ddef9758d4cedfa89c7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Lucene.Net.Index.IndexWriter.IndexWriter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/df1/_syns2_index_8cs.html#aada057080323f6e867d8f9c189276716">Directory</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d53/_more_like_this_8cs.html#a7f807a855319cb4e1efa0e1fcd2a537f">Analyzer</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d7/d90/interface_lucene_1_1_net_1_1_index_1_1_index_deletion_policy.html">IndexDeletionPolicy</a>&#160;</td>
          <td class="paramname"><em>deletionPolicy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d33/class_lucene_1_1_net_1_1_index_1_1_index_writer_1_1_max_field_length.html">MaxFieldLength</a>&#160;</td>
          <td class="paramname"><em>mfl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/de7/class_lucene_1_1_net_1_1_index_1_1_index_commit.html">IndexCommit</a>&#160;</td>
          <td class="paramname"><em>commit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expert: constructs an <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a> on specific commit point, with a custom <a class="el" href="../../d7/d90/interface_lucene_1_1_net_1_1_index_1_1_index_deletion_policy.html" title="Expert: policy for deletion of stale index commits.">IndexDeletionPolicy</a>, for the index in <code>d</code>. Text will be analyzed with <code>a</code>. </p>
<p>This is only meaningful if you've used a <a class="el" href="../../d7/d90/interface_lucene_1_1_net_1_1_index_1_1_index_deletion_policy.html" title="Expert: policy for deletion of stale index commits.">IndexDeletionPolicy</a> in that past that keeps more than just the last commit.</p>
<p>This operation is similar to <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a6585064853f33355bf4b450ec88fd727" title="Close the IndexWriter without committing any changes that have occurred since the last commit (or sin...">Rollback()</a>, except that method can only rollback what's been done with the current instance of <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a> since its last commit, whereas this method can rollback to an arbitrary commit point from the past, assuming the <a class="el" href="../../d7/d90/interface_lucene_1_1_net_1_1_index_1_1_index_deletion_policy.html" title="Expert: policy for deletion of stale index commits.">IndexDeletionPolicy</a> has preserved past commits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>the index directory </td></tr>
    <tr><td class="paramname">a</td><td>the analyzer to use </td></tr>
    <tr><td class="paramname">deletionPolicy</td><td>see <a href="../../#deletionPolicy">above</a> </td></tr>
    <tr><td class="paramname">mfl</td><td>whether or not to limit field lengths, value is in number of terms/tokens. See <a class="el" href="../../d4/d33/class_lucene_1_1_net_1_1_index_1_1_index_writer_1_1_max_field_length.html" title="Specifies maximum field length (in number of tokens/terms) in IndexWriter constructors. SetMaxFieldLength(int) overrides the value set by the constructor. ">Lucene.Net.Index.IndexWriter.MaxFieldLength</a>. </td></tr>
    <tr><td class="paramname">commit</td><td>which commit to open </td></tr>
  </table>
  </dd>
</dl>
<p>&lt;throws&gt; <a class="el" href="../../d6/d74/class_lucene_1_1_net_1_1_index_1_1_corrupt_index_exception.html" title="This exception is thrown when Lucene detects an inconsistency in the index. ">CorruptIndexException</a> if the index is corrupt &lt;/throws&gt; &lt;throws&gt; LockObtainFailedException if another writer &lt;/throws&gt; </p>
<p>has this index open (<code>write.lock</code> could not be obtained) </p>
<p>&lt;throws&gt; IOException if the directory cannot be read/written to, or &lt;/throws&gt; </p>
<p>if it does not exist and <code>create</code> is <code>false</code> or if there is any other low-level IO error </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l01193">1193</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a000da5a984e6cce2aee03cbaf121a53f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Lucene.Net.Index.IndexWriter.AddDocument </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d53/_more_like_this_8cs.html#a2ad6aef8641c7b7a6cf9277f7d54b2cd">Document</a>&#160;</td>
          <td class="paramname"><em>doc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a document to this index. If the document contains more than <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a91be1a71d5a51f7232dc2b6f5e021d9e" title="The maximum number of terms that will be indexed for a single field in a document. This limits the amount of memory required for indexing, so that collections with very large files will not crash the indexing process by running out of memory. This setting refers to the number of running terms, not to the number of different terms.Note: this silently truncates large documents, excluding from the index all terms that occur further in the document. If you know your source documents are large, be sure to set this value high enough to accomodate the expected size. If you set it to Integer.MAX_VALUE, then the only limit is your memory, but you should anticipate an OutOfMemoryError.By default, no more than DEFAULT_MAX_FIELD_LENGTH terms will be indexed for a field. ">SetMaxFieldLength(int)</a> terms for a given field, the remainder are discarded. </p>
<p>Note that if an Exception is hit (for example disk full) then the index will be consistent, but this document may not have been added. Furthermore, it's possible the index will have one segment in non-compound format even when using compound files (when a merge has partially succeeded).</p>
<p>This method periodically flushes pending documents to the Directory (see <a href="../../#flush">above</a>), and also periodically triggers segment merges in the index according to the <a class="el" href="../../d2/dce/class_lucene_1_1_net_1_1_index_1_1_merge_policy.html" title="Expert: a MergePolicy determines the sequence of primitive merge operations to be used for overall me...">MergePolicy</a> in use.</p>
<p>Merges temporarily consume space in the directory. The amount of space required is up to 1X the size of all segments being merged, when no readers/searchers are open against the index, and up to 2X the size of all segments being merged when readers/searchers are open against the index (see <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a19cfeeb684bdfee1802e51fcb9d49559" title="Requests an &quot;optimize&quot; operation on an index, priming the index for the fastest available search...">Optimize()</a> for details). The sequence of primitive merge operations performed is governed by the merge policy.</p>
<p>Note that each term in the document can be no longer than 16383 characters, otherwise an IllegalArgumentException will be thrown.</p>
<p>Note that it's possible to create an invalid Unicode string in java if a UTF16 surrogate pair is malformed. In this case, the invalid characters are silently replaced with the Unicode replacement character U+FFFD.</p>
<p><b>NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer. See <a href="../../#OOME">above</a> for details.</p>
<p>&lt;throws&gt; <a class="el" href="../../d6/d74/class_lucene_1_1_net_1_1_index_1_1_corrupt_index_exception.html" title="This exception is thrown when Lucene detects an inconsistency in the index. ">CorruptIndexException</a> if the index is corrupt &lt;/throws&gt; &lt;throws&gt; IOException if there is a low-level IO error &lt;/throws&gt; </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l02301">2301</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="ae8afce956be92f2864822aa9c88ea687"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Lucene.Net.Index.IndexWriter.AddDocument </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d53/_more_like_this_8cs.html#a2ad6aef8641c7b7a6cf9277f7d54b2cd">Document</a>&#160;</td>
          <td class="paramname"><em>doc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d53/_more_like_this_8cs.html#a7f807a855319cb4e1efa0e1fcd2a537f">Analyzer</a>&#160;</td>
          <td class="paramname"><em>analyzer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a document to this index, using the provided analyzer instead of the value of <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a5fb5084a704bb4b22096429e21262d61" title="Returns the analyzer used by this index. ">Analyzer</a>. If the document contains more than <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a91be1a71d5a51f7232dc2b6f5e021d9e" title="The maximum number of terms that will be indexed for a single field in a document. This limits the amount of memory required for indexing, so that collections with very large files will not crash the indexing process by running out of memory. This setting refers to the number of running terms, not to the number of different terms.Note: this silently truncates large documents, excluding from the index all terms that occur further in the document. If you know your source documents are large, be sure to set this value high enough to accomodate the expected size. If you set it to Integer.MAX_VALUE, then the only limit is your memory, but you should anticipate an OutOfMemoryError.By default, no more than DEFAULT_MAX_FIELD_LENGTH terms will be indexed for a field. ">SetMaxFieldLength(int)</a> terms for a given field, the remainder are discarded. </p>
<p>See <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a000da5a984e6cce2aee03cbaf121a53f" title="Adds a document to this index. If the document contains more than SetMaxFieldLength(int) terms for a ...">AddDocument(Document)</a> for details on index and <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a> state after an Exception, and flushing/merging temporary free space requirements.</p>
<p><b>NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer. See <a href="../../#OOME">above</a> for details.</p>
<p>&lt;throws&gt; <a class="el" href="../../d6/d74/class_lucene_1_1_net_1_1_index_1_1_corrupt_index_exception.html" title="This exception is thrown when Lucene detects an inconsistency in the index. ">CorruptIndexException</a> if the index is corrupt &lt;/throws&gt; &lt;throws&gt; IOException if there is a low-level IO error &lt;/throws&gt; </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l02322">2322</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a9b0b1546bb8fee0480823dee19046f45"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Lucene.Net.Index.IndexWriter.AddIndexes </td>
          <td>(</td>
          <td class="paramtype">params <a class="el" href="../../d6/d27/class_lucene_1_1_net_1_1_index_1_1_index_reader.html">IndexReader</a>[]&#160;</td>
          <td class="paramname"><em>readers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merges the provided indexes into this index. After this completes, the index is optimized. The provided IndexReaders are not closed.</p>
<p><b>NOTE:</b> while this is running, any attempts to add or delete documents (with another thread) will be paused until this method completes.</p>
<p>See AddIndexesNoOptimize(Directory[]) for details on transactional semantics, temporary free space required in the Directory, and non-CFS segments on an Exception.</p>
<p><b>NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer. See <a href="../../#OOME">above</a> for details.</p>
<p>&lt;throws&gt; <a class="el" href="../../d6/d74/class_lucene_1_1_net_1_1_index_1_1_corrupt_index_exception.html" title="This exception is thrown when Lucene detects an inconsistency in the index. ">CorruptIndexException</a> if the index is corrupt &lt;/throws&gt; &lt;throws&gt; IOException if there is a low-level IO error &lt;/throws&gt; summary&gt; A hook for extending classes to execute operations after pending added and deleted documents have been flushed to the Directory but before the change is committed (new segments_N file written). /summary&gt; </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l03781">3781</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="ab6e1537958bf485ce9d1195b2eece3cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Lucene.Net.Index.IndexWriter.AddIndexesNoOptimize </td>
          <td>(</td>
          <td class="paramtype">params <a class="el" href="../../dd/df1/_syns2_index_8cs.html#aada057080323f6e867d8f9c189276716">Directory</a>[]&#160;</td>
          <td class="paramname"><em>dirs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merges all segments from an array of indexes into this index. </p>
<p>This may be used to parallelize batch indexing. A large document collection can be broken into sub-collections. Each sub-collection can be indexed in parallel, on a different thread, process or machine. The complete index can then be created by merging sub-collection indexes with this method.</p>
<p><b>NOTE:</b> the index in each Directory must not be changed (opened by a writer) while this method is running. This method does not acquire a write lock in each input Directory, so it is up to the caller to enforce this.</p>
<p><b>NOTE:</b> while this is running, any attempts to add or delete documents (with another thread) will be paused until this method completes.</p>
<p>This method is transactional in how Exceptions are handled: it does not commit a new segments_N file until all indexes are added. This means if an Exception occurs (for example disk full), then either no indexes will have been added or they all will have been.</p>
<p>Note that this requires temporary free space in the Directory up to 2X the sum of all input indexes (including the starting index). If readers/searchers are open against the starting index, then temporary free space required will be higher by the size of the starting index (see <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a19cfeeb684bdfee1802e51fcb9d49559" title="Requests an &quot;optimize&quot; operation on an index, priming the index for the fastest available search...">Optimize()</a> for details). </p>
<p>Once this completes, the final size of the index will be less than the sum of all input index sizes (including the starting index). It could be quite a bit smaller (if there were many pending deletes) or just slightly smaller.</p>
<p>This requires this index not be among those to be added.</p>
<p><b>NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer. See <a href="../../#OOME">above</a> for details.</p>
<p>&lt;throws&gt; <a class="el" href="../../d6/d74/class_lucene_1_1_net_1_1_index_1_1_corrupt_index_exception.html" title="This exception is thrown when Lucene detects an inconsistency in the index. ">CorruptIndexException</a> if the index is corrupt &lt;/throws&gt; &lt;throws&gt; IOException if there is a low-level IO error &lt;/throws&gt; </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l03583">3583</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="abe4383aeee76431a2b30b10e5ffb4b87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lucene.Net.Index.IndexWriter.Close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Commits all changes to an index and closes all associated files. Note that this may be a costly operation, so, try to re-use a single writer instead of closing and opening a new one. See <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#ad1df12452bb45f153d9d06e1c160e2ff" title="Commits all pending changes (added &amp; deleted documents, optimizations, segment merges, added indexes, etc.) to the index, and syncs all referenced index files, such that a reader will see the changes and the index updates will survive an OS or machine crash or power loss. Note that this does not wait for any running background merges to finish. This may be a costly operation, so you should test the cost in your application and do it only when really necessary.">Commit()</a> for caveats about write caching done by some IO devices. </p>
<p>If an Exception is hit during close, eg due to disk full or some other reason, then both the on-disk index and the internal state of the <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a> instance will be consistent. However, the close will not be complete even though part of it (flushing buffered documents) may have succeeded, so the write lock will still be held.</p>
<p>If you can correct the underlying cause (eg free up some disk space) then you can call close() again. Failing that, if you want to force the write lock to be released (dangerous, because you may then lose buffered docs in the <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a> instance) then you can do something like this:</p>
<p><code> try { writer.close(); } finally { if (IndexWriter.isLocked(directory)) { IndexWriter.unlock(directory); } } </code></p>
<p>after which, you must be certain not to use the writer instance anymore.</p>
<p><b>NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer, again. See <a href="../../#OOME">above</a> for details.</p>
<p>&lt;throws&gt; <a class="el" href="../../d6/d74/class_lucene_1_1_net_1_1_index_1_1_corrupt_index_exception.html" title="This exception is thrown when Lucene detects an inconsistency in the index. ">CorruptIndexException</a> if the index is corrupt &lt;/throws&gt; &lt;throws&gt; IOException if there is a low-level IO error &lt;/throws&gt; </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l01825">1825</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a24977b3c172ea49d2d66098885dcf63d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Lucene.Net.Index.IndexWriter.Close </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>waitForMerges</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Closes the index with or without waiting for currently running merges to finish. This is only meaningful when using a <a class="el" href="../../d9/d30/class_lucene_1_1_net_1_1_index_1_1_merge_scheduler.html" title="Expert: IndexWriter uses an instance implementing this interface to execute the merges selected by a ...">MergeScheduler</a> that runs merges in background threads. </p>
<p><b>NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer, again. See <a href="../../#OOME">above</a> for details.</p>
<p><b>NOTE</b>: it is dangerous to always call close(false), especially when <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a> is not open for very long, because this can result in "merge
starvation" whereby long merges will never have a chance to finish. This will cause too many segments in your index over time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waitForMerges</td><td>if true, this call will block until all merges complete; else, it will ask all running merges to abort, wait until those merges have finished (which should be at most a few seconds), and then return. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l01946">1946</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="ad1df12452bb45f153d9d06e1c160e2ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lucene.Net.Index.IndexWriter.Commit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Commits all pending changes (added &amp; deleted documents, optimizations, segment merges, added indexes, etc.) to the index, and syncs all referenced index files, such that a reader will see the changes and the index updates will survive an OS or machine crash or power loss. Note that this does not wait for any running background merges to finish. This may be a costly operation, so you should test the cost in your application and do it only when really necessary.</p>
<p>Note that this operation calls Directory.sync on the index files. That call should not return until the file contents &amp; metadata are on stable storage. For FSDirectory, this calls the OS's fsync. But, beware: some hardware devices may in fact cache writes even during fsync, and return before the bits are actually on stable storage, to give the appearance of faster performance. If you have such a device, and it does not have a battery backup (for example) then on power loss it may still lose data. <a class="el" href="../../df/d7a/namespace_lucene.html">Lucene</a> cannot guarantee consistency on such devices. </p>
<p><b>NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer. See <a href="../../#OOME">above</a> for details.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a654d4db76a39dc6f888315b60c7f1455" title="Expert: prepare for commit.">PrepareCommit()</a></dd></dl>
<dl class="section see"><dt>See Also</dt><dd>Commit(IDictionary{string,string})</dd></dl>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l04081">4081</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a1ba869eef21db681571a29c004118a09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lucene.Net.Index.IndexWriter.Commit </td>
          <td>(</td>
          <td class="paramtype">IDictionary&lt; string, string &gt;&#160;</td>
          <td class="paramname"><em>commitUserData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Commits all changes to the index, specifying a commitUserData Map (String -&gt; String). This just calls PrepareCommit(IDictionary{string, string}) (if you didn't already call it) and then FinishCommit. </p>
<p><b>NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer. See <a href="../../#OOME">above</a> for details.</p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l04095">4095</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a3adb3b86d0b00ab2ba73ecfd81f418ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Lucene.Net.Index.IndexWriter.DeleteAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete all documents in the index. </p>
<p>This method will drop all buffered documents and will remove all segments from the index. This change will not be visible until a <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#ad1df12452bb45f153d9d06e1c160e2ff" title="Commits all pending changes (added &amp; deleted documents, optimizations, segment merges, added indexes, etc.) to the index, and syncs all referenced index files, such that a reader will see the changes and the index updates will survive an OS or machine crash or power loss. Note that this does not wait for any running background merges to finish. This may be a costly operation, so you should test the cost in your application and do it only when really necessary.">Commit()</a> has been called. This method can be rolled back using <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a6585064853f33355bf4b450ec88fd727" title="Close the IndexWriter without committing any changes that have occurred since the last commit (or sin...">Rollback()</a>.</p>
<p>NOTE: this method is much faster than using deleteDocuments( new <a class="el" href="../../dc/d87/_query_parser_8cs.html#a5bdafef6a08957cb9fda126bc524a0d5">MatchAllDocsQuery()</a> ).</p>
<p>NOTE: this method will forcefully abort all merges in progress. If other threads are running <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a19cfeeb684bdfee1802e51fcb9d49559" title="Requests an &quot;optimize&quot; operation on an index, priming the index for the fastest available search...">Optimize()</a> or any of the addIndexes methods, they will receive <a class="el" href="../../d7/d84/class_lucene_1_1_net_1_1_index_1_1_merge_policy_1_1_merge_aborted_exception.html">Index.MergePolicy.MergeAbortedException</a>s. </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l03335">3335</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a07b556766e1a2a68836906f3d66ffc27"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Lucene.Net.Index.IndexWriter.DeleteDocuments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/daf/class_lucene_1_1_net_1_1_index_1_1_term.html">Term</a>&#160;</td>
          <td class="paramname"><em>term</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the document(s) containing <code>term</code>. </p>
<p><b>NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer. See <a href="../../#OOME">above</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">term</td><td>the term to identify the documents to be deleted </td></tr>
  </table>
  </dd>
</dl>
<p>&lt;throws&gt; <a class="el" href="../../d6/d74/class_lucene_1_1_net_1_1_index_1_1_corrupt_index_exception.html" title="This exception is thrown when Lucene detects an inconsistency in the index. ">CorruptIndexException</a> if the index is corrupt &lt;/throws&gt; &lt;throws&gt; IOException if there is a low-level IO error &lt;/throws&gt; </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l02375">2375</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a08fce328d97b7c50e6080f684f76b726"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Lucene.Net.Index.IndexWriter.DeleteDocuments </td>
          <td>(</td>
          <td class="paramtype">params <a class="el" href="../../d3/daf/class_lucene_1_1_net_1_1_index_1_1_term.html">Term</a>[]&#160;</td>
          <td class="paramname"><em>terms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the document(s) containing any of the terms. All deletes are flushed at the same time. </p>
<p><b>NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer. See <a href="../../#OOME">above</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">terms</td><td>array of terms to identify the documents to be deleted </td></tr>
  </table>
  </dd>
</dl>
<p>&lt;throws&gt; <a class="el" href="../../d6/d74/class_lucene_1_1_net_1_1_index_1_1_corrupt_index_exception.html" title="This exception is thrown when Lucene detects an inconsistency in the index. ">CorruptIndexException</a> if the index is corrupt &lt;/throws&gt; &lt;throws&gt; IOException if there is a low-level IO error &lt;/throws&gt; </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l02403">2403</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a2d79488123fefa3e4bbda53b94ae3e89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Lucene.Net.Index.IndexWriter.DeleteDocuments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d53/_more_like_this_8cs.html#accbc7c5687907350ba0e2681b41e1b0d">Query</a>&#160;</td>
          <td class="paramname"><em>query</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the document(s) matching the provided query. </p>
<p><b>NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer. See <a href="../../#OOME">above</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>the query to identify the documents to be deleted </td></tr>
  </table>
  </dd>
</dl>
<p>&lt;throws&gt; <a class="el" href="../../d6/d74/class_lucene_1_1_net_1_1_index_1_1_corrupt_index_exception.html" title="This exception is thrown when Lucene detects an inconsistency in the index. ">CorruptIndexException</a> if the index is corrupt &lt;/throws&gt; &lt;throws&gt; IOException if there is a low-level IO error &lt;/throws&gt; </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l02429">2429</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a64a7d5700d30a575128de41e9f362eb1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Lucene.Net.Index.IndexWriter.DeleteDocuments </td>
          <td>(</td>
          <td class="paramtype">params <a class="el" href="../../dd/d53/_more_like_this_8cs.html#accbc7c5687907350ba0e2681b41e1b0d">Query</a>[]&#160;</td>
          <td class="paramname"><em>queries</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the document(s) matching any of the provided queries. All deletes are flushed at the same time. </p>
<p><b>NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer. See <a href="../../#OOME">above</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queries</td><td>array of queries to identify the documents to be deleted </td></tr>
  </table>
  </dd>
</dl>
<p>&lt;throws&gt; <a class="el" href="../../d6/d74/class_lucene_1_1_net_1_1_index_1_1_corrupt_index_exception.html" title="This exception is thrown when Lucene detects an inconsistency in the index. ">CorruptIndexException</a> if the index is corrupt &lt;/throws&gt; &lt;throws&gt; IOException if there is a low-level IO error &lt;/throws&gt; </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l02450">2450</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a9cc0fe31cda04b23756dacd6d16e091a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Lucene.Net.Index.IndexWriter.Dispose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Commits all changes to an index and closes all associated files. Note that this may be a costly operation, so, try to re-use a single writer instead of closing and opening a new one. See <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#ad1df12452bb45f153d9d06e1c160e2ff" title="Commits all pending changes (added &amp; deleted documents, optimizations, segment merges, added indexes, etc.) to the index, and syncs all referenced index files, such that a reader will see the changes and the index updates will survive an OS or machine crash or power loss. Note that this does not wait for any running background merges to finish. This may be a costly operation, so you should test the cost in your application and do it only when really necessary.">Commit()</a> for caveats about write caching done by some IO devices. </p>
<p>If an Exception is hit during close, eg due to disk full or some other reason, then both the on-disk index and the internal state of the <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a> instance will be consistent. However, the close will not be complete even though part of it (flushing buffered documents) may have succeeded, so the write lock will still be held.</p>
<p>If you can correct the underlying cause (eg free up some disk space) then you can call close() again. Failing that, if you want to force the write lock to be released (dangerous, because you may then lose buffered docs in the <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a> instance) then you can do something like this:</p>
<p><code> try { writer.close(); } finally { if (IndexWriter.isLocked(directory)) { IndexWriter.unlock(directory); } } </code></p>
<p>after which, you must be certain not to use the writer instance anymore.</p>
<p><b>NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer, again. See <a href="../../#OOME">above</a> for details.</p>
<p>&lt;throws&gt; <a class="el" href="../../d6/d74/class_lucene_1_1_net_1_1_index_1_1_corrupt_index_exception.html" title="This exception is thrown when Lucene detects an inconsistency in the index. ">CorruptIndexException</a> if the index is corrupt &lt;/throws&gt; &lt;throws&gt; IOException if there is a low-level IO error &lt;/throws&gt; </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l01871">1871</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a64da2894d280a7b238b54a8cb0c04116"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Lucene.Net.Index.IndexWriter.Dispose </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>waitForMerges</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Closes the index with or without waiting for currently running merges to finish. This is only meaningful when using a <a class="el" href="../../d9/d30/class_lucene_1_1_net_1_1_index_1_1_merge_scheduler.html" title="Expert: IndexWriter uses an instance implementing this interface to execute the merges selected by a ...">MergeScheduler</a> that runs merges in background threads. </p>
<p><b>NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer, again. See <a href="../../#OOME">above</a> for details.</p>
<p><b>NOTE</b>: it is dangerous to always call close(false), especially when <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a> is not open for very long, because this can result in "merge
starvation" whereby long merges will never have a chance to finish. This will cause too many segments in your index over time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waitForMerges</td><td>if true, this call will block until all merges complete; else, it will ask all running merges to abort, wait until those merges have finished (which should be at most a few seconds), and then return. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l01899">1899</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a3604153c1f92199cab0ac152ff9f145d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Lucene.Net.Index.IndexWriter.Dispose </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>disposing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>waitForMerges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l01904">1904</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a38f54eec8794d78ffc58c9ad8939ffa2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Lucene.Net.Index.IndexWriter.DoAfterFlush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>summary&gt; A hook for extending classes to execute operations before pending added and deleted documents are flushed to the Directory. /summary&gt; </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l03964">3964</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="aaead441a4456916c6f129c1de7b36d04"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Lucene.Net.Index.IndexWriter.DoBeforeFlush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l03972">3972</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="ab69c8dc2c6f40ecc8e92d0de02b17840"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Lucene.Net.Index.IndexWriter.ExpungeDeletes </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doWait</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Just like <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#aea5dfc7746eb73b6d44d1ab738cdab59" title="Expunges all deletes from the index. When an index has many document deletions (or updates to existin...">ExpungeDeletes()</a>, except you can specify whether the call should block until the operation completes. This is only meaningful with a <a class="el" href="../../d9/d30/class_lucene_1_1_net_1_1_index_1_1_merge_scheduler.html" title="Expert: IndexWriter uses an instance implementing this interface to execute the merges selected by a ...">MergeScheduler</a> that is able to run merges in background threads. </p>
<p><b>NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer. See <a href="../../#OOME">above</a> for details.</p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l02839">2839</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="aea5dfc7746eb73b6d44d1ab738cdab59"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Lucene.Net.Index.IndexWriter.ExpungeDeletes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expunges all deletes from the index. When an index has many document deletions (or updates to existing documents), it's best to either call optimize or expungeDeletes to remove all unused data in the index associated with the deleted documents. To see how many deletions you have pending in your index, call <a class="el" href="../../d6/d27/class_lucene_1_1_net_1_1_index_1_1_index_reader.html#a8ca390814a8df63b33d2221348b61552" title="Returns the number of deleted documents. ">IndexReader.NumDeletedDocs</a> This saves disk space and memory usage while searching. expungeDeletes should be somewhat faster than optimize since it does not insist on reducing the index to a single segment (though, this depends on the <a class="el" href="../../d2/dce/class_lucene_1_1_net_1_1_index_1_1_merge_policy.html" title="Expert: a MergePolicy determines the sequence of primitive merge operations to be used for overall me...">MergePolicy</a>; see <a class="el" href="../../d2/dce/class_lucene_1_1_net_1_1_index_1_1_merge_policy.html#a88ec89d1914e64f08aa0031174a7b792" title="Determine what set of merge operations is necessary in order to expunge all deletes from the index...">Index.MergePolicy.FindMergesToExpungeDeletes</a>.). Note that this call does not first commit any buffered documents, so you must do so yourself if necessary. See also </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#ab69c8dc2c6f40ecc8e92d0de02b17840" title="Just like ExpungeDeletes(), except you can specify whether the call should block until the operation ...">ExpungeDeletes(bool)</a></dd></dl>
</p>
<p><b>NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer. See <a href="../../#OOME">above</a> for details.</p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l02925">2925</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a6efcea17970d2822fc08945bab36439e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lucene.Net.Index.IndexWriter.Flush </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>triggerMerge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flushDocStores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flushDeletes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush all in-memory buffered udpates (adds and deletes) to the Directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triggerMerge</td><td>if true, we may merge segments (if deletes or docs were flushed) if necessary </td></tr>
    <tr><td class="paramname">flushDocStores</td><td>if false we are allowed to keep doc stores open to share with the next segment </td></tr>
    <tr><td class="paramname">flushDeletes</td><td>whether pending deletes should also be flushed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l04178">4178</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a5231c186c9b1d64b30d9a7b1e0d666c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Lucene.Net.Index.IndexWriter.GetDocCount </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l02560">2560</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a97789ec602d14712bd0e109a5959f435"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Lucene.Net.Index.IndexWriter.GetMaxBufferedDeleteTerms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of buffered deleted terms that will trigger a flush if enabled. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a6ba86647b33915ad12d588238fbd996e" title="Determines the minimal number of delete terms required before the buffered in-memory delete terms are...">SetMaxBufferedDeleteTerms</a></dd></dl>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l01673">1673</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="acd14299c479299920fbf759782e7c0a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Lucene.Net.Index.IndexWriter.GetMaxBufferedDocs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of buffered added documents that will trigger a flush if enabled. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a0af3f9039f7a75a70ee9e496ff4a6460" title="Determines the minimal number of documents required before the buffered in-memory documents are flush...">SetMaxBufferedDocs</a></dd></dl>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l01578">1578</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a2d51d131b3e0351dff04357fb0ee9c51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Lucene.Net.Index.IndexWriter.GetMaxFieldLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of terms that will be indexed for a single field in a document. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a91be1a71d5a51f7232dc2b6f5e021d9e" title="The maximum number of terms that will be indexed for a single field in a document. This limits the amount of memory required for indexing, so that collections with very large files will not crash the indexing process by running out of memory. This setting refers to the number of running terms, not to the number of different terms.Note: this silently truncates large documents, excluding from the index all terms that occur further in the document. If you know your source documents are large, be sure to set this value high enough to accomodate the expected size. If you set it to Integer.MAX_VALUE, then the only limit is your memory, but you should anticipate an OutOfMemoryError.By default, no more than DEFAULT_MAX_FIELD_LENGTH terms will be indexed for a field. ">SetMaxFieldLength</a></dd></dl>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l01480">1480</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a1590a85413d530f8e86b014325e00cac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double Lucene.Net.Index.IndexWriter.GetRAMBufferSizeMB </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value set by <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#aee00b6cfce82c5e8e7eb088afbfcd465" title="Determines the amount of RAM that may be used for buffering added documents and deletions before they...">SetRAMBufferSizeMB</a> if enabled.</p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l01640">1640</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a57044cd06b7b2b00bb33a08ad666d4c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../d6/d27/class_lucene_1_1_net_1_1_index_1_1_index_reader.html">IndexReader</a> Lucene.Net.Index.IndexWriter.GetReader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expert: returns a readonly reader, covering all committed as well as un-committed changes to the index. This provides "near real-time" searching, in that changes made during an <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a> session can be quickly made available for searching without closing the writer nor calling <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#ad1df12452bb45f153d9d06e1c160e2ff" title="Commits all pending changes (added &amp; deleted documents, optimizations, segment merges, added indexes, etc.) to the index, and syncs all referenced index files, such that a reader will see the changes and the index updates will survive an OS or machine crash or power loss. Note that this does not wait for any running background merges to finish. This may be a costly operation, so you should test the cost in your application and do it only when really necessary.">Commit()</a>. </p>
<p>Note that this is functionally equivalent to calling {#commit} and then using <a class="el" href="../../d6/d27/class_lucene_1_1_net_1_1_index_1_1_index_reader.html#ad51f1feca975e447b6486d01ed24e1ea" title="Returns an IndexReader reading the index in the given Directory. You should pass readOnly=true, since it gives much better concurrent performance, unless you intend to do write operations (delete documents or change norms) with the reader. ">IndexReader.Open(Lucene.Net.Store.Directory, bool)</a> to open a new reader. But the turarnound time of this method should be faster since it avoids the potentially costly <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#ad1df12452bb45f153d9d06e1c160e2ff" title="Commits all pending changes (added &amp; deleted documents, optimizations, segment merges, added indexes, etc.) to the index, and syncs all referenced index files, such that a reader will see the changes and the index updates will survive an OS or machine crash or power loss. Note that this does not wait for any running background merges to finish. This may be a costly operation, so you should test the cost in your application and do it only when really necessary.">Commit()</a>. </p>
<p>You must close the <a class="el" href="../../d6/d27/class_lucene_1_1_net_1_1_index_1_1_index_reader.html" title="IndexReader is an abstract class, providing an interface for accessing an index. Search of an index i...">IndexReader</a> returned by this method once you are done using it.</p>
<p>It's <em>near</em> real-time because there is no hard guarantee on how quickly you can get a new reader after making changes with <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a>. You'll have to experiment in your situation to determine if it's faster enough. As this is a new and experimental feature, please report back on your findings so we can learn, improve and iterate.</p>
<p>The resulting reader suppports <a class="el" href="../../d6/d27/class_lucene_1_1_net_1_1_index_1_1_index_reader.html#afdbae91b13509eca9832c2b4aa33591d" title="Refreshes an IndexReader if the index has changed since this instance was (re)opened. Opening an IndexReader is an expensive operation. This method can be used to refresh an existing IndexReader to reduce these costs. This method tries to only load segments that have changed or were created after the IndexReader was (re)opened. If the index has not changed since this instance was (re)opened, then this call is a NOOP and returns this instance. Otherwise, a new instance is returned. The old instance is not closed and remains usable.  If the reader is reopened, even though they share resources internally, it&#39;s safe to make changes (deletions, norms) with the new reader. All shared mutable state obeys &quot;copy on write&quot; semantics to ensure the changes are not seen by other readers. You can determine whether a reader was actually reopened by comparing the old instance with the instance returned by this method:">IndexReader.Reopen()</a> , but that call will simply forward back to this method (though this may change in the future).</p>
<p>The very first time this method is called, this writer instance will make every effort to pool the readers that it opens for doing merges, applying deletes, etc. This means additional resources (RAM, file descriptors, CPU time) will be consumed.</p>
<p>For lower latency on reopening a reader, you should call <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a316e18a963f39495c3fb6c73f16c905b" title="Gets or sets the merged segment warmer. See IndexReaderWarmer ">MergedSegmentWarmer</a> to call <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a316e18a963f39495c3fb6c73f16c905b" title="Gets or sets the merged segment warmer. See IndexReaderWarmer ">MergedSegmentWarmer</a> to pre-warm a newly merged segment before it's committed to the index. This is important for minimizing index-to-search delay after a large merge.</p>
<p>If an addIndexes* call is running in another thread, then this reader will only search those segments from the foreign index that have been successfully copied over, so far</p>
<p>.</p>
<p><b>NOTE</b>: Once the writer is closed, any outstanding readers may continue to be used. However, if you attempt to reopen any of those readers, you'll hit an <a class="el" href="../../d0/d90/_index_writer_8cs.html#a3bd6418bcbeb676f7dad24a00a2d6903">AlreadyClosedException</a>.</p>
<p><b>NOTE:</b> This API is experimental and might change in incompatible ways in the next release.</p>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd"><a class="el" href="../../d6/d27/class_lucene_1_1_net_1_1_index_1_1_index_reader.html" title="IndexReader is an abstract class, providing an interface for accessing an index. Search of an index i...">IndexReader</a> that covers entire index plus all changes made so far by this <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a> instance</p>
<p class="enddd"></p>
</dd></dl>
<p>&lt;throws&gt; IOException &lt;/throws&gt; </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l00351">351</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="ac60833a517b62ccfc10647c42b3e37b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../d6/d27/class_lucene_1_1_net_1_1_index_1_1_index_reader.html">IndexReader</a> Lucene.Net.Index.IndexWriter.GetReader </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>termInfosIndexDivisor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expert: like <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a57044cd06b7b2b00bb33a08ad666d4c5" title="Expert: returns a readonly reader, covering all committed as well as un-committed changes to the inde...">GetReader()</a>, except you can specify which termInfosIndexDivisor should be used for any newly opened readers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">termInfosIndexDivisor</td><td>Subsambles which indexed terms are loaded into RAM. This has the same effect as <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a08bd108b86cc51879645de74c878afa7" title="Expert: Gets or sets the interval between indexed terms. Large values cause less memory to be used by...">IndexWriter.TermIndexInterval</a> except that setting must be done at indexing time while this setting can be set per reader. When set to N, then one in every N*termIndexInterval terms in the index is loaded into memory. By setting this to a value &gt; 1 you can reduce memory usage, at the expense of higher latency when loading a <a class="el" href="../../df/d4d/class_lucene_1_1_net_1_1_index_1_1_term_info.html" title="A TermInfo is the record of information stored for a term.">TermInfo</a>. The default value is 1. Set this to -1 to skip loading the terms index entirely. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l00371">371</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a8ae9e478226238bff6eb549912b25149"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Lucene.Net.Index.IndexWriter.HasDeletions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l02228">2228</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a759669255f82e89072a9249cd131c1da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Lucene.Net.Index.IndexWriter.IsLocked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/df1/_syns2_index_8cs.html#aada057080323f6e867d8f9c189276716">Directory</a>&#160;</td>
          <td class="paramname"><em>directory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> iff the index in the named directory is currently locked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directory</td><td>the directory to check for a lock </td></tr>
  </table>
  </dd>
</dl>
<p>&lt;throws&gt; IOException if there is a low-level IO error &lt;/throws&gt; </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l05763">5763</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="ad550b4d48b97e3304fca067b9ba8bbf2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Lucene.Net.Index.IndexWriter.MaxDoc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns total number of docs in this index, including docs not yet flushed (still in the RAM buffer), not counting deletions. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#adfb6189992e060b9049c505a5d2ba71a" title="Returns total number of docs in this index, including docs not yet flushed (still in the RAM buffer)...">NumDocs</a></dd></dl>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l02185">2185</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a056e7a7776e7b57e85a7357d0f31d355"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lucene.Net.Index.IndexWriter.MaybeMerge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expert: asks the mergePolicy whether any merges are necessary now and if so, runs the requested merges and then iterate (test again if merges are needed) until no more merges are returned by the mergePolicy. </p>
<p>Explicit calls to maybeMerge() are usually not necessary. The most common case is when merge policy parameters have changed.</p>
<p><b>NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer. See <a href="../../#OOME">above</a> for details.</p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l02943">2943</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a7b566ac9c2e1fa55dd50758d2a2216ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lucene.Net.Index.IndexWriter.Merge_ForNUnit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/de7/class_lucene_1_1_net_1_1_index_1_1_merge_policy_1_1_one_merge.html">MergePolicy.OneMerge</a>&#160;</td>
          <td class="paramname"><em>merge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l04645">4645</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a1d3bfaa57bd4eaded7e16e2da30639a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Lucene.Net.Index.IndexWriter.Message </td>
          <td>(</td>
          <td class="paramtype">System.String&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints a message to the infoStream (if non-null), prefixed with the identifying information for this writer and the thread that's calling it. </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l00869">869</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="af60a31363679597a308914e11de0e6b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../d7/d6c/class_lucene_1_1_net_1_1_index_1_1_segment_info.html">SegmentInfo</a> Lucene.Net.Index.IndexWriter.NewestSegment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l05403">5403</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="aaeb4982d5f53568e301068a3eb9e8b86"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Lucene.Net.Index.IndexWriter.NumDeletedDocs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d6c/class_lucene_1_1_net_1_1_index_1_1_segment_info.html">SegmentInfo</a>&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the number of deleted docs for a pooled reader. If the reader isn't being pooled, the segmentInfo's delCount is returned. </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l00743">743</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="adfb6189992e060b9049c505a5d2ba71a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Lucene.Net.Index.IndexWriter.NumDocs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns total number of docs in this index, including docs not yet flushed (still in the RAM buffer), and including deletions. <b>NOTE:</b> buffered deletions are not counted. If you really need these to be counted you should call <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#ad1df12452bb45f153d9d06e1c160e2ff" title="Commits all pending changes (added &amp; deleted documents, optimizations, segment merges, added indexes, etc.) to the index, and syncs all referenced index files, such that a reader will see the changes and the index updates will survive an OS or machine crash or power loss. Note that this does not wait for any running background merges to finish. This may be a costly operation, so you should test the cost in your application and do it only when really necessary.">Commit()</a> first. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#adfb6189992e060b9049c505a5d2ba71a" title="Returns total number of docs in this index, including docs not yet flushed (still in the RAM buffer)...">NumDocs</a></dd></dl>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l02209">2209</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a7607d45f20ecd78ede37f9f2adca8569"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Lucene.Net.Index.IndexWriter.NumRamDocs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expert: Return the number of documents currently buffered in RAM. </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l04409">4409</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a19cfeeb684bdfee1802e51fcb9d49559"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Lucene.Net.Index.IndexWriter.Optimize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests an "optimize" operation on an index, priming the index for the fastest available search. Traditionally this has meant merging all segments into a single segment as is done in the default merge policy, but individaul merge policies may implement optimize in different ways. </p>
<p>It is recommended that this method be called upon completion of indexing. In environments with frequent updates, optimize is best done during low volume times, if at all.</p>
<p>See <a href="http://www.gossamer-threads.com/lists/lucene/java-dev/47895">http://www.gossamer-threads.com/lists/lucene/java-dev/47895</a> for more discussion. </p>
<p>Note that optimize requires 2X the index size free space in your Directory (3X if you're using compound file format). For example, if your index size is 10 MB then you need 20 MB free for optimize to complete (30 MB if you're using compound fiel format).</p>
<p>If some but not all readers re-open while an optimize is underway, this will cause &gt; 2X temporary space to be consumed as those new readers will then hold open the partially optimized segments at that time. It is best not to re-open readers while optimize is running.</p>
<p>The actual temporary usage could be much less than these figures (it depends on many factors).</p>
<p>In general, once the optimize completes, the total size of the index will be less than the size of the starting index. It could be quite a bit smaller (if there were many pending deletes) or just slightly smaller.</p>
<p>If an Exception is hit during optimize(), for example due to disk full, the index will not be corrupt and no documents will have been lost. However, it may have been partially optimized (some segments were merged but not all), and it's possible that one of the segments in the index will be in non-compound format even when using compound file format. This will occur when the Exception is hit during conversion of the segment into compound format.</p>
<p>This call will optimize those segments present in the index when the call started. If other threads are still adding documents and flushing segments, those newly created segments will not be optimized unless you call optimize again.</p>
<p><b>NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer. See <a href="../../#OOME">above</a> for details.</p>
<p>&lt;throws&gt; <a class="el" href="../../d6/d74/class_lucene_1_1_net_1_1_index_1_1_corrupt_index_exception.html" title="This exception is thrown when Lucene detects an inconsistency in the index. ">CorruptIndexException</a> if the index is corrupt &lt;/throws&gt; &lt;throws&gt; IOException if there is a low-level IO error &lt;/throws&gt; </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="../../db/d3e/class_lucene_1_1_net_1_1_index_1_1_log_merge_policy.html#a1bb27d9bc06ba140107d1db6006205d9" title="Returns the merges necessary to optimize the index. This merge policy defines &quot;optimized&quot; to mean onl...">Index.LogMergePolicy.FindMergesForOptimize</a></dd></dl>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l02671">2671</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a214dc271d1438e9072dda4cf33962ec7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Lucene.Net.Index.IndexWriter.Optimize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxNumSegments</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optimize the index down to &lt;= maxNumSegments. If maxNumSegments==1 then this is the same as <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a19cfeeb684bdfee1802e51fcb9d49559" title="Requests an &quot;optimize&quot; operation on an index, priming the index for the fastest available search...">Optimize()</a></p>
<p><b>NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer. See <a href="../../#OOME">above</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxNumSegments</td><td>maximum number of segments left in the index after optimization finishes </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l02688">2688</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a270bc05ce32b6021952d4fcd785a76c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Lucene.Net.Index.IndexWriter.Optimize </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doWait</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Just like <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a19cfeeb684bdfee1802e51fcb9d49559" title="Requests an &quot;optimize&quot; operation on an index, priming the index for the fastest available search...">Optimize()</a>, except you can specify whether the call should block until the optimize completes. This is only meaningful with a <a class="el" href="../../d9/d30/class_lucene_1_1_net_1_1_index_1_1_merge_scheduler.html" title="Expert: IndexWriter uses an instance implementing this interface to execute the merges selected by a ...">MergeScheduler</a> that is able to run merges in background threads. </p>
<p><b>NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer. See <a href="../../#OOME">above</a> for details.</p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l02703">2703</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="af115559461b738571538b7a6da2fc1ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Lucene.Net.Index.IndexWriter.Optimize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxNumSegments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Just like <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a214dc271d1438e9072dda4cf33962ec7" title="Optimize the index down to &lt;= maxNumSegments. If maxNumSegments==1 then this is the same as Optimize(...">Optimize(int)</a>, except you can specify whether the call should block until the optimize completes. This is only meaningful with a <a class="el" href="../../d9/d30/class_lucene_1_1_net_1_1_index_1_1_merge_scheduler.html" title="Expert: IndexWriter uses an instance implementing this interface to execute the merges selected by a ...">MergeScheduler</a> that is able to run merges in background threads. </p>
<p><b>NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer. See <a href="../../#OOME">above</a> for details.</p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l02718">2718</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a654d4db76a39dc6f888315b60c7f1455"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lucene.Net.Index.IndexWriter.PrepareCommit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expert: prepare for commit. </p>
<p><b>NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer. See <a href="../../#OOME">above</a> for details.</p>
<dl class="section see"><dt>See Also</dt><dd>PrepareCommit(IDictionary{string,string})</dd></dl>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l03985">3985</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="aab99319eb9efee0c6ca719a1bb6a0c5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Lucene.Net.Index.IndexWriter.RamSizeInBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expert: Return the total size of all index files currently cached in memory. Useful for size management with flushRamDocs() </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l04400">4400</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a6585064853f33355bf4b450ec88fd727"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Lucene.Net.Index.IndexWriter.Rollback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the <code><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a></code> without committing any changes that have occurred since the last commit (or since it was opened, if commit hasn't been called). This removes any temporary files that had been created, after which the state of the index will be the same as it was when commit() was last called or when this writer was first opened. This also clears a previous call to <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a654d4db76a39dc6f888315b60c7f1455" title="Expert: prepare for commit.">PrepareCommit()</a>. </p>
<p>&lt;throws&gt; IOException if there is a low-level IO error &lt;/throws&gt; </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l03230">3230</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a19dbab4393010c63c8a8e97080359dee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual System.String Lucene.Net.Index.IndexWriter.SegString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l05408">5408</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="adce005e0f128225cc6abb481099aa6d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Lucene.Net.Index.IndexWriter.SetInfoStream </td>
          <td>(</td>
          <td class="paramtype">System.IO.StreamWriter&#160;</td>
          <td class="paramname"><em>infoStream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If non-null, information about merges, deletes and a message when maxFieldLength is reached will be printed to this. </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l01719">1719</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a6ba86647b33915ad12d588238fbd996e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Lucene.Net.Index.IndexWriter.SetMaxBufferedDeleteTerms </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxBufferedDeleteTerms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the minimal number of delete terms required before the buffered in-memory delete terms are applied and flushed. If there are documents buffered in memory at the time, they are merged and a new segment is created.Disabled by default (writer flushes by RAM usage).</p>
<p>&lt;throws&gt; IllegalArgumentException if maxBufferedDeleteTerms &lt;/throws&gt; </p>
<p>is enabled but smaller than 1 </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#aee00b6cfce82c5e8e7eb088afbfcd465" title="Determines the amount of RAM that may be used for buffering added documents and deletions before they...">SetRAMBufferSizeMB</a></dd></dl>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l01657">1657</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a0af3f9039f7a75a70ee9e496ff4a6460"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Lucene.Net.Index.IndexWriter.SetMaxBufferedDocs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxBufferedDocs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the minimal number of documents required before the buffered in-memory documents are flushed as a new Segment. Large values generally gives faster indexing. </p>
<p>When this is set, the writer will flush every maxBufferedDocs added documents. Pass in <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#afb9f145da7f3ab3eb6bc74eef5de9c50" title="Value to denote a flush trigger is disabled">DISABLE_AUTO_FLUSH</a> to prevent triggering a flush due to number of buffered documents. Note that if flushing by RAM usage is also enabled, then the flush will be triggered by whichever comes first.</p>
<p>Disabled by default (writer flushes by RAM usage).</p>
<p>&lt;throws&gt; IllegalArgumentException if maxBufferedDocs is &lt;/throws&gt; </p>
<p>enabled but smaller than 2, or it disables maxBufferedDocs when ramBufferSize is already disabled </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#aee00b6cfce82c5e8e7eb088afbfcd465" title="Determines the amount of RAM that may be used for buffering added documents and deletions before they...">SetRAMBufferSizeMB</a></dd></dl>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l01534">1534</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a91be1a71d5a51f7232dc2b6f5e021d9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Lucene.Net.Index.IndexWriter.SetMaxFieldLength </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxFieldLength</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum number of terms that will be indexed for a single field in a document. This limits the amount of memory required for indexing, so that collections with very large files will not crash the indexing process by running out of memory. This setting refers to the number of running terms, not to the number of different terms.<b>Note:</b> this silently truncates large documents, excluding from the index all terms that occur further in the document. If you know your source documents are large, be sure to set this value high enough to accomodate the expected size. If you set it to Integer.MAX_VALUE, then the only limit is your memory, but you should anticipate an OutOfMemoryError.By default, no more than <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a7295b9b97b02ed5a179bbc3778f10e57" title="Default value is 10,000. Change using SetMaxFieldLength(int).">DEFAULT_MAX_FIELD_LENGTH</a> terms will be indexed for a field. </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l01465">1465</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a6f94df68d90885575f2cc7df66b8f1d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Lucene.Net.Index.IndexWriter.SetMergePolicy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/dce/class_lucene_1_1_net_1_1_index_1_1_merge_policy.html">MergePolicy</a>&#160;</td>
          <td class="paramname"><em>mp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expert: set the merge policy used by this writer.</p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l01359">1359</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="aba977b2dd3a5da8dd171515c166ded27"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Lucene.Net.Index.IndexWriter.SetMergeScheduler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d30/class_lucene_1_1_net_1_1_index_1_1_merge_scheduler.html">MergeScheduler</a>&#160;</td>
          <td class="paramname"><em>mergeScheduler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expert: set the merge scheduler used by this writer.</p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l01388">1388</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="aee00b6cfce82c5e8e7eb088afbfcd465"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Lucene.Net.Index.IndexWriter.SetRAMBufferSizeMB </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the amount of RAM that may be used for buffering added documents and deletions before they are flushed to the Directory. Generally for faster indexing performance it's best to flush by RAM usage instead of document count and use as large a RAM buffer as you can. </p>
<p>When this is set, the writer will flush whenever buffered documents and deletions use this much RAM. Pass in <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#afb9f145da7f3ab3eb6bc74eef5de9c50" title="Value to denote a flush trigger is disabled">DISABLE_AUTO_FLUSH</a> to prevent triggering a flush due to RAM usage. Note that if flushing by document count is also enabled, then the flush will be triggered by whichever comes first.</p>
<p><b>NOTE</b>: the account of RAM usage for pending deletions is only approximate. Specifically, if you delete by Query, <a class="el" href="../../df/d7a/namespace_lucene.html">Lucene</a> currently has no way to measure the RAM usage if individual Queries so the accounting will under-estimate and you should compensate by either calling commit() periodically yourself, or by using <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a6ba86647b33915ad12d588238fbd996e" title="Determines the minimal number of delete terms required before the buffered in-memory delete terms are...">SetMaxBufferedDeleteTerms</a> to flush by count instead of RAM usage (each buffered delete Query counts as one).</p>
<p><b>NOTE</b>: because <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a> uses <code>int</code>s when managing its internal storage, the absolute maximum value for this setting is somewhat less than 2048 MB. The precise limit depends on various factors, such as how large your documents are, how many fields have norms, etc., so it's best to set this value comfortably under 2048. </p>
<p>The default value is <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a7226e029bdd37e6cf049a5495d75bddf" title="Default value is 16 MB (which means flush when buffered docs consume 16 MB RAM). Change using SetRAMB...">DEFAULT_RAM_BUFFER_SIZE_MB</a>.</p>
<p>&lt;throws&gt; IllegalArgumentException if ramBufferSize is &lt;/throws&gt; </p>
<p>enabled but non-positive, or it disables ramBufferSize when maxBufferedDocs is already disabled </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l01623">1623</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a5695d47fe4b1e23ad339fd3e543e3a86"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Lucene.Net.Index.IndexWriter.SetSimilarity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d70/_documents_writer_8cs.html#a5431a3a4edd067eec50ca39b5ea99c31">Similarity</a>&#160;</td>
          <td class="paramname"><em>similarity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expert: Set the Similarity implementation used by this <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a>. </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l00930">930</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a15457a4f8494c68602a5bba5b1ad0d86"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Lucene.Net.Index.IndexWriter.TestPoint </td>
          <td>(</td>
          <td class="paramtype">System.String&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l05887">5887</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="acee14d6d2f1a94a7e67e0cdc58ff373d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Lucene.Net.Index.IndexWriter.Unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/df1/_syns2_index_8cs.html#aada057080323f6e867d8f9c189276716">Directory</a>&#160;</td>
          <td class="paramname"><em>directory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forcibly unlocks the index in the named directory. Caution: this should only be used by failure recovery code, when it is known that no other process nor thread is in fact currently accessing this index. </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l05774">5774</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a3667a5f5d4cffeb250ed20c2da19178b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Lucene.Net.Index.IndexWriter.UpdateDocument </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/daf/class_lucene_1_1_net_1_1_index_1_1_term.html">Term</a>&#160;</td>
          <td class="paramname"><em>term</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d53/_more_like_this_8cs.html#a2ad6aef8641c7b7a6cf9277f7d54b2cd">Document</a>&#160;</td>
          <td class="paramname"><em>doc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates a document by first deleting the document(s) containing <code>term</code> and then adding the new document. The delete and then add are atomic as seen by a reader on the same index (flush may happen only after the add). </p>
<p><b>NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer. See <a href="../../#OOME">above</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">term</td><td>the term to identify the document(s) to be deleted </td></tr>
    <tr><td class="paramname">doc</td><td>the document to be added </td></tr>
  </table>
  </dd>
</dl>
<p>&lt;throws&gt; <a class="el" href="../../d6/d74/class_lucene_1_1_net_1_1_index_1_1_corrupt_index_exception.html" title="This exception is thrown when Lucene detects an inconsistency in the index. ">CorruptIndexException</a> if the index is corrupt &lt;/throws&gt; &lt;throws&gt; IOException if there is a low-level IO error &lt;/throws&gt; </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l02476">2476</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a153cb58ae0d05e8c46a617dabb7db188"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Lucene.Net.Index.IndexWriter.UpdateDocument </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/daf/class_lucene_1_1_net_1_1_index_1_1_term.html">Term</a>&#160;</td>
          <td class="paramname"><em>term</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d53/_more_like_this_8cs.html#a2ad6aef8641c7b7a6cf9277f7d54b2cd">Document</a>&#160;</td>
          <td class="paramname"><em>doc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d53/_more_like_this_8cs.html#a7f807a855319cb4e1efa0e1fcd2a537f">Analyzer</a>&#160;</td>
          <td class="paramname"><em>analyzer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates a document by first deleting the document(s) containing <code>term</code> and then adding the new document. The delete and then add are atomic as seen by a reader on the same index (flush may happen only after the add). </p>
<p><b>NOTE</b>: if this method hits an OutOfMemoryError you should immediately close the writer. See <a href="../../#OOME">above</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">term</td><td>the term to identify the document(s) to be deleted </td></tr>
    <tr><td class="paramname">doc</td><td>the document to be added </td></tr>
    <tr><td class="paramname">analyzer</td><td>the analyzer to use when analyzing the document </td></tr>
  </table>
  </dd>
</dl>
<p>&lt;throws&gt; <a class="el" href="../../d6/d74/class_lucene_1_1_net_1_1_index_1_1_corrupt_index_exception.html" title="This exception is thrown when Lucene detects an inconsistency in the index. ">CorruptIndexException</a> if the index is corrupt &lt;/throws&gt; &lt;throws&gt; IOException if there is a low-level IO error &lt;/throws&gt; </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l02502">2502</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="aec6bf166ec1ec56a12311150b63670b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Lucene.Net.Index.IndexWriter.WaitForMerges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for any currently outstanding merges to finish. </p>
<p>It is guaranteed that any merges started prior to calling this method will have completed once this method completes.</p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l03447">3447</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a176a18e0e398195b6cb1d2526559063a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">readonly int Lucene.Net.Index.IndexWriter.DEFAULT_MAX_BUFFERED_DELETE_TERMS = <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#afb9f145da7f3ab3eb6bc74eef5de9c50">DISABLE_AUTO_FLUSH</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disabled by default (because <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a> flushes by RAM usage by default). Change using <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a6ba86647b33915ad12d588238fbd996e" title="Determines the minimal number of delete terms required before the buffered in-memory delete terms are...">SetMaxBufferedDeleteTerms(int)</a>. </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l00195">195</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="aa97bda7523a7160f1ee61a4fecb98dcf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">readonly int Lucene.Net.Index.IndexWriter.DEFAULT_MAX_BUFFERED_DOCS = <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#afb9f145da7f3ab3eb6bc74eef5de9c50">DISABLE_AUTO_FLUSH</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disabled by default (because <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a> flushes by RAM usage by default). Change using <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a0af3f9039f7a75a70ee9e496ff4a6460" title="Determines the minimal number of documents required before the buffered in-memory documents are flush...">SetMaxBufferedDocs(int)</a>. </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l00185">185</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a7295b9b97b02ed5a179bbc3778f10e57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int Lucene.Net.Index.IndexWriter.DEFAULT_MAX_FIELD_LENGTH = 10000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default value is 10,000. Change using <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a91be1a71d5a51f7232dc2b6f5e021d9e" title="The maximum number of terms that will be indexed for a single field in a document. This limits the amount of memory required for indexing, so that collections with very large files will not crash the indexing process by running out of memory. This setting refers to the number of running terms, not to the number of different terms.Note: this silently truncates large documents, excluding from the index all terms that occur further in the document. If you know your source documents are large, be sure to set this value high enough to accomodate the expected size. If you set it to Integer.MAX_VALUE, then the only limit is your memory, but you should anticipate an OutOfMemoryError.By default, no more than DEFAULT_MAX_FIELD_LENGTH terms will be indexed for a field. ">SetMaxFieldLength(int)</a>.</p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l00198">198</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a7226e029bdd37e6cf049a5495d75bddf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double Lucene.Net.Index.IndexWriter.DEFAULT_RAM_BUFFER_SIZE_MB = 16.0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default value is 16 MB (which means flush when buffered docs consume 16 MB RAM). Change using <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#aee00b6cfce82c5e8e7eb088afbfcd465" title="Determines the amount of RAM that may be used for buffering added documents and deletions before they...">SetRAMBufferSizeMB</a>. </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l00190">190</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a6e73c423d6fa320f8592b96d5833dac4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int Lucene.Net.Index.IndexWriter.DEFAULT_TERM_INDEX_INTERVAL = 128</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default value is 128. Change using <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a08bd108b86cc51879645de74c878afa7" title="Expert: Gets or sets the interval between indexed terms. Large values cause less memory to be used by...">TermIndexInterval</a>.</p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l00201">201</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="afb9f145da7f3ab3eb6bc74eef5de9c50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int Lucene.Net.Index.IndexWriter.DISABLE_AUTO_FLUSH = - 1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value to denote a flush trigger is disabled</p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l00180">180</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a5dab15a94436a74deaf7d1f609d2563f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">readonly int Lucene.Net.Index.IndexWriter.MAX_TERM_LENGTH</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Absolute hard maximum length for a term. If a term arrives from the analyzer longer than this length, it is skipped and a message is printed to infoStream, if set (see <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#adce005e0f128225cc6abb481099aa6d9" title="If non-null, information about merges, deletes and a message when maxFieldLength is reached will be p...">SetInfoStream</a>). </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l00208">208</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a315ae29ddea7027ec4b573acf7be850a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const System.String Lucene.Net.Index.IndexWriter.WRITE_LOCK_NAME = &quot;write.lock&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name of the write lock in the index.</p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l00177">177</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a860de8d252b7555bf02d5adeaa90a2d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long Lucene.Net.Index.IndexWriter.WRITE_LOCK_TIMEOUT = 1000</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default value for the write lock timeout (1,000).</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#ae25c05c7cbbf50fbf5a6dd18f9008245" title="Gets or sets the default (for any instance of IndexWriter) maximum time to wait for a write lock (in ...">DefaultWriteLockTimeout</a></dd></dl>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l00172">172</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a class="anchor" id="a5fb5084a704bb4b22096429e21262d61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../dd/d53/_more_like_this_8cs.html#a7f807a855319cb4e1efa0e1fcd2a537f">Analyzer</a> Lucene.Net.Index.IndexWriter.Analyzer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the analyzer used by this index. </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l02171">2171</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="ad0d4b0ded13c15df91f8a61bd8625590"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StreamWriter Lucene.Net.Index.IndexWriter.DefaultInfoStream</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets or sets the default info stream. If non-null, this will be the default infoStream used by a newly instantiated <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a>. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#adce005e0f128225cc6abb481099aa6d9" title="If non-null, information about merges, deletes and a message when maxFieldLength is reached will be p...">SetInfoStream</a></dd></dl>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l01710">1710</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="ae25c05c7cbbf50fbf5a6dd18f9008245"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long Lucene.Net.Index.IndexWriter.DefaultWriteLockTimeout</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets or sets the default (for any instance of <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a>) maximum time to wait for a write lock (in milliseconds). </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l01778">1778</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a3b1c7cb1f5060b72d2cd346870525c3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../dd/df1/_syns2_index_8cs.html#aada057080323f6e867d8f9c189276716">Directory</a> Lucene.Net.Index.IndexWriter.Directory</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Directory used by this index. </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l02160">2160</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a5e46eb19436b37c6d38284106816732d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual StreamWriter Lucene.Net.Index.IndexWriter.InfoStream</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current infoStream in use by this writer.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#adce005e0f128225cc6abb481099aa6d9" title="If non-null, information about merges, deletes and a message when maxFieldLength is reached will be p...">SetInfoStream</a></dd></dl>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l01745">1745</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a2d23a10865edb3459475dd48d4d90c16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Lucene.Net.Index.IndexWriter.MaxMergeDocs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets or sets the largest segment (measured by document count) that may be merged with other segments. Small values (e.g., less than 10,000) are best for interactive indexing, as this limits the length of pauses while indexing to a few seconds. Larger values are best for batched indexing and speedier searches. The default value is int.MaxValue. Note that this method is a convenience method: it just calls mergePolicy.getMaxMergeDocs as long as mergePolicy is an instance of <a class="el" href="../../db/d3e/class_lucene_1_1_net_1_1_index_1_1_log_merge_policy.html" title="This class implements a MergePolicy that tries to merge segments into levels of exponentially increas...">LogMergePolicy</a>. Otherwise an IllegalArgumentException is thrown.</p>
<p>The default merge policy (<a class="el" href="../../de/d2f/class_lucene_1_1_net_1_1_index_1_1_log_byte_size_merge_policy.html" title="This is a LogMergePolicy that measures size of a segment as the total byte size of the segment&#39;s file...">LogByteSizeMergePolicy</a>) also allows you to set this limit by net size (in MB) of the segment, using <a class="el" href="../../de/d2f/class_lucene_1_1_net_1_1_index_1_1_log_byte_size_merge_policy.html#a2523b0db76b78b6f3430d141b7d98fa0" title="Gets or sets the largest segment (measured by total byte size of the segment&#39;s files, in MB) that may be merged with other segments. Small values (e.g., less than 50 MB) are best for interactive indexing, as this limits the length of pauses while indexing to a few seconds. Larger values are best for batched indexing and speedier searches.">LogByteSizeMergePolicy.MaxMergeMB</a>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a2d23a10865edb3459475dd48d4d90c16" title="Gets or sets the largest segment (measured by document count) that may be merged with other segments...">MaxMergeDocs</a></dd></dl>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l01447">1447</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a316e18a963f39495c3fb6c73f16c905b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../de/ddd/class_lucene_1_1_net_1_1_index_1_1_index_writer_1_1_index_reader_warmer.html">IndexReaderWarmer</a> Lucene.Net.Index.IndexWriter.MergedSegmentWarmer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets or sets the merged segment warmer. See <a class="el" href="../../de/ddd/class_lucene_1_1_net_1_1_index_1_1_index_writer_1_1_index_reader_warmer.html" title="If GetReader() has been called (ie, this writer is in near real-time mode), then after a merge comple...">IndexReaderWarmer</a> </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l05860">5860</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a90e99233c275fbaf89ce4f71e0d22269"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Lucene.Net.Index.IndexWriter.MergeFactor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets or sets the number of segments that are merged at once and also controls the total number of segments allowed to accumulate in the index. Determines how often segment indices are merged by addDocument(). With smaller values, less RAM is used while indexing, and searches on unoptimized indices are faster, but indexing speed is slower. With larger values, more RAM is used during indexing, and while searches on unoptimized indices are slower, indexing is faster. Thus larger values (&gt; 10) are best for batch index creation, and smaller values (&lt; 10) for indices that are interactively maintained. </p>
<p>Note that this method is a convenience method: it just calls mergePolicy.setMergeFactor as long as mergePolicy is an instance of <a class="el" href="../../db/d3e/class_lucene_1_1_net_1_1_index_1_1_log_merge_policy.html" title="This class implements a MergePolicy that tries to merge segments into levels of exponentially increas...">LogMergePolicy</a>. Otherwise an IllegalArgumentException is thrown.</p>
<p>This must never be less than 2. The default value is 10. </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l01698">1698</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="ab6533cdba6fc8ca76c61c1c85bfc400d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../d2/dce/class_lucene_1_1_net_1_1_index_1_1_merge_policy.html">MergePolicy</a> Lucene.Net.Index.IndexWriter.MergePolicy</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expert: returns the current <a class="el" href="../../d2/dce/class_lucene_1_1_net_1_1_index_1_1_merge_policy.html" title="Expert: a MergePolicy determines the sequence of primitive merge operations to be used for overall me...">MergePolicy</a> in use by this writer.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a6f94df68d90885575f2cc7df66b8f1d6" title="Expert: set the merge policy used by this writer.">SetMergePolicy</a></dd></dl>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l01379">1379</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a52f8f717fb0f9b7cc6e549988eaff05c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../d9/d30/class_lucene_1_1_net_1_1_index_1_1_merge_scheduler.html">MergeScheduler</a> Lucene.Net.Index.IndexWriter.MergeScheduler</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expert: returns the current <a class="el" href="../../d2/dce/class_lucene_1_1_net_1_1_index_1_1_merge_policy.html" title="Expert: a MergePolicy determines the sequence of primitive merge operations to be used for overall me...">MergePolicy</a> in use by this writer. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a6f94df68d90885575f2cc7df66b8f1d6" title="Expert: set the merge policy used by this writer.">SetMergePolicy</a></dd></dl>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l01415">1415</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a4c11aedfb44fe470060747f46655ec50"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Lucene.Net.Index.IndexWriter.ReaderTermsIndexDivisor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets or sets the termsIndexDivisor passed to any readers that <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a> opens, for example when applying deletes or creating a near-real-time reader in <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a57044cd06b7b2b00bb33a08ad666d4c5" title="Expert: returns a readonly reader, covering all committed as well as un-committed changes to the inde...">GetReader()</a>. Default value is IndexReader.DEFAULT_TERMS_INDEX_DIVISOR. </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l01492">1492</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a2f133271bb3f57361cd4036b4d136233"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../d7/d70/_documents_writer_8cs.html#a5431a3a4edd067eec50ca39b5ea99c31">Similarity</a> Lucene.Net.Index.IndexWriter.Similarity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expert: Return the Similarity implementation used by this <a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. The create argument to the constructor determines whet...">IndexWriter</a>. </p>
<p>This defaults to the current value of <a class="el" href="../../df/dc2/class_lucene_1_1_net_1_1_search_1_1_similarity.html#a374d891e671bbaca17d776be505bc944" title="Gets or sets the default Similarity implementation used by indexing and search code. This is initially an instance of DefaultSimilarity. ">Search.Similarity.Default</a>. </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l00942">942</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a08bd108b86cc51879645de74c878afa7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Lucene.Net.Index.IndexWriter.TermIndexInterval</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expert: Gets or sets the interval between indexed terms. Large values cause less memory to be used by <a class="el" href="../../d6/d27/class_lucene_1_1_net_1_1_index_1_1_index_reader.html" title="IndexReader is an abstract class, providing an interface for accessing an index. Search of an index i...">IndexReader</a>, but slow random-access to terms. Small values cause more memory to be used by an <a class="el" href="../../d6/d27/class_lucene_1_1_net_1_1_index_1_1_index_reader.html" title="IndexReader is an abstract class, providing an interface for accessing an index. Search of an index i...">IndexReader</a>, and speed random-access to terms. </p>
<p>This parameter determines the amount of computation required per query term, regardless of the number of documents that contain that term. In particular, it is the maximum number of other terms that must be scanned before a term is located and its frequency and position information may be processed. In a large index with user-entered query terms, query processing time is likely to be dominated not by term lookup but rather by the processing of frequency and positional data. In a small index or when many uncommon query terms are generated (e.g., by wildcard queries) term lookup may become a dominant cost.</p>
<p>In particular, <code>numUniqueTerms/interval</code> terms are read into memory by an <a class="el" href="../../d6/d27/class_lucene_1_1_net_1_1_index_1_1_index_reader.html" title="IndexReader is an abstract class, providing an interface for accessing an index. Search of an index i...">IndexReader</a>, and, on average, <code>interval/2</code> terms must be scanned for each random term access.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="../../d2/d1d/class_lucene_1_1_net_1_1_index_1_1_index_writer.html#a6e73c423d6fa320f8592b96d5833dac4" title="Default value is 128. Change using TermIndexInterval.">DEFAULT_TERM_INDEX_INTERVAL</a></dd></dl>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l00974">974</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a36aac4bd54d03505193f5679f1298df6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Lucene.Net.Index.IndexWriter.UseCompoundFile</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets or sets the current setting of whether newly flushed segments will use the compound file format. Note that this just returns the value previously set with setUseCompoundFile(boolean), or the default value (true). You cannot use this to query the status of previously flushed segments.</p>
<p>Note that this method is a convenience method: it just calls mergePolicy.getUseCompoundFile as long as mergePolicy is an instance of <a class="el" href="../../db/d3e/class_lucene_1_1_net_1_1_index_1_1_log_merge_policy.html" title="This class implements a MergePolicy that tries to merge segments into levels of exponentially increas...">LogMergePolicy</a>. Otherwise an IllegalArgumentException is thrown.</p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l00919">919</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="ac169fab8e4b1bb5f6167521bc3a012ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Lucene.Net.Index.IndexWriter.Verbose</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if verbosing is enabled (i.e., infoStream != null). </p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l01755">1755</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a88765a6d0199ffe5b45d6fdedcaa0a92"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual long Lucene.Net.Index.IndexWriter.WriteLockTimeout</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets or sets allowed timeout when acquiring the write lock.</p>

<p>Definition at line <a class="el" href="../../d0/d90/_index_writer_8cs_source.html#l01761">1761</a> of file <a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>core/Index/<a class="el" href="../../d0/d90/_index_writer_8cs_source.html">IndexWriter.cs</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 3 2013 02:34:18 for Lucene.Net by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.3
</small></address>
</body>
</html>
