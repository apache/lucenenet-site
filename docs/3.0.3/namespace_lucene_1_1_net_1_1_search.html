<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>Lucene.Net: Package Lucene.Net.Search</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="lucene-net-icon-128x128.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Lucene.Net
   &#160;<span id="projectnumber">3.0.3</span>
   </div>
   <div id="projectbrief">Lucene.Net is a .NET port of the Java Lucene Indexing Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="Index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="namespacemembers.html"><span>Package&#160;Functions</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Properties</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_lucene.html">Lucene</a></li><li class="navelem"><a class="el" href="namespace_lucene_1_1_net.html">Net</a></li><li class="navelem"><a class="el" href="namespace_lucene_1_1_net_1_1_search.html">Search</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">Package Lucene.Net.Search</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_lucene_1_1_net_1_1_search_1_1_function"><td class="memItemLeft" align="right" valign="top">package &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lucene_1_1_net_1_1_search_1_1_function.html">Function</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_lucene_1_1_net_1_1_search_1_1_highlight"><td class="memItemLeft" align="right" valign="top">package &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lucene_1_1_net_1_1_search_1_1_highlight.html">Highlight</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_lucene_1_1_net_1_1_search_1_1_payloads"><td class="memItemLeft" align="right" valign="top">package &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lucene_1_1_net_1_1_search_1_1_payloads.html">Payloads</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_lucene_1_1_net_1_1_search_1_1_similar"><td class="memItemLeft" align="right" valign="top">package &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lucene_1_1_net_1_1_search_1_1_similar.html">Similar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_lucene_1_1_net_1_1_search_1_1_spans"><td class="memItemLeft" align="right" valign="top">package &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lucene_1_1_net_1_1_search_1_1_spans.html">Spans</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_lucene_1_1_net_1_1_search_1_1_vectorhighlight"><td class="memItemLeft" align="right" valign="top">package &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lucene_1_1_net_1_1_search_1_1_vectorhighlight.html">Vectorhighlight</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_boolean_filter.html">BooleanFilter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_boosting_query.html">BoostingQuery</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_boosting_query.html" title="The BoostingQuery class can be used to effectively demote results that match a given query...">BoostingQuery</a> class can be used to effectively demote results that match a given query. Unlike the "NOT" clause, this still selects documents that contain undesirable terms, but reduces their overall score:  <a href="class_lucene_1_1_net_1_1_search_1_1_boosting_query.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_duplicate_filter.html">DuplicateFilter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_filter_clause.html">FilterClause</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_fuzzy_like_this_query.html">FuzzyLikeThisQuery</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuzzifies ALL terms provided as strings and then picks the best n differentiating terms. In effect this mixes the behaviour of <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_fuzzy_query.html" title="Implements the fuzzy search query. The similarity measurement is based on the Levenshtein (edit dista...">FuzzyQuery</a> and MoreLikeThis but with special consideration of fuzzy scoring factors. This generally produces good results for queries where users may provide details in a number of fields and have no knowledge of boolean query syntax and also want a degree of fuzzy matching and a fast query.  <a href="class_lucene_1_1_net_1_1_search_1_1_fuzzy_like_this_query.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_terms_filter.html">TermsFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A filter that contains multiple terms.  <a href="class_lucene_1_1_net_1_1_search_1_1_terms_filter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Extensions</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_simple_faceted_search.html">SimpleFacetedSearch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_field_values_bit_sets.html">FieldValuesBitSets</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_boolean_clause.html">BooleanClause</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A clause in a <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_boolean_query.html" title="A Query that matches documents matching boolean combinations of other queries, e.g. TermQuerys, PhraseQuerys or other BooleanQuerys. ">BooleanQuery</a>.  <a href="class_lucene_1_1_net_1_1_search_1_1_boolean_clause.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>OccurExtensions</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_boolean_query.html">BooleanQuery</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_query.html" title="The abstract base class for queries. Instantiable subclasses are: TermQuery  MultiTermQuery  BooleanQ...">Query</a> that matches documents matching boolean combinations of other queries, e.g. <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_term_query.html" title="A Query that matches documents containing a term. This may be combined with other terms with a Boolea...">TermQuery</a>s, <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_phrase_query.html" title="A Query that matches documents containing a particular sequence of terms. A PhraseQuery is built by Q...">PhraseQuery</a>s or other BooleanQuerys.  <a href="class_lucene_1_1_net_1_1_search_1_1_boolean_query.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_boolean_scorer.html">BooleanScorer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_boolean_scorer2.html">BooleanScorer2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alternative to <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_boolean_scorer.html">BooleanScorer</a> that also allows a minimum number of optional scorers that should match. <br/>
Implements skipTo(), and has no limitations on the numbers of added scorers. <br/>
Uses <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_conjunction_scorer.html" title="Scorer for conjunctions, sets of queries, all of which are required. ">ConjunctionScorer</a>, DisjunctionScorer, ReqOptScorer and <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_req_excl_scorer.html" title="A Scorer for queries with a required subscorer and an excluding (prohibited) sub DocIdSetIterator.   This Scorer implements DocIdSetIterator.Advance(int), and it uses the skipTo() on the given scorers. ">ReqExclScorer</a>.  <a href="class_lucene_1_1_net_1_1_search_1_1_boolean_scorer2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_caching_span_filter.html">CachingSpanFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps another <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_span_filter.html" title="Abstract base class providing a mechanism to restrict searches to a subset of an index and also maint...">SpanFilter</a>'s result and caches it. The purpose is to allow filters to simply filter, and then wrap with this class to add caching.  <a href="class_lucene_1_1_net_1_1_search_1_1_caching_span_filter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_caching_wrapper_filter.html">CachingWrapperFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps another filter's result and caches it. The purpose is to allow filters to simply filter, and then wrap with this class to add caching.  <a href="class_lucene_1_1_net_1_1_search_1_1_caching_wrapper_filter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_collector.html">Collector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: Collectors are primarily meant to be used to gather raw results from a search, and implement sorting or custom result filtering, collation, etc.  <a href="class_lucene_1_1_net_1_1_search_1_1_collector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_complex_explanation.html">ComplexExplanation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: Describes the score computation for document and query, and can distinguish a match independent of a positive value.  <a href="class_lucene_1_1_net_1_1_search_1_1_complex_explanation.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_conjunction_scorer.html">ConjunctionScorer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_scorer.html" title="Expert: Common scoring functionality for different types of queries.">Scorer</a> for conjunctions, sets of queries, all of which are required.  <a href="class_lucene_1_1_net_1_1_search_1_1_conjunction_scorer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_constant_score_query.html">ConstantScoreQuery</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A query that wraps a filter and simply returns a constant score equal to the query boost for every document in the filter.  <a href="class_lucene_1_1_net_1_1_search_1_1_constant_score_query.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_default_similarity.html">DefaultSimilarity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: Default scoring implementation.  <a href="class_lucene_1_1_net_1_1_search_1_1_default_similarity.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_disjunction_max_query.html">DisjunctionMaxQuery</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A query that generates the union of documents produced by its subqueries, and that scores each document with the maximum score for that document as produced by any subquery, plus a tie breaking increment for any additional matching subqueries. This is useful when searching for a word in multiple fields with different boost factors (so that the fields cannot be combined equivalently into a single search field). We want the primary score to be the one associated with the highest boost, not the sum of the field scores (as <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_boolean_query.html" title="A Query that matches documents matching boolean combinations of other queries, e.g. TermQuerys, PhraseQuerys or other BooleanQuerys. ">BooleanQuery</a> would give). If the query is "albino elephant" this ensures that "albino" matching one field and "elephant" matching another gets a higher score than "albino" matching both fields. To get this result, use both <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_boolean_query.html" title="A Query that matches documents matching boolean combinations of other queries, e.g. TermQuerys, PhraseQuerys or other BooleanQuerys. ">BooleanQuery</a> and <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_disjunction_max_query.html" title="A query that generates the union of documents produced by its subqueries, and that scores each docume...">DisjunctionMaxQuery</a>: for each term a <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_disjunction_max_query.html" title="A query that generates the union of documents produced by its subqueries, and that scores each docume...">DisjunctionMaxQuery</a> searches for it in each field, while the set of these <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_disjunction_max_query.html" title="A query that generates the union of documents produced by its subqueries, and that scores each docume...">DisjunctionMaxQuery</a>'s is combined into a <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_boolean_query.html" title="A Query that matches documents matching boolean combinations of other queries, e.g. TermQuerys, PhraseQuerys or other BooleanQuerys. ">BooleanQuery</a>. The tie breaker capability allows results that include the same term in multiple fields to be judged better than results that include this term in only the best of those multiple fields, without confusing this with the better case of two different terms in the multiple fields.  <a href="class_lucene_1_1_net_1_1_search_1_1_disjunction_max_query.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_disjunction_max_scorer.html">DisjunctionMaxScorer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_scorer.html" title="Expert: Common scoring functionality for different types of queries.">Scorer</a> for <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_disjunction_max_query.html" title="A query that generates the union of documents produced by its subqueries, and that scores each docume...">DisjunctionMaxQuery</a>'s. The union of all documents generated by the the subquery scorers is generated in document number order. The score for each document is the maximum of the scores computed by the subquery scorers that generate that document, plus tieBreakerMultiplier times the sum of the scores for the other subqueries that generate the document.  <a href="class_lucene_1_1_net_1_1_search_1_1_disjunction_max_scorer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_disjunction_sum_scorer.html">DisjunctionSumScorer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_scorer.html" title="Expert: Common scoring functionality for different types of queries.">Scorer</a> for OR like queries, counterpart of <code><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_conjunction_scorer.html" title="Scorer for conjunctions, sets of queries, all of which are required. ">ConjunctionScorer</a></code>. This <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_scorer.html" title="Expert: Common scoring functionality for different types of queries.">Scorer</a> implements <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_doc_id_set_iterator.html#a4ea4804a0dd948a55077e1dde86b0983" title="Advances to the first beyond the current whose document number is greater than or equal to target...">DocIdSetIterator.Advance(int)</a> and uses skipTo() on the given Scorers.  <a href="class_lucene_1_1_net_1_1_search_1_1_disjunction_sum_scorer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_doc_id_set.html">DocIdSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_doc_id_set.html" title="A DocIdSet contains a set of doc ids. Implementing classes must only implement Iterator to provide ac...">DocIdSet</a> contains a set of doc ids. Implementing classes must only implement <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_doc_id_set.html#ada9f32eb3d60f5b8702420e19373356c" title="Provides a DocIdSetIterator to access the set. This implementation can return null or EMPTY_DOCIDSET...">Iterator</a> to provide access to the set.  <a href="class_lucene_1_1_net_1_1_search_1_1_doc_id_set.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_doc_id_set_iterator.html">DocIdSetIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This abstract class defines methods to iterate over a set of non-decreasing doc ids. Note that this class assumes it iterates on doc Ids, and therefore <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_doc_id_set_iterator.html#ac005b14762e519ad644745031fac2ad4" title="When returned by NextDoc(), Advance(int) and DocID() it means there are no more docs in the iterator...">NO_MORE_DOCS</a> is set to Int32.MaxValue in order to be used as a sentinel object. Implementations of this class are expected to consider int.MaxValue as an invalid value.  <a href="class_lucene_1_1_net_1_1_search_1_1_doc_id_set_iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_exact_phrase_scorer.html">ExactPhraseScorer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_explanation.html">Explanation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: Describes the score computation for document and query.  <a href="class_lucene_1_1_net_1_1_search_1_1_explanation.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_creation_placeholder.html">CreationPlaceholder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: Maintains caches of term values.  <a href="class_lucene_1_1_net_1_1_search_1_1_creation_placeholder.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_string_index.html">StringIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: Stores term text values and document ordering data.  <a href="class_lucene_1_1_net_1_1_search_1_1_string_index.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_cache_entry.html">CacheEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">EXPERT: A unique Identifier/Description for each item in the <a class="el" href="interface_lucene_1_1_net_1_1_search_1_1_field_cache.html">FieldCache</a>. Can be useful for logging/debugging. <b>EXPERIMENTAL API:</b> This API is considered extremely advanced and experimental. It may be removed or altered w/o warning in future releases of <a class="el" href="namespace_lucene.html">Lucene</a>.  <a href="class_lucene_1_1_net_1_1_search_1_1_cache_entry.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lucene_1_1_net_1_1_search_1_1_field_cache___fields.html">FieldCache_Fields</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_anonymous_class_byte_parser.html">AnonymousClassByteParser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_anonymous_class_short_parser.html">AnonymousClassShortParser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_anonymous_class_int_parser.html">AnonymousClassIntParser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_anonymous_class_float_parser.html">AnonymousClassFloatParser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_anonymous_class_long_parser.html">AnonymousClassLongParser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_anonymous_class_double_parser.html">AnonymousClassDoubleParser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_anonymous_class_int_parser1.html">AnonymousClassIntParser1</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_anonymous_class_float_parser1.html">AnonymousClassFloatParser1</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_anonymous_class_long_parser1.html">AnonymousClassLongParser1</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_anonymous_class_double_parser1.html">AnonymousClassDoubleParser1</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_lucene_1_1_net_1_1_search_1_1_field_cache.html">FieldCache</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_lucene_1_1_net_1_1_search_1_1_parser.html">Parser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marker interface as super-interface to all parsers. It is used to specify a custom parser to SortField(String, Parser).  <a href="interface_lucene_1_1_net_1_1_search_1_1_parser.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_lucene_1_1_net_1_1_search_1_1_byte_parser.html">ByteParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface to parse bytes from document fields. <a href="interface_lucene_1_1_net_1_1_search_1_1_byte_parser.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_lucene_1_1_net_1_1_search_1_1_short_parser.html">ShortParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface to parse shorts from document fields. <a href="interface_lucene_1_1_net_1_1_search_1_1_short_parser.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_lucene_1_1_net_1_1_search_1_1_int_parser.html">IntParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface to parse ints from document fields. <a href="interface_lucene_1_1_net_1_1_search_1_1_int_parser.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_lucene_1_1_net_1_1_search_1_1_float_parser.html">FloatParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface to parse floats from document fields. <a href="interface_lucene_1_1_net_1_1_search_1_1_float_parser.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_lucene_1_1_net_1_1_search_1_1_long_parser.html">LongParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface to parse long from document fields. <a href="interface_lucene_1_1_net_1_1_search_1_1_long_parser.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_lucene_1_1_net_1_1_search_1_1_double_parser.html">DoubleParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface to parse doubles from document fields. <a href="interface_lucene_1_1_net_1_1_search_1_1_double_parser.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_field_cache_impl.html">FieldCacheImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: The default cache implementation, storing all values in memory. A WeakDictionary is used for storage.  <a href="class_lucene_1_1_net_1_1_search_1_1_field_cache_impl.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>FieldCacheRangeFilter</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A range filter built on top of a cached single term field (in <a class="el" href="interface_lucene_1_1_net_1_1_search_1_1_field_cache.html">FieldCache</a>). <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_field_cache_range_filter_3_01_t_01_4.html">FieldCacheRangeFilter&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_field_cache_terms_filter.html">FieldCacheTermsFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_filter.html" title="Abstract base class for restricting which documents may be returned during searching.">Filter</a> that only accepts documents whose single term value in the specified field is contained in the provided set of allowed terms.  <a href="class_lucene_1_1_net_1_1_search_1_1_field_cache_terms_filter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_field_comparator.html">FieldComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: a <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_field_comparator.html" title="Expert: a FieldComparator compares hits so as to determine their sort order when collecting the top r...">FieldComparator</a> compares hits so as to determine their sort order when collecting the top results with <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_top_field_collector.html" title="A Collector that sorts by SortField using FieldComparators. See the Create method for instantiating a...">TopFieldCollector</a> . The concrete public <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_field_comparator.html" title="Expert: a FieldComparator compares hits so as to determine their sort order when collecting the top r...">FieldComparator</a> classes here correspond to the <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_sort_field.html" title="Stores information about how to sort documents by terms in an individual field. Fields must be indexe...">SortField</a> types.  <a href="class_lucene_1_1_net_1_1_search_1_1_field_comparator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_field_comparator_source.html">FieldComparatorSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_field_comparator.html" title="Expert: a FieldComparator compares hits so as to determine their sort order when collecting the top r...">FieldComparator</a> for custom field sorting.  <a href="class_lucene_1_1_net_1_1_search_1_1_field_comparator_source.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_field_doc.html">FieldDoc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: A <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_score_doc.html" title="Expert: Returned by low-level search implementations.">ScoreDoc</a> which also contains information about how to sort the referenced document. In addition to the document number and score, this object contains an array of values for the document from the field(s) used to sort. For example, if the sort criteria was to sort by fields "a", "b" then "c", the <code>fields</code> object array will have three elements, corresponding respectively to the term values for the document in fields "a", "b" and "c". The class of each element in the array will be either Integer, Float or String depending on the type of values in the terms of each field.  <a href="class_lucene_1_1_net_1_1_search_1_1_field_doc.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_field_doc_sorted_hit_queue.html">FieldDocSortedHitQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: Collects sorted results from <a class="el" href="interface_lucene_1_1_net_1_1_search_1_1_searchable.html" title="The interface for search implementations.">Searchable</a>'s and collates them. The elements put into this queue must be of type <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_field_doc.html" title="Expert: A ScoreDoc which also contains information about how to sort the referenced document...">FieldDoc</a>.  <a href="class_lucene_1_1_net_1_1_search_1_1_field_doc_sorted_hit_queue.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_field_value_hit_queue.html">FieldValueHitQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: A hit queue for sorting by hits by terms in more than one field. Uses <code>FieldCache.DEFAULT</code> for maintaining internal term lookup tables.  <a href="class_lucene_1_1_net_1_1_search_1_1_field_value_hit_queue.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_filter.html">Filter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for restricting which documents may be returned during searching. <a href="class_lucene_1_1_net_1_1_search_1_1_filter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_filtered_doc_id_set.html">FilteredDocIdSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract decorator class for a <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_doc_id_set.html" title="A DocIdSet contains a set of doc ids. Implementing classes must only implement Iterator to provide ac...">DocIdSet</a> implementation that provides on-demand filtering/validation mechanism on a given <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_doc_id_set.html" title="A DocIdSet contains a set of doc ids. Implementing classes must only implement Iterator to provide ac...">DocIdSet</a>.  <a href="class_lucene_1_1_net_1_1_search_1_1_filtered_doc_id_set.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_filtered_doc_id_set_iterator.html">FilteredDocIdSetIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract decorator class of a <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_doc_id_set_iterator.html" title="This abstract class defines methods to iterate over a set of non-decreasing doc ids. Note that this class assumes it iterates on doc Ids, and therefore NO_MORE_DOCS is set to Int32.MaxValue in order to be used as a sentinel object. Implementations of this class are expected to consider int.MaxValue as an invalid value. ">DocIdSetIterator</a> implementation that provides on-demand filter/validation mechanism on an underlying <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_doc_id_set_iterator.html" title="This abstract class defines methods to iterate over a set of non-decreasing doc ids. Note that this class assumes it iterates on doc Ids, and therefore NO_MORE_DOCS is set to Int32.MaxValue in order to be used as a sentinel object. Implementations of this class are expected to consider int.MaxValue as an invalid value. ">DocIdSetIterator</a>. See <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_filtered_doc_id_set.html" title="Abstract decorator class for a DocIdSet implementation that provides on-demand filtering/validation m...">FilteredDocIdSet</a>  <a href="class_lucene_1_1_net_1_1_search_1_1_filtered_doc_id_set_iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_filtered_query.html">FilteredQuery</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A query that applies a filter to the results of another query.  <a href="class_lucene_1_1_net_1_1_search_1_1_filtered_query.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_filtered_term_enum.html">FilteredTermEnum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for enumerating a subset of all terms. Term enumerations are always ordered by Term.compareTo(). Each term in the enumeration is greater than all that precede it.  <a href="class_lucene_1_1_net_1_1_search_1_1_filtered_term_enum.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_filter_manager.html">FilterManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_filter.html" title="Abstract base class for restricting which documents may be returned during searching.">Filter</a> caching singleton. It can be used to save filters locally for reuse. This class makes it possble to cache Filters even when using RMI, as it keeps the cache on the seaercher side of the RMI connection.  <a href="class_lucene_1_1_net_1_1_search_1_1_filter_manager.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_fuzzy_query.html">FuzzyQuery</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the fuzzy search query. The similarity measurement is based on the Levenshtein (edit distance) algorithm.  <a href="class_lucene_1_1_net_1_1_search_1_1_fuzzy_query.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_fuzzy_term_enum.html">FuzzyTermEnum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclass of <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_filtered_term_enum.html" title="Abstract class for enumerating a subset of all terms. Term enumerations are always ordered by Term...">FilteredTermEnum</a> for enumerating all terms that are similiar to the specified filter term.  <a href="class_lucene_1_1_net_1_1_search_1_1_fuzzy_term_enum.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_hit_queue.html">HitQueue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_index_searcher.html">IndexSearcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements search over a single IndexReader.  <a href="class_lucene_1_1_net_1_1_search_1_1_index_searcher.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_match_all_docs_query.html">MatchAllDocsQuery</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A query that matches all documents.  <a href="class_lucene_1_1_net_1_1_search_1_1_match_all_docs_query.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_multi_phrase_query.html">MultiPhraseQuery</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_multi_phrase_query.html" title="MultiPhraseQuery is a generalized version of PhraseQuery, with an added method Add(Term[]). To use this class, to search for the phrase &quot;Microsoft app*&quot; first use add(Term) on the term &quot;Microsoft&quot;, then find all terms that have &quot;app&quot; as prefix using IndexReader.terms(Term), and use MultiPhraseQuery.add(Term[] terms) to add them to the query.">MultiPhraseQuery</a> is a generalized version of <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_phrase_query.html" title="A Query that matches documents containing a particular sequence of terms. A PhraseQuery is built by Q...">PhraseQuery</a>, with an added method <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_multi_phrase_query.html#ae22d4b033985c8f73db6ab1a0c8af96e" title="Add multiple terms at the next position in the phrase. Any of the terms may match.">Add(Term[])</a>. To use this class, to search for the phrase "Microsoft app*" first use add(Term) on the term "Microsoft", then find all terms that have "app" as prefix using IndexReader.terms(Term), and use MultiPhraseQuery.add(Term[] terms) to add them to the query.  <a href="class_lucene_1_1_net_1_1_search_1_1_multi_phrase_query.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_multi_searcher.html">MultiSearcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements search over a set of <code>Searchables</code>.  <a href="class_lucene_1_1_net_1_1_search_1_1_multi_searcher.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_multi_term_query.html">MultiTermQuery</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_query.html" title="The abstract base class for queries. Instantiable subclasses are: TermQuery  MultiTermQuery  BooleanQ...">Query</a> that matches documents containing a subset of terms provided by a <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_filtered_term_enum.html" title="Abstract class for enumerating a subset of all terms. Term enumerations are always ordered by Term...">FilteredTermEnum</a> enumeration.  <a href="class_lucene_1_1_net_1_1_search_1_1_multi_term_query.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_rewrite_method.html">RewriteMethod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class that defines how the query is rewritten.  <a href="class_lucene_1_1_net_1_1_search_1_1_rewrite_method.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_multi_term_query_wrapper_filter_3_01_t_01_4.html">MultiTermQueryWrapperFilter&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_multi_term_query.html" title="An abstract Query that matches documents containing a subset of terms provided by a FilteredTermEnum ...">MultiTermQuery</a>, that exposes its functionality as a <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_filter.html" title="Abstract base class for restricting which documents may be returned during searching.">Filter</a>. <code>MultiTermQueryWrapperFilter</code> is not designed to be used by itself. Normally you subclass it to provide a <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_filter.html" title="Abstract base class for restricting which documents may be returned during searching.">Filter</a> counterpart for a <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_multi_term_query.html" title="An abstract Query that matches documents containing a subset of terms provided by a FilteredTermEnum ...">MultiTermQuery</a> subclass. For example, <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_term_range_filter.html" title="A Filter that restricts search results to a range of values in a given field.">TermRangeFilter</a> and <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_prefix_filter.html" title="A Filter that restricts search results to values that have a matching prefix in a given field...">PrefixFilter</a> extend <code>MultiTermQueryWrapperFilter</code>. This class also provides the functionality behind <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_multi_term_query.html#ae124731685dcbdac89e9c858a348efaf" title="A rewrite method that first creates a private Filter, by visiting each term in sequence and marking a...">MultiTermQuery.CONSTANT_SCORE_FILTER_REWRITE</a>; this is why it is not abstract.  <a href="class_lucene_1_1_net_1_1_search_1_1_multi_term_query_wrapper_filter_3_01_t_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_numeric_range_filter_3_01_t_01_4.html">NumericRangeFilter&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_filter.html" title="Abstract base class for restricting which documents may be returned during searching.">Filter</a> that only accepts numeric values within a specified range. To use this, you must first index the numeric values using <a class="el" href="_sort_field_8cs.html#a0548f0e7e5187d877d964eab1119b8dd">NumericField</a> (expert: <a class="el" href="_numeric_utils_8cs.html#ab25a5cea67a38594cfddfac92e18554e">NumericTokenStream</a> ).  <a href="class_lucene_1_1_net_1_1_search_1_1_numeric_range_filter_3_01_t_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>NumericRangeFilter</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_numeric_range_query_3_01_t_01_4.html">NumericRangeQuery&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_query.html" title="The abstract base class for queries. Instantiable subclasses are: TermQuery  MultiTermQuery  BooleanQ...">Query</a> that matches numeric values within a specified range. To use this, you must first index the numeric values using <a class="el" href="_sort_field_8cs.html#a0548f0e7e5187d877d964eab1119b8dd">NumericField</a> (expert: <a class="el" href="_numeric_utils_8cs.html#ab25a5cea67a38594cfddfac92e18554e">NumericTokenStream</a> ). If your terms are instead textual, you should use <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_term_range_query.html" title="A Query that matches documents within an exclusive range of terms.">TermRangeQuery</a>. NumericRangeFilter{T} is the filter equivalent of this query. <a href="class_lucene_1_1_net_1_1_search_1_1_numeric_range_query_3_01_t_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>NumericRangeQuery</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_parallel_multi_searcher.html">ParallelMultiSearcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements parallel search over a set of <code>Searchables</code>.  <a href="class_lucene_1_1_net_1_1_search_1_1_parallel_multi_searcher.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_phrase_positions.html">PhrasePositions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position of a term in a document that takes into account the term offset within the phrase.  <a href="class_lucene_1_1_net_1_1_search_1_1_phrase_positions.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_phrase_query.html">PhraseQuery</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_query.html" title="The abstract base class for queries. Instantiable subclasses are: TermQuery  MultiTermQuery  BooleanQ...">Query</a> that matches documents containing a particular sequence of terms. A <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_phrase_query.html" title="A Query that matches documents containing a particular sequence of terms. A PhraseQuery is built by Q...">PhraseQuery</a> is built by QueryParser for input like <code>"new york"</code>.  <a href="class_lucene_1_1_net_1_1_search_1_1_phrase_query.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_phrase_queue.html">PhraseQueue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_phrase_scorer.html">PhraseScorer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: Scoring functionality for phrase queries. <br/>
A document is considered matching if it contains the phrase-query terms at "valid" positons. What "valid positions" are depends on the type of the phrase query: for an exact phrase query terms are required to appear in adjacent locations, while for a sloppy phrase query some distance between the terms is allowed. The abstract method PhraseFreq() of extending classes is invoked for each document containing all the phrase query terms, in order to compute the frequency of the phrase query in that document. A non zero frequency means a match.  <a href="class_lucene_1_1_net_1_1_search_1_1_phrase_scorer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_positive_scores_only_collector.html">PositiveScoresOnlyCollector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_collector.html" title="Expert: Collectors are primarily meant to be used to gather raw results from a search, and implement sorting or custom result filtering, collation, etc. ">Collector</a> implementation which wraps another <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_collector.html" title="Expert: Collectors are primarily meant to be used to gather raw results from a search, and implement sorting or custom result filtering, collation, etc. ">Collector</a> and makes sure only documents with scores &gt; 0 are collected.  <a href="class_lucene_1_1_net_1_1_search_1_1_positive_scores_only_collector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_prefix_filter.html">PrefixFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_filter.html" title="Abstract base class for restricting which documents may be returned during searching.">Filter</a> that restricts search results to values that have a matching prefix in a given field.  <a href="class_lucene_1_1_net_1_1_search_1_1_prefix_filter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_prefix_query.html">PrefixQuery</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_query.html" title="The abstract base class for queries. Instantiable subclasses are: TermQuery  MultiTermQuery  BooleanQ...">Query</a> that matches documents containing terms with a specified prefix. A <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_prefix_query.html" title="A Query that matches documents containing terms with a specified prefix. A PrefixQuery is built by Qu...">PrefixQuery</a> is built by QueryParser for input like <code>app*</code>.  <a href="class_lucene_1_1_net_1_1_search_1_1_prefix_query.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_prefix_term_enum.html">PrefixTermEnum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclass of <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_filtered_term_enum.html" title="Abstract class for enumerating a subset of all terms. Term enumerations are always ordered by Term...">FilteredTermEnum</a> for enumerating all terms that match the specified prefix filter term. Term enumerations are always ordered by Term.compareTo(). Each term in the enumeration is greater than all that precede it.  <a href="class_lucene_1_1_net_1_1_search_1_1_prefix_term_enum.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_query.html">Query</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract base class for queries. Instantiable subclasses are: </p>
<ul>
<li>
<a class="el" href="class_lucene_1_1_net_1_1_search_1_1_term_query.html" title="A Query that matches documents containing a term. This may be combined with other terms with a Boolea...">TermQuery</a>  </li>
<li>
<a class="el" href="class_lucene_1_1_net_1_1_search_1_1_multi_term_query.html" title="An abstract Query that matches documents containing a subset of terms provided by a FilteredTermEnum ...">MultiTermQuery</a>  </li>
<li>
<a class="el" href="class_lucene_1_1_net_1_1_search_1_1_boolean_query.html" title="A Query that matches documents matching boolean combinations of other queries, e.g. TermQuerys, PhraseQuerys or other BooleanQuerys. ">BooleanQuery</a>  </li>
<li>
<a class="el" href="class_lucene_1_1_net_1_1_search_1_1_wildcard_query.html" title="Implements the wildcard search query. Supported wildcards are *, which matches any character sequence...">WildcardQuery</a>  </li>
<li>
<a class="el" href="class_lucene_1_1_net_1_1_search_1_1_phrase_query.html" title="A Query that matches documents containing a particular sequence of terms. A PhraseQuery is built by Q...">PhraseQuery</a>  </li>
<li>
<a class="el" href="class_lucene_1_1_net_1_1_search_1_1_prefix_query.html" title="A Query that matches documents containing terms with a specified prefix. A PrefixQuery is built by Qu...">PrefixQuery</a>  </li>
<li>
<a class="el" href="class_lucene_1_1_net_1_1_search_1_1_multi_phrase_query.html" title="MultiPhraseQuery is a generalized version of PhraseQuery, with an added method Add(Term[]). To use this class, to search for the phrase &quot;Microsoft app*&quot; first use add(Term) on the term &quot;Microsoft&quot;, then find all terms that have &quot;app&quot; as prefix using IndexReader.terms(Term), and use MultiPhraseQuery.add(Term[] terms) to add them to the query.">MultiPhraseQuery</a>  </li>
<li>
<a class="el" href="class_lucene_1_1_net_1_1_search_1_1_fuzzy_query.html" title="Implements the fuzzy search query. The similarity measurement is based on the Levenshtein (edit dista...">FuzzyQuery</a>  </li>
<li>
<a class="el" href="class_lucene_1_1_net_1_1_search_1_1_term_range_query.html" title="A Query that matches documents within an exclusive range of terms.">TermRangeQuery</a>  </li>
<li>
NumericRangeQuery{T}  </li>
<li>
<a class="el" href="class_lucene_1_1_net_1_1_search_1_1_spans_1_1_span_query.html" title="Base class for span-based queries. ">Lucene.Net.Search.Spans.SpanQuery</a>  </li>
</ul>
A parser for queries is contained in: </p>
<ul>
<li>
<a class="el" href="class_lucene_1_1_net_1_1_query_parsers_1_1_query_parser.html">QueryParser</a>  </li>
</ul>
 <a href="class_lucene_1_1_net_1_1_search_1_1_query.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_query_term_vector.html">QueryTermVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="class_lucene_1_1_net_1_1_search_1_1_query_term_vector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_query_wrapper_filter.html">QueryWrapperFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrains search results to only match those which also match a provided query.  <a href="class_lucene_1_1_net_1_1_search_1_1_query_wrapper_filter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_req_excl_scorer.html">ReqExclScorer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_scorer.html" title="Expert: Common scoring functionality for different types of queries.">Scorer</a> for queries with a required subscorer and an excluding (prohibited) sub <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_doc_id_set_iterator.html" title="This abstract class defines methods to iterate over a set of non-decreasing doc ids. Note that this class assumes it iterates on doc Ids, and therefore NO_MORE_DOCS is set to Int32.MaxValue in order to be used as a sentinel object. Implementations of this class are expected to consider int.MaxValue as an invalid value. ">DocIdSetIterator</a>. <br/>
 This <code><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_scorer.html" title="Expert: Common scoring functionality for different types of queries.">Scorer</a></code> implements <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_doc_id_set_iterator.html#a4ea4804a0dd948a55077e1dde86b0983" title="Advances to the first beyond the current whose document number is greater than or equal to target...">DocIdSetIterator.Advance(int)</a>, and it uses the skipTo() on the given scorers.  <a href="class_lucene_1_1_net_1_1_search_1_1_req_excl_scorer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_req_opt_sum_scorer.html">ReqOptSumScorer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_scorer.html" title="Expert: Common scoring functionality for different types of queries.">Scorer</a> for queries with a required part and an optional part. Delays skipTo() on the optional part until a score() is needed. <br/>
 This <code><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_scorer.html" title="Expert: Common scoring functionality for different types of queries.">Scorer</a></code> implements <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_doc_id_set_iterator.html#a4ea4804a0dd948a55077e1dde86b0983" title="Advances to the first beyond the current whose document number is greater than or equal to target...">DocIdSetIterator.Advance(int)</a>.  <a href="class_lucene_1_1_net_1_1_search_1_1_req_opt_sum_scorer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_score_caching_wrapping_scorer.html">ScoreCachingWrappingScorer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_scorer.html" title="Expert: Common scoring functionality for different types of queries.">Scorer</a> which wraps another scorer and caches the score of the current document. Successive calls to <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_score_caching_wrapping_scorer.html#a9e97a6adf12ee75252149d660f59c822" title="Returns the score of the current document matching the query. Initially invalid, until DocIdSetIterat...">Score()</a> will return the same result and will not invoke the wrapped <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_scorer.html" title="Expert: Common scoring functionality for different types of queries.">Scorer</a>'s score() method, unless the current document has changed.<br/>
 This class might be useful due to the changes done to the <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_collector.html" title="Expert: Collectors are primarily meant to be used to gather raw results from a search, and implement sorting or custom result filtering, collation, etc. ">Collector</a> interface, in which the score is not computed for a document by default, only if the collector requests it. Some collectors may need to use the score in several places, however all they have in hand is a <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_scorer.html" title="Expert: Common scoring functionality for different types of queries.">Scorer</a> object, and might end up computing the score of a document more than once.  <a href="class_lucene_1_1_net_1_1_search_1_1_score_caching_wrapping_scorer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_score_doc.html">ScoreDoc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: Returned by low-level search implementations. <a href="class_lucene_1_1_net_1_1_search_1_1_score_doc.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_scorer.html">Scorer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: Common scoring functionality for different types of queries.  <a href="class_lucene_1_1_net_1_1_search_1_1_scorer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_lucene_1_1_net_1_1_search_1_1_searchable.html">Searchable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The interface for search implementations.  <a href="interface_lucene_1_1_net_1_1_search_1_1_searchable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_searcher.html">Searcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract base class for search implementations. Implements the main search methods.  <a href="class_lucene_1_1_net_1_1_search_1_1_searcher.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_similarity.html">Similarity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: Scoring API. Subclasses implement search scoring.  <a href="class_lucene_1_1_net_1_1_search_1_1_similarity.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_similarity_delegator.html">SimilarityDelegator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: Delegating scoring implementation. Useful in <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_query.html#a61ccd3cc51e811a537f7929e98302fd3" title="Expert: Returns the Similarity implementation to be used for this query. Subclasses may override this...">Query.GetSimilarity(Searcher)</a> implementations, to override only certain methods of a <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_searcher.html" title="An abstract base class for search implementations. Implements the main search methods.">Searcher</a>'s Similiarty implementation..  <a href="class_lucene_1_1_net_1_1_search_1_1_similarity_delegator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_single_term_enum.html">SingleTermEnum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclass of <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_filtered_term_enum.html" title="Abstract class for enumerating a subset of all terms. Term enumerations are always ordered by Term...">FilteredTermEnum</a> for enumerating a single term. This can be used by <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_multi_term_query.html" title="An abstract Query that matches documents containing a subset of terms provided by a FilteredTermEnum ...">MultiTermQuery</a>s that need only visit one term, but want to preserve <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_multi_term_query.html" title="An abstract Query that matches documents containing a subset of terms provided by a FilteredTermEnum ...">MultiTermQuery</a> semantics such as <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_rewrite_method.html" title="Abstract class that defines how the query is rewritten. ">RewriteMethod</a>.  <a href="class_lucene_1_1_net_1_1_search_1_1_single_term_enum.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_sloppy_phrase_scorer.html">SloppyPhraseScorer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_sort.html">Sort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates sort criteria for returned hits.  <a href="class_lucene_1_1_net_1_1_search_1_1_sort.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_sort_field.html">SortField</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores information about how to sort documents by terms in an individual field. Fields must be indexed in order to sort by them.  <a href="class_lucene_1_1_net_1_1_search_1_1_sort_field.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_span_filter.html">SpanFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class providing a mechanism to restrict searches to a subset of an index and also maintains and returns position information. This is useful if you want to compare the positions from a SpanQuery with the positions of items in a filter. For instance, if you had a <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_span_filter.html" title="Abstract base class providing a mechanism to restrict searches to a subset of an index and also maint...">SpanFilter</a> that marked all the occurrences of the word "foo" in documents, and then you entered a new SpanQuery containing bar, you could not only filter by the word foo, but you could then compare position information for post processing.  <a href="class_lucene_1_1_net_1_1_search_1_1_span_filter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_span_filter_result.html">SpanFilterResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The results of a <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_span_query_filter.html" title="Constrains search results to only match those which also match a provided query. Also provides positi...">SpanQueryFilter</a>. Wraps the BitSet and the position information from the SpanQuery  <a href="class_lucene_1_1_net_1_1_search_1_1_span_filter_result.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_span_query_filter.html">SpanQueryFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrains search results to only match those which also match a provided query. Also provides position information about where each document matches at the cost of extra space compared with the <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_query_wrapper_filter.html" title="Constrains search results to only match those which also match a provided query.">QueryWrapperFilter</a>. There is an added cost to this above what is stored in a <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_query_wrapper_filter.html" title="Constrains search results to only match those which also match a provided query.">QueryWrapperFilter</a>. Namely, the position information for each matching document is stored. This filter does not cache. See the <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_caching_span_filter.html" title="Wraps another SpanFilter&#39;s result and caches it. The purpose is to allow filters to simply filter...">Lucene.Net.Search.CachingSpanFilter</a> for a wrapper that caches.  <a href="class_lucene_1_1_net_1_1_search_1_1_span_query_filter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_term_query.html">TermQuery</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_query.html" title="The abstract base class for queries. Instantiable subclasses are: TermQuery  MultiTermQuery  BooleanQ...">Query</a> that matches documents containing a term. This may be combined with other terms with a <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_boolean_query.html" title="A Query that matches documents matching boolean combinations of other queries, e.g. TermQuerys, PhraseQuerys or other BooleanQuerys. ">BooleanQuery</a>.  <a href="class_lucene_1_1_net_1_1_search_1_1_term_query.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_term_range_filter.html">TermRangeFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_filter.html" title="Abstract base class for restricting which documents may be returned during searching.">Filter</a> that restricts search results to a range of values in a given field.  <a href="class_lucene_1_1_net_1_1_search_1_1_term_range_filter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_term_range_query.html">TermRangeQuery</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_query.html" title="The abstract base class for queries. Instantiable subclasses are: TermQuery  MultiTermQuery  BooleanQ...">Query</a> that matches documents within an exclusive range of terms.  <a href="class_lucene_1_1_net_1_1_search_1_1_term_range_query.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_term_range_term_enum.html">TermRangeTermEnum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclass of <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_filtered_term_enum.html" title="Abstract class for enumerating a subset of all terms. Term enumerations are always ordered by Term...">FilteredTermEnum</a> for enumerating all terms that match the specified range parameters. Term enumerations are always ordered by Term.compareTo(). Each term in the enumeration is greater than all that precede it.  <a href="class_lucene_1_1_net_1_1_search_1_1_term_range_term_enum.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_term_scorer.html">TermScorer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: A <code><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_scorer.html" title="Expert: Common scoring functionality for different types of queries.">Scorer</a></code> for documents matching a <code>Term</code>. <a href="class_lucene_1_1_net_1_1_search_1_1_term_scorer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_time_limiting_collector.html">TimeLimitingCollector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_time_limiting_collector.html" title="The TimeLimitingCollector is used to timeout search requests that take longer than the maximum allowe...">TimeLimitingCollector</a> is used to timeout search requests that take longer than the maximum allowed search time limit. After this time is exceeded, the search thread is stopped by throwing a <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_time_limiting_collector_1_1_time_exceeded_exception.html" title="Thrown when elapsed search time exceeds allowed search time. ">TimeExceededException</a>.  <a href="class_lucene_1_1_net_1_1_search_1_1_time_limiting_collector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_top_docs.html">TopDocs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents hits returned by <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_searcher.html#aa266a774d95218869ce300bd74444151" title="Finds the top n hits for query, applying filter if non-null.">Searcher.Search(Query,Filter,int)</a> and <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_searcher.html#a15a44f147c6f8a9a9cf56e47dd560c05" title="Finds the top n hits for query.">Searcher.Search(Query,int)</a>  <a href="class_lucene_1_1_net_1_1_search_1_1_top_docs.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_top_docs_collector_3_01_t_01_4.html">TopDocsCollector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for all collectors that return a <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_top_docs.html" title="Represents hits returned by Searcher.Search(Query,Filter,int) and Searcher.Search(Query,int) ">Lucene.Net.Search.TopDocs</a> output. This collector allows easy extension by providing a single constructor which accepts a PriorityQueue{T} as well as protected members for that priority queue and a counter of the number of total hits.<br/>
 Extending classes can override <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_top_docs_collector_3_01_t_01_4.html#a5b01f25cd19aad8a9216677f68a92674" title="Returns the documents in the rage [start .. start+howMany) that were collected by this collector...">TopDocs(int, int)</a> and <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_top_docs_collector_3_01_t_01_4.html#aeff22c23faf95d863bff65fffb40a42e" title="The total number of documents that matched this query. ">TotalHits</a> in order to provide their own implementation.  <a href="class_lucene_1_1_net_1_1_search_1_1_top_docs_collector_3_01_t_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_top_field_collector.html">TopFieldCollector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_collector.html" title="Expert: Collectors are primarily meant to be used to gather raw results from a search, and implement sorting or custom result filtering, collation, etc. ">Collector</a> that sorts by <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_sort_field.html" title="Stores information about how to sort documents by terms in an individual field. Fields must be indexe...">SortField</a> using <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_field_comparator.html" title="Expert: a FieldComparator compares hits so as to determine their sort order when collecting the top r...">FieldComparator</a>s. See the <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_top_field_collector.html#acb40dd39119e08534429eb92f0e3ab5f" title="Creates a new TopFieldCollector from the given arguments.">Create</a> method for instantiating a <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_top_field_collector.html" title="A Collector that sorts by SortField using FieldComparators. See the Create method for instantiating a...">TopFieldCollector</a>.  <a href="class_lucene_1_1_net_1_1_search_1_1_top_field_collector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_top_field_docs.html">TopFieldDocs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents hits returned by <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_searcher.html#a4fa776037fe41a7fccc3c9d32057c258" title="Search implementation with arbitrary sorting. Finds the top n hits for query, applying filter if non-...">Searcher.Search(Query,Filter,int,Sort)</a>.  <a href="class_lucene_1_1_net_1_1_search_1_1_top_field_docs.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_top_score_doc_collector.html">TopScoreDocCollector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_collector.html" title="Expert: Collectors are primarily meant to be used to gather raw results from a search, and implement sorting or custom result filtering, collation, etc. ">Collector</a> implementation that collects the top-scoring hits, returning them as a <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_top_docs.html" title="Represents hits returned by Searcher.Search(Query,Filter,int) and Searcher.Search(Query,int) ">TopDocs</a>. This is used by <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_index_searcher.html" title="Implements search over a single IndexReader.">IndexSearcher</a> to implement <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_top_docs.html" title="Represents hits returned by Searcher.Search(Query,Filter,int) and Searcher.Search(Query,int) ">TopDocs</a>-based search. Hits are sorted by score descending and then (when the scores are tied) docID ascending. When you create an instance of this collector you should know in advance whether documents are going to be collected in doc Id order or not.  <a href="class_lucene_1_1_net_1_1_search_1_1_top_score_doc_collector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_weight.html">Weight</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: Calculate query weights and build query scorers. The purpose of <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_weight.html" title="Expert: Calculate query weights and build query scorers. The purpose of Weight is to ensure searching...">Weight</a> is to ensure searching does not modify a <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_query.html" title="The abstract base class for queries. Instantiable subclasses are: TermQuery  MultiTermQuery  BooleanQ...">Query</a>, so that a <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_query.html" title="The abstract base class for queries. Instantiable subclasses are: TermQuery  MultiTermQuery  BooleanQ...">Query</a> instance can be reused. <br/>
 <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_searcher.html" title="An abstract base class for search implementations. Implements the main search methods.">Searcher</a> dependent state of the query should reside in the <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_weight.html" title="Expert: Calculate query weights and build query scorers. The purpose of Weight is to ensure searching...">Weight</a>. <br/>
 <a class="el" href="_reader_util_8cs.html#a2a6914ea10bbe06764856e29e5674e66">IndexReader</a> dependent state should reside in the <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_scorer.html" title="Expert: Common scoring functionality for different types of queries.">Scorer</a>. A <code><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_weight.html" title="Expert: Calculate query weights and build query scorers. The purpose of Weight is to ensure searching...">Weight</a></code> is used in the following way: </p>
<ul>
<li>
A <code><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_weight.html" title="Expert: Calculate query weights and build query scorers. The purpose of Weight is to ensure searching...">Weight</a></code> is constructed by a top-level query, given a <code><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_searcher.html" title="An abstract base class for search implementations. Implements the main search methods.">Searcher</a></code> (<a class="el" href="class_lucene_1_1_net_1_1_search_1_1_query.html#adb579d26787d010ed599ab01a9b6adae" title="Expert: Constructs an appropriate Weight implementation for this query.">Lucene.Net.Search.Query.CreateWeight(Searcher)</a>). </li>
<li>
The <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_weight.html#a0a9aa5e55306164f0b5e6b8ee30b8a41" title="The sum of squared weights of contained query clauses. ">GetSumOfSquaredWeights()</a> method is called on the <code><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_weight.html" title="Expert: Calculate query weights and build query scorers. The purpose of Weight is to ensure searching...">Weight</a></code> to compute the query normalization factor <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_similarity.html#a941d4d16d71b59858e360de8c2d59371" title="Computes the normalization value for a query given the sum of the squared weights of each of the quer...">Similarity.QueryNorm(float)</a> of the query clauses contained in the query. </li>
<li>
The query normalization factor is passed to <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_weight.html#a33ec760fdf31354a43b50d7abd53a573" title="Assigns the query normalization factor to this. ">Normalize(float)</a>. At this point the weighting is complete. </li>
<li>
A <code><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_scorer.html" title="Expert: Common scoring functionality for different types of queries.">Scorer</a></code> is constructed by <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_weight.html#a87064513b858e1608bf7c66731f89a6b" title="Returns a Scorer which scores documents in/out-of order according to scoreDocsInOrder. NOTE: even if scoreDocsInOrder is false, it is recommended to check whether the returned Scorer indeed scores documents out of order (i.e., call GetScoresDocsOutOfOrder()), as some Scorer implementations will always return documents in-order.  NOTE: null can be returned if no documents will be scored by this query.">Scorer(IndexReader,bool,bool)</a>. </li>
</ul>
 <a href="class_lucene_1_1_net_1_1_search_1_1_weight.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_wildcard_query.html">WildcardQuery</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the wildcard search query. Supported wildcards are <code>*</code>, which matches any character sequence (including the empty one), and <code>?</code>, which matches any single character. Note this query can be slow, as it needs to iterate over many terms. In order to prevent extremely slow WildcardQueries, a Wildcard term should not start with one of the wildcards <code>*</code> or <code>?</code>.  <a href="class_lucene_1_1_net_1_1_search_1_1_wildcard_query.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_wildcard_term_enum.html">WildcardTermEnum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclass of <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_filtered_term_enum.html" title="Abstract class for enumerating a subset of all terms. Term enumerations are always ordered by Term...">FilteredTermEnum</a> for enumerating all terms that match the specified wildcard filter term. Term enumerations are always ordered by Term.compareTo(). Each term in the enumeration is greater than all that precede it.  <a href="class_lucene_1_1_net_1_1_search_1_1_wildcard_term_enum.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a99a7442e50a0ff52bf00ddb319eb9d34"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_lucene_1_1_net_1_1_search.html#a99a7442e50a0ff52bf00ddb319eb9d34">Occur</a> { <a class="el" href="namespace_lucene_1_1_net_1_1_search.html#a99a7442e50a0ff52bf00ddb319eb9d34a0c0ae552d2049b453963f23035ee7c6a">MUST</a>, 
<a class="el" href="namespace_lucene_1_1_net_1_1_search.html#a99a7442e50a0ff52bf00ddb319eb9d34abdc97aca8d1f2741c582792b24431122">SHOULD</a>, 
<a class="el" href="namespace_lucene_1_1_net_1_1_search.html#a99a7442e50a0ff52bf00ddb319eb9d34a1fb8c8386e3cd76753d54552dcb690e9">MUST_NOT</a>
 }</td></tr>
<tr class="separator:a99a7442e50a0ff52bf00ddb319eb9d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a99a7442e50a0ff52bf00ddb319eb9d34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_lucene_1_1_net_1_1_search.html#a99a7442e50a0ff52bf00ddb319eb9d34">Lucene.Net.Search.Occur</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a99a7442e50a0ff52bf00ddb319eb9d34a0c0ae552d2049b453963f23035ee7c6a"></a>MUST</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a99a7442e50a0ff52bf00ddb319eb9d34abdc97aca8d1f2741c582792b24431122"></a>SHOULD</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a99a7442e50a0ff52bf00ddb319eb9d34a1fb8c8386e3cd76753d54552dcb690e9"></a>MUST_NOT</em>&nbsp;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_boolean_clause_8cs_source.html#l00084">84</a> of file <a class="el" href="_boolean_clause_8cs_source.html">BooleanClause.cs</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 3 2013 02:12:56 for Lucene.Net by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3
</small></address>
</body>
</html>
