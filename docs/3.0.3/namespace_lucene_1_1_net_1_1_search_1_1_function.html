<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>Lucene.Net: Package Lucene.Net.Search.Function</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="lucene-net-icon-128x128.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Lucene.Net
   &#160;<span id="projectnumber">3.0.3</span>
   </div>
   <div id="projectbrief">Lucene.Net is a .NET port of the Java Lucene Indexing Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="Index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="namespacemembers.html"><span>Package&#160;Functions</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Properties</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_lucene.html">Lucene</a></li><li class="navelem"><a class="el" href="namespace_lucene_1_1_net.html">Net</a></li><li class="navelem"><a class="el" href="namespace_lucene_1_1_net_1_1_search.html">Search</a></li><li class="navelem"><a class="el" href="namespace_lucene_1_1_net_1_1_search_1_1_function.html">Function</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">Package Lucene.Net.Search.Function</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_byte_field_source.html">ByteFieldSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: obtains single byte field values from the <a class="el" href="interface_lucene_1_1_net_1_1_search_1_1_field_cache.html">FieldCache</a> using <code>getBytes()</code> and makes those values available as other numeric types, casting as needed.  <a href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_byte_field_source.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_custom_score_provider.html">CustomScoreProvider</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An instance of this subclass should be returned by <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_custom_score_query.html#aab7ecc65053fd215dd983cc6dbac19a5" title="Returns a CustomScoreProvider that calculates the custom scores for the given IndexReader. The default implementation returns a default implementation as specified in the docs of CustomScoreProvider. ">CustomScoreQuery.GetCustomScoreProvider</a>, if you want to modify the custom score calculation of a <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_custom_score_query.html" title="Query that sets document score as a programmatic function of several (sub) scores: the score of its s...">CustomScoreQuery</a>.  <a href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_custom_score_provider.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_custom_score_query.html">CustomScoreQuery</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_query.html" title="The abstract base class for queries. Instantiable subclasses are: TermQuery  MultiTermQuery  BooleanQ...">Query</a> that sets document score as a programmatic function of several (sub) scores: </p>
<ul>
<li>
the score of its subQuery (any query) </li>
<li>
(optional) the score of its <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_value_source_query.html" title="Expert: A Query that sets the scores of document to the values obtained from a ValueSource. This query provides a score for each and every undeleted document in the index. The value source can be based on a (cached) value of an indexed field, but it can also be based on an external source, e.g. values read from an external database. Score is set as: Score(doc,query) = query.getBoost()2 * valueSource(doc).">ValueSourceQuery</a> (or queries). For most simple/convenient use cases this query is likely to be a <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_field_score_query.html">FieldScoreQuery</a> </li>
</ul>
<p>Subclasses can modify the computation by overriding <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_custom_score_query.html#aab7ecc65053fd215dd983cc6dbac19a5" title="Returns a CustomScoreProvider that calculates the custom scores for the given IndexReader. The default implementation returns a default implementation as specified in the docs of CustomScoreProvider. ">GetCustomScoreProvider</a>.  <a href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_custom_score_query.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_doc_values.html">DocValues</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: represents field values as different types. Normally created via a <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_value_source.html">ValueSuorce</a> for a particular field and reader.  <a href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_doc_values.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_field_cache_source.html">FieldCacheSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: A base class for <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_value_source.html" title="Expert: source of values for basic function queries. At its default/simplest form, values - one per doc - are used as the score of that doc. Values are instantiated as DocValues for a particular reader. ValueSource implementations differ in RAM requirements: it would always be a factor of the number of documents, but for each document the number of bytes can be 1, 2, 4, or 8.">ValueSource</a> implementations that retrieve values for a single field from the <a class="el" href="interface_lucene_1_1_net_1_1_search_1_1_field_cache.html">FieldCache</a>. Fields used herein nust be indexed (doesn't matter if these fields are stored or not). It is assumed that each such indexed field is untokenized, or at least has a single token in a document. For documents with multiple tokens of the same field, behavior is undefined (It is likely that current code would use the value of one of these tokens, but this is not guaranteed). Document with no tokens in this field are assigned the <code>Zero</code> value.  <a href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_field_cache_source.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_field_score_query.html">FieldScoreQuery</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A query that scores each document as the value of the numeric input field. The query matches all documents, and scores each document according to the numeric value of that field. It is assumed, and expected, that: </p>
<ul>
<li>
The field used here is indexed, and has exactly one token in every scored document. </li>
<li>
Best if this field is un_tokenized. </li>
<li>
That token is parsable to the selected type. </li>
</ul>
Combining this query in a FunctionQuery allows much freedom in affecting document scores. Note, that with this freedom comes responsibility: it is more than likely that the default <a class="el" href="namespace_lucene.html">Lucene</a> scoring is superior in quality to scoring modified as explained here. However, in some cases, and certainly for research experiments, this capability may turn useful. When contructing this query, select the appropriate type. That type should match the data stored in the field. So in fact the "right" type should be selected before indexing. <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_field_score_query_1_1_type.html" title="Type of score field, indicating how field values are interpreted/parsed. The type selected at search ...">Type</a> selection has effect on the RAM usage: </p>
<ul>
<li>
<a class="el" href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_field_score_query_1_1_type.html#a19d455a56dcb987761f48be5a2c70734" title="field values are interpreted as numeric byte values. ">Type.BYTE</a> consumes 1 * maxDocs bytes. </li>
<li>
<a class="el" href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_field_score_query_1_1_type.html#a0660831879e37f62039b8f6d818cbb55" title="field values are interpreted as numeric short values. ">Type.SHORT</a> consumes 2 * maxDocs bytes. </li>
<li>
<a class="el" href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_field_score_query_1_1_type.html#a0bed4cfe167cec1b6fb0bd2c4f4dfb1e" title="field values are interpreted as numeric int values. ">Type.INT</a> consumes 4 * maxDocs bytes. </li>
<li>
<a class="el" href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_field_score_query_1_1_type.html#a63d1ff19cf53472209bc4b1ad3745846" title="field values are interpreted as numeric float values. ">Type.FLOAT</a> consumes 8 * maxDocs bytes. </li>
</ul>
<b>Caching:</b> Values for the numeric field are loaded once and cached in memory for further use with the same IndexReader. To take advantage of this, it is extremely important to reuse index-readers or index-searchers, otherwise, for instance if for each query a new index reader is opened, large penalties would be paid for loading the field values into memory over and over again!  <a href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_field_score_query.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_float_field_source.html">FloatFieldSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: obtains float field values from the <a class="el" href="interface_lucene_1_1_net_1_1_search_1_1_field_cache.html">FieldCache</a> using <code>getFloats()</code> and makes those values available as other numeric types, casting as needed.  <a href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_float_field_source.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_int_field_source.html">IntFieldSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: obtains int field values from the <a class="el" href="interface_lucene_1_1_net_1_1_search_1_1_field_cache.html">FieldCache</a> using <code>getInts()</code> and makes those values available as other numeric types, casting as needed.  <a href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_int_field_source.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_ord_field_source.html">OrdFieldSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: obtains the ordinal of the field value from the default <a class="el" href="namespace_lucene.html">Lucene</a> <a class="el" href="interface_lucene_1_1_net_1_1_search_1_1_field_cache.html">Fieldcache</a> using getStringIndex(). The native lucene index order is used to assign an ordinal value for each field value. Field values (terms) are lexicographically ordered by unicode value, and numbered starting at 1. Example: <br/>
If there were only three field values: "apple","banana","pear" <br/>
then ord("apple")=1, ord("banana")=2, ord("pear")=3 WARNING: ord() depends on the position in an index and can thus change when other documents are inserted or deleted, or if a <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_multi_searcher.html" title="Implements search over a set of Searchables.">MultiSearcher</a> is used.  <a href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_ord_field_source.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_reverse_ord_field_source.html">ReverseOrdFieldSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: obtains the ordinal of the field value from the default <a class="el" href="namespace_lucene.html">Lucene</a> <a class="el" href="interface_lucene_1_1_net_1_1_search_1_1_field_cache.html">FieldCache</a> using getStringIndex() and reverses the order. The native lucene index order is used to assign an ordinal value for each field value. Field values (terms) are lexicographically ordered by unicode value, and numbered starting at 1. <br/>
 Example of reverse ordinal (rord): <br/>
If there were only three field values: "apple","banana","pear" <br/>
then rord("apple")=3, rord("banana")=2, ord("pear")=1 WARNING: rord() depends on the position in an index and can thus change when other documents are inserted or deleted, or if a <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_multi_searcher.html" title="Implements search over a set of Searchables.">MultiSearcher</a> is used.  <a href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_reverse_ord_field_source.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_short_field_source.html">ShortFieldSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: obtains short field values from the <a class="el" href="interface_lucene_1_1_net_1_1_search_1_1_field_cache.html">FieldCache</a> using <code>getShorts()</code> and makes those values available as other numeric types, casting as needed.  <a href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_short_field_source.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_value_source.html">ValueSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: source of values for basic function queries. At its default/simplest form, values - one per doc - are used as the score of that doc. Values are instantiated as <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_doc_values.html">DocValues</a> for a particular reader. <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_value_source.html" title="Expert: source of values for basic function queries. At its default/simplest form, values - one per doc - are used as the score of that doc. Values are instantiated as DocValues for a particular reader. ValueSource implementations differ in RAM requirements: it would always be a factor of the number of documents, but for each document the number of bytes can be 1, 2, 4, or 8.">ValueSource</a> implementations differ in RAM requirements: it would always be a factor of the number of documents, but for each document the number of bytes can be 1, 2, 4, or 8.  <a href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_value_source.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_value_source_query.html">ValueSourceQuery</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: A <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_query.html" title="The abstract base class for queries. Instantiable subclasses are: TermQuery  MultiTermQuery  BooleanQ...">Query</a> that sets the scores of document to the values obtained from a <a class="el" href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_value_source.html">ValueSource</a>. This query provides a score for <em>each and every</em> undeleted document in the index. The value source can be based on a (cached) value of an indexed field, but it can also be based on an external source, e.g. values read from an external database. Score is set as: Score(doc,query) = query.getBoost()<sup>2</sup> * valueSource(doc).  <a href="class_lucene_1_1_net_1_1_search_1_1_function_1_1_value_source_query.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 3 2013 02:12:57 for Lucene.Net by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3
</small></address>
</body>
</html>
