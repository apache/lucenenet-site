<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Namespace Lucene.Net.Util.Packed
   | Apache Lucene.NET 4.8.0 Documentation </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Namespace Lucene.Net.Util.Packed
   | Apache Lucene.NET 4.8.0 Documentation ">
    <meta name="generator" content="docfx 2.47.0.0">
    
    <link rel="shortcut icon" href="../../logo/favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    <meta property="docfx:rel" content="../../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../logo/lucene-net-color.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="Lucene.Net.Util.Packed">
  
  <h1 id="Lucene_Net_Util_Packed" data-uid="Lucene.Net.Util.Packed" class="text-break">Namespace Lucene.Net.Util.Packed
  </h1>
  <div class="markdown level0 summary"></div>
  <div class="markdown level0 conceptual"></div>
  <div class="markdown level0 remarks"></div>
    <h3 id="classes">Classes
  </h3>
      <h4><a class="xref" href="Lucene.Net.Util.Packed.AbstractAppendingInt64Buffer.html">AbstractAppendingInt64Buffer</a></h4>
      <section><p>Common functionality shared by <a class="xref" href="Lucene.Net.Util.Packed.AppendingDeltaPackedInt64Buffer.html">AppendingDeltaPackedInt64Buffer</a> and <a class="xref" href="Lucene.Net.Util.Packed.MonotonicAppendingInt64Buffer.html">MonotonicAppendingInt64Buffer</a>. 
<p>
NOTE: This was AbstractAppendingLongBuffer in Lucene</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.Packed.AbstractAppendingInt64Buffer.Iterator.html">AbstractAppendingInt64Buffer.Iterator</a></h4>
      <section></section>
      <h4><a class="xref" href="Lucene.Net.Util.Packed.AbstractBlockPackedWriter.html">AbstractBlockPackedWriter</a></h4>
      <section></section>
      <h4><a class="xref" href="Lucene.Net.Util.Packed.AbstractPagedMutable-1.html">AbstractPagedMutable&lt;T&gt;</a></h4>
      <section><p>Base implementation for <a class="xref" href="Lucene.Net.Util.Packed.PagedMutable.html">PagedMutable</a> and <a class="xref" href="Lucene.Net.Util.Packed.PagedGrowableWriter.html">PagedGrowableWriter</a>.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.Packed.AppendingDeltaPackedInt64Buffer.html">AppendingDeltaPackedInt64Buffer</a></h4>
      <section><p>Utility class to buffer a list of signed longs in memory. This class only
supports appending and is optimized for the case where values are close to
each other.
<p>
NOTE: This was AppendingDeltaPackedLongBuffer in Lucene
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.Packed.AppendingPackedInt64Buffer.html">AppendingPackedInt64Buffer</a></h4>
      <section><p>Utility class to buffer a list of signed longs in memory. This class only
supports appending and is optimized for non-negative numbers with a uniform distribution over a fixed (limited) range.
<p>
NOTE: This was AppendingPackedLongBuffer in Lucene
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.Packed.BlockPackedReader.html">BlockPackedReader</a></h4>
      <section><p>Provides random access to a stream written with <a class="xref" href="Lucene.Net.Util.Packed.BlockPackedWriter.html">BlockPackedWriter</a>.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.Packed.BlockPackedReaderIterator.html">BlockPackedReaderIterator</a></h4>
      <section><p>Reader for sequences of <span class="xref">System.Int64</span>s written with <a class="xref" href="Lucene.Net.Util.Packed.BlockPackedWriter.html">BlockPackedWriter</a>. 
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.Packed.BlockPackedWriter.html">BlockPackedWriter</a></h4>
      <section><p>A writer for large sequences of longs.
<p>
The sequence is divided into fixed-size blocks and for each block, the
difference between each value and the minimum value of the block is encoded
using as few bits as possible. Memory usage of this class is proportional to
the block size. Each block has an overhead between 1 and 10 bytes to store
the minimum value and the number of bits per value of the block.
<p>
Format:
<ul><li>&lt;BLock&gt;<sup>BlockCount</sup></li><li>BlockCount: ⌈ ValueCount / BlockSize ⌉</li><li>Block: &lt;Header, (Ints)&gt;</li><li>Header: &lt;Token, (MinValue)&gt;</li><li>Token: a byte (<a class="xref" href="Lucene.Net.Store.DataOutput.html#Lucene_Net_Store_DataOutput_WriteByte_System_Byte_">WriteByte(Byte)</a>), first 7 bits are the
    number of bits per value (<code>bitsPerValue</code>). If the 8th bit is 1,
    then MinValue (see next) is <code>0</code>, otherwise MinValue and needs to
    be decoded</li><li>MinValue: a
<a href="https://developers.google.com/protocol-buffers/docs/encoding#types">zigzag-encoded</a>
 variable-length <span class="xref">System.Int64</span> (<a class="xref" href="Lucene.Net.Store.DataOutput.html#Lucene_Net_Store_DataOutput_WriteVInt64_System_Int64_">WriteVInt64(Int64)</a>) whose value
should be added to every int from the block to restore the original
values</li><li>Ints: If the number of bits per value is <code>0</code>, then there is
nothing to decode and all ints are equal to MinValue. Otherwise: BlockSize
packed ints (<a class="xref" href="Lucene.Net.Util.Packed.PackedInt32s.html">PackedInt32s</a>) encoded on exactly <code>bitsPerValue</code>
bits per value. They are the subtraction of the original values and
MinValue</li></ul>
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.Packed.EliasFanoDecoder.html">EliasFanoDecoder</a></h4>
      <section><p>A decoder for an <a class="xref" href="Lucene.Net.Util.Packed.EliasFanoEncoder.html">EliasFanoEncoder</a>.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.Packed.EliasFanoDocIdSet.html">EliasFanoDocIdSet</a></h4>
      <section><p>A DocIdSet in Elias-Fano encoding.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.Packed.EliasFanoEncoder.html">EliasFanoEncoder</a></h4>
      <section><p>Encode a non decreasing sequence of non negative whole numbers in the Elias-Fano encoding
that was introduced in the 1970&apos;s by Peter Elias and Robert Fano.
<p>
The Elias-Fano encoding is a high bits / low bits representation of
a monotonically increasing sequence of <code>numValues &gt; 0</code> natural numbers <code>x[i]</code>
<p>
<code>0 &lt;= x[0] &lt;= x[1] &lt;= ... &lt;= x[numValues-2] &lt;= x[numValues-1] &lt;= upperBound</code>
<p>
where <code>upperBound &gt; 0</code> is an upper bound on the last value.
<p>
The Elias-Fano encoding uses less than half a bit per encoded number more
than the smallest representation
that can encode any monotone sequence with the same bounds.
<p>
The lower <code>L</code> bits of each <code>x[i]</code> are stored explicitly and contiguously
in the lower-bits array, with <code>L</code> chosen as (<code>Log()</code> base 2):
<p>
<code>L = max(0, floor(log(upperBound/numValues)))</code>
<p>
The upper bits are stored in the upper-bits array as a sequence of unary-coded gaps (<code>x[-1] = 0</code>):
<p>
<code>(x[i]/2<strong>L) - (x[i-1]/2</strong>L)</code>
<p>
The unary code encodes a natural number <code>n</code> by <code>n</code> 0 bits followed by a 1 bit:
<code>0...01</code>. 
<p>
In the upper bits the total the number of 1 bits is <code>numValues</code>
and the total number of 0 bits is:
<p>
<code>floor(x[numValues-1]/2<strong>L) &lt;= upperBound/(2</strong>max(0, floor(log(upperBound/numValues)))) &lt;= 2<em>numValues</em></code>
<p>
The Elias-Fano encoding uses at most
<p>
<code>2 + Ceil(Log(upperBound/numValues))</code>
<p>
bits per encoded number. With <code>upperBound</code> in these bounds (<code>p</code> is an integer):
<p>
<code>2<em>p &lt; x[numValues-1] &lt;= upperBound &lt;= 2</em>*(p+1)</code>
<p>
the number of bits per encoded number is minimized.
<p>
In this implementation the values in the sequence can be given as <code>long</code>,
<code>numValues = 0</code> and <code>upperBound = 0</code> are allowed,
and each of the upper and lower bit arrays should fit in a <code>long[]</code>.
<p>
An index of positions of zero&apos;s in the upper bits is also built.
<p>
this implementation is based on this article:
<p>
Sebastiano Vigna, &quot;Quasi Succinct Indices&quot;, June 19, 2012, sections 3, 4 and 9.
Retrieved from <a href="http://arxiv.org/pdf/1206.4300">http://arxiv.org/pdf/1206.4300</a> .</p>
<p><p>The articles originally describing the Elias-Fano representation are:
<p>Peter Elias, &quot;Efficient storage and retrieval by content and address of static files&quot;,
J. Assoc. Comput. Mach., 21(2):246â€&quot;260, 1974.
<p>Robert M. Fano, &quot;On the number of bits required to implement an associative memory&quot;,
 Memorandum 61, Computer Structures Group, Project MAC, MIT, Cambridge, Mass., 1971.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.Packed.GrowableWriter.html">GrowableWriter</a></h4>
      <section><p>Implements <a class="xref" href="Lucene.Net.Util.Packed.PackedInt32s.Mutable.html">PackedInt32s.Mutable</a>, but grows the
bit count of the underlying packed ints on-demand.
<p>Beware that this class will accept to set negative values but in order
to do this, it will grow the number of bits per value to 64.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.Packed.MonotonicAppendingInt64Buffer.html">MonotonicAppendingInt64Buffer</a></h4>
      <section><p>Utility class to buffer signed longs in memory, which is optimized for the
case where the sequence is monotonic, although it can encode any sequence of
arbitrary longs. It only supports appending.
<p>
NOTE: This was MonotonicAppendingLongBuffer in Lucene.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.Packed.MonotonicBlockPackedReader.html">MonotonicBlockPackedReader</a></h4>
      <section><p>Provides random access to a stream written with
<a class="xref" href="Lucene.Net.Util.Packed.MonotonicBlockPackedWriter.html">MonotonicBlockPackedWriter</a>.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.Packed.MonotonicBlockPackedWriter.html">MonotonicBlockPackedWriter</a></h4>
      <section><p>A writer for large monotonically increasing sequences of positive <span class="xref">System.Int64</span>s.
<p>
The sequence is divided into fixed-size blocks and for each block, values
are modeled after a linear function f: x → A × x + B. The block
encodes deltas from the expected values computed from this function using as
few bits as possible. Each block has an overhead between 6 and 14 bytes.
<p>
Format:
<ul><li>&lt;BLock&gt;<sup>BlockCount</sup></li><li>BlockCount: ⌈ ValueCount / BlockSize ⌉</li><li>Block: &lt;Header, (Ints)&gt;</li><li>Header: &lt;B, A, BitsPerValue&gt;</li><li>B: the B from f: x → A × x + B using a
    variable-length <span class="xref">System.Int64</span> (<a class="xref" href="Lucene.Net.Store.DataOutput.html#Lucene_Net_Store_DataOutput_WriteVInt64_System_Int64_">WriteVInt64(Int64)</a>)</li><li>A: the A from f: x → A × x + B encoded using
<a class="xref" href="Lucene.Net.Support.Number.html#Lucene_Net_Support_Number_SingleToInt32Bits_System_Single_">SingleToInt32Bits(Single)</a> on
4 bytes (<a class="xref" href="Lucene.Net.Store.DataOutput.html#Lucene_Net_Store_DataOutput_WriteVInt32_System_Int32_">WriteVInt32(Int32)</a>)</li><li>BitsPerValue: a variable-length <span class="xref">System.Int32</span> (<a class="xref" href="Lucene.Net.Store.DataOutput.html#Lucene_Net_Store_DataOutput_WriteVInt32_System_Int32_">WriteVInt32(Int32)</a>)</li><li>Ints: if BitsPerValue is <code>0</code>, then there is nothing to read and
all values perfectly match the result of the function. Otherwise, these
are the
<a href="https://developers.google.com/protocol-buffers/docs/encoding#types">zigzag-encoded</a>
packed (<a class="xref" href="Lucene.Net.Util.Packed.PackedInt32s.html">PackedInt32s</a>) deltas from the expected value (computed from
the function) using exaclty BitsPerValue bits per value</li></ul> 
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.Packed.Packed64.html">Packed64</a></h4>
      <section><p>Space optimized random access capable array of values with a fixed number of
bits/value. Values are packed contiguously.
<p>
The implementation strives to perform af fast as possible under the
constraint of contiguous bits, by avoiding expensive operations. This comes
at the cost of code clarity.
<p>
Technical details: this implementation is a refinement of a non-branching
version. The non-branching get and set methods meant that 2 or 4 atomics in
the underlying array were always accessed, even for the cases where only
1 or 2 were needed. Even with caching, this had a detrimental effect on
performance.
Related to this issue, the old implementation used lookup tables for shifts
and masks, which also proved to be a bit slower than calculating the shifts
and masks on the fly.
See <a href="https://issues.apache.org/jira/browse/LUCENE-4062">https://issues.apache.org/jira/browse/LUCENE-4062</a> for details.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.Packed.PackedDataInput.html">PackedDataInput</a></h4>
      <section><p>A <a class="xref" href="Lucene.Net.Store.DataInput.html">DataInput</a> wrapper to read unaligned, variable-length packed
integers. This API is much slower than the <a class="xref" href="Lucene.Net.Util.Packed.PackedInt32s.html">PackedInt32s</a> fixed-length
API but can be convenient to save space. 
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.Packed.PackedDataOutput.html">PackedDataOutput</a></h4>
      <section><p>A <a class="xref" href="Lucene.Net.Store.DataOutput.html">DataOutput</a> wrapper to write unaligned, variable-length packed
integers.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.Packed.PackedInt32s.html">PackedInt32s</a></h4>
      <section><p>Simplistic compression for array of unsigned long values.
Each value is &gt;= 0 and &lt;= a specified maximum value.  The
values are stored as packed ints, with each value
consuming a fixed number of bits.
<p>
NOTE: This was PackedInts in Lucene.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.Packed.PackedInt32s.Format.html">PackedInt32s.Format</a></h4>
      <section><p>A format to write packed <span class="xref">System.Int32</span>s.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.Packed.PackedInt32s.FormatAndBits.html">PackedInt32s.FormatAndBits</a></h4>
      <section><p>Simple class that holds a format and a number of bits per value.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.Packed.PackedInt32s.Header.html">PackedInt32s.Header</a></h4>
      <section><p>Header identifying the structure of a packed integer array. </p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.Packed.PackedInt32s.Mutable.html">PackedInt32s.Mutable</a></h4>
      <section><p>A packed integer array that can be modified.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.Packed.PackedInt32s.MutableImpl.html">PackedInt32s.MutableImpl</a></h4>
      <section></section>
      <h4><a class="xref" href="Lucene.Net.Util.Packed.PackedInt32s.NullReader.html">PackedInt32s.NullReader</a></h4>
      <section><p>A <a class="xref" href="Lucene.Net.Util.Packed.PackedInt32s.Reader.html">PackedInt32s.Reader</a> which has all its values equal to 0 (bitsPerValue = 0). </p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.Packed.PackedInt32s.Reader.html">PackedInt32s.Reader</a></h4>
      <section><p>A read-only random access array of positive integers.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.Packed.PackedInt32s.Writer.html">PackedInt32s.Writer</a></h4>
      <section><p>A write-once Writer.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.Packed.PagedGrowableWriter.html">PagedGrowableWriter</a></h4>
      <section><p>A <a class="xref" href="Lucene.Net.Util.Packed.PagedGrowableWriter.html">PagedGrowableWriter</a>. This class slices data into fixed-size blocks
which have independent numbers of bits per value and grow on-demand.
<p>
You should use this class instead of the <a class="xref" href="Lucene.Net.Util.Packed.AbstractAppendingInt64Buffer.html">AbstractAppendingInt64Buffer</a> related ones only when
you need random write-access. Otherwise this class will likely be slower and
less memory-efficient.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.Packed.PagedMutable.html">PagedMutable</a></h4>
      <section><p>A <a class="xref" href="Lucene.Net.Util.Packed.PagedMutable.html">PagedMutable</a>. This class slices data into fixed-size blocks
which have the same number of bits per value. It can be a useful replacement
for <a class="xref" href="Lucene.Net.Util.Packed.PackedInt32s.Mutable.html">PackedInt32s.Mutable</a> to store more than 2B values.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
    <h3 id="interfaces">Interfaces
  </h3>
      <h4><a class="xref" href="Lucene.Net.Util.Packed.PackedInt32s.IDecoder.html">PackedInt32s.IDecoder</a></h4>
      <section><p>A decoder for packed integers.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.Packed.PackedInt32s.IEncoder.html">PackedInt32s.IEncoder</a></h4>
      <section><p>An encoder for packed integers.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.Packed.PackedInt32s.IReaderIterator.html">PackedInt32s.IReaderIterator</a></h4>
      <section><p>Run-once iterator interface, to decode previously saved <a class="xref" href="Lucene.Net.Util.Packed.PackedInt32s.html">PackedInt32s</a>.</p>
</section>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            Copyright © 2019 Licensed to the Apache Software Foundation (ASF)
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
