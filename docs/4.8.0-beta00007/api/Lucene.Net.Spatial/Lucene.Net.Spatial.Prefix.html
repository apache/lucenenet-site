<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Namespace Lucene.Net.Spatial.Prefix
   | Apache Lucene.NET 4.8.0 Documentation </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Namespace Lucene.Net.Spatial.Prefix
   | Apache Lucene.NET 4.8.0 Documentation ">
    <meta name="generator" content="docfx 2.50.0.0">
    
    <link rel="shortcut icon" href="../../logo/favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    <meta property="docfx:rel" content="../../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../logo/lucene-net-color.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="Lucene.Net.Spatial.Prefix">
  
  <h1 id="Lucene_Net_Spatial_Prefix" data-uid="Lucene.Net.Spatial.Prefix" class="text-break">Namespace Lucene.Net.Spatial.Prefix
  </h1>
  <div class="markdown level0 summary"><!--
 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<p>Prefix Tree Strategy</p>
</div>
  <div class="markdown level0 conceptual"></div>
  <div class="markdown level0 remarks"></div>
    <h3 id="classes">Classes
  </h3>
      <h4><a class="xref" href="Lucene.Net.Spatial.Prefix.AbstractPrefixTreeFilter.html">AbstractPrefixTreeFilter</a></h4>
      <section><p>Base class for Lucene Filters on SpatialPrefixTree fields.</p>
<div class="lucene-block lucene-experimental">This is a Lucene.NET EXPERIMENTAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Spatial.Prefix.AbstractPrefixTreeFilter.BaseTermsEnumTraverser.html">AbstractPrefixTreeFilter.BaseTermsEnumTraverser</a></h4>
      <section><p>Holds transient state and docid collecting utility methods as part of
traversing a <a class="xref" href="../Lucene.Net/Lucene.Net.Index.TermsEnum.html">TermsEnum</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Spatial.Prefix.AbstractVisitingPrefixTreeFilter.html">AbstractVisitingPrefixTreeFilter</a></h4>
      <section><p>Traverses a <a class="xref" href="Lucene.Net.Spatial.Prefix.Tree.SpatialPrefixTree.html">SpatialPrefixTree</a> indexed field, using the template &amp;
visitor design patterns for subclasses to guide the traversal and collect
matching documents.
<p>
Subclasses implement <a class="xref" href="../Lucene.Net/Lucene.Net.Search.Filter.html#Lucene_Net_Search_Filter_GetDocIdSet_Lucene_Net_Index_AtomicReaderContext_Lucene_Net_Util_IBits_">GetDocIdSet(AtomicReaderContext, IBits)</a>
by instantiating a custom <a class="xref" href="Lucene.Net.Spatial.Prefix.AbstractVisitingPrefixTreeFilter.VisitorTemplate.html">AbstractVisitingPrefixTreeFilter.VisitorTemplate</a> subclass (i.e. an anonymous inner class) and implement the
required methods.</p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Spatial.Prefix.AbstractVisitingPrefixTreeFilter.VisitorTemplate.html">AbstractVisitingPrefixTreeFilter.VisitorTemplate</a></h4>
      <section><p>An abstract class designed to make it easy to implement predicates or
other operations on a <a class="xref" href="Lucene.Net.Spatial.Prefix.Tree.SpatialPrefixTree.html">SpatialPrefixTree</a> indexed field. An instance
of this class is not designed to be re-used across AtomicReaderContext
instances so simply create a new one for each call to, say a
<a class="xref" href="../Lucene.Net/Lucene.Net.Search.Filter.html#Lucene_Net_Search_Filter_GetDocIdSet_Lucene_Net_Index_AtomicReaderContext_Lucene_Net_Util_IBits_">GetDocIdSet(AtomicReaderContext, IBits)</a>.
The <a class="xref" href="Lucene.Net.Spatial.Prefix.AbstractVisitingPrefixTreeFilter.VisitorTemplate.html#Lucene_Net_Spatial_Prefix_AbstractVisitingPrefixTreeFilter_VisitorTemplate_GetDocIdSet">GetDocIdSet()</a> method here starts the work. It first checks
that there are indexed terms; if not it quickly returns null. Then it calls
<a class="xref" href="Lucene.Net.Spatial.Prefix.AbstractVisitingPrefixTreeFilter.VisitorTemplate.html#Lucene_Net_Spatial_Prefix_AbstractVisitingPrefixTreeFilter_VisitorTemplate_Start">Start()</a> so a subclass can set up a return value, like an
<a class="xref" href="../Lucene.Net/Lucene.Net.Util.FixedBitSet.html">FixedBitSet</a>. Then it starts the traversal
process, calling <a class="xref" href="Lucene.Net.Spatial.Prefix.AbstractVisitingPrefixTreeFilter.VisitorTemplate.html#Lucene_Net_Spatial_Prefix_AbstractVisitingPrefixTreeFilter_VisitorTemplate_FindSubCellsToVisit_Lucene_Net_Spatial_Prefix_Tree_Cell_">FindSubCellsToVisit(Cell)</a>
which by default finds the top cells that intersect <code>queryShape</code>. If
there isn&apos;t an indexed cell for a corresponding cell returned for this
method then it&apos;s short-circuited until it finds one, at which point
<a class="xref" href="Lucene.Net.Spatial.Prefix.AbstractVisitingPrefixTreeFilter.VisitorTemplate.html#Lucene_Net_Spatial_Prefix_AbstractVisitingPrefixTreeFilter_VisitorTemplate_Visit_Lucene_Net_Spatial_Prefix_Tree_Cell_">Visit(Cell)</a> is called. At
some depths, of the tree, the algorithm switches to a scanning mode that
calls <a class="xref" href="Lucene.Net.Spatial.Prefix.AbstractVisitingPrefixTreeFilter.VisitorTemplate.html#Lucene_Net_Spatial_Prefix_AbstractVisitingPrefixTreeFilter_VisitorTemplate_VisitScanned_Lucene_Net_Spatial_Prefix_Tree_Cell_">VisitScanned(Cell)</a>
for each leaf cell found.</p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Spatial.Prefix.AbstractVisitingPrefixTreeFilter.VNode.html">AbstractVisitingPrefixTreeFilter.VNode</a></h4>
      <section><p>A Visitor node/cell found via the query shape for <a class="xref" href="Lucene.Net.Spatial.Prefix.AbstractVisitingPrefixTreeFilter.VisitorTemplate.html">AbstractVisitingPrefixTreeFilter.VisitorTemplate</a>.
Sometimes these are reset(cell). It&apos;s like a LinkedList node but forms a
tree.</p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Spatial.Prefix.ContainsPrefixTreeFilter.html">ContainsPrefixTreeFilter</a></h4>
      <section><p>Finds docs where its indexed shape <a class="xref" href="Lucene.Net.Spatial.Queries.SpatialOperation.html#Lucene_Net_Spatial_Queries_SpatialOperation_Contains">Contains</a>
the query shape. For use on <a class="xref" href="Lucene.Net.Spatial.Prefix.RecursivePrefixTreeStrategy.html">RecursivePrefixTreeStrategy</a>.</p>
<div class="lucene-block lucene-experimental">This is a Lucene.NET EXPERIMENTAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Spatial.Prefix.IntersectsPrefixTreeFilter.html">IntersectsPrefixTreeFilter</a></h4>
      <section><p>A Filter matching documents that have an <see cref="!:SpatialRelation.INTERSECTS"></see>
(i.e. not DISTINCT) relationship with a provided query shape.</p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Spatial.Prefix.PointPrefixTreeFieldCacheProvider.html">PointPrefixTreeFieldCacheProvider</a></h4>
      <section><p>Implementation of <a class="xref" href="Lucene.Net.Spatial.Util.ShapeFieldCacheProvider-1.html">ShapeFieldCacheProvider&lt;T&gt;</a>
designed for <a class="xref" href="Lucene.Net.Spatial.Prefix.PrefixTreeStrategy.html">PrefixTreeStrategy</a>s.</p>
<p>Note, due to the fragmented representation of Shapes in these Strategies, this implementation
can only retrieve the central <see cref="!:IPoint">Point</see> of the original Shapes.</p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Spatial.Prefix.PrefixTreeStrategy.html">PrefixTreeStrategy</a></h4>
      <section><p>An abstract SpatialStrategy based on <a class="xref" href="Lucene.Net.Spatial.Prefix.Tree.SpatialPrefixTree.html">SpatialPrefixTree</a>. The two
subclasses are <a class="xref" href="Lucene.Net.Spatial.Prefix.RecursivePrefixTreeStrategy.html">RecursivePrefixTreeStrategy</a> and
<a class="xref" href="Lucene.Net.Spatial.Prefix.TermQueryPrefixTreeStrategy.html">TermQueryPrefixTreeStrategy</a>.  This strategy is most effective as a fast
approximate spatial search filter.</p>
<p><h4>Characteristics:</h4>
<ul><li>Can index any shape; however only
<a class="xref" href="Lucene.Net.Spatial.Prefix.RecursivePrefixTreeStrategy.html">RecursivePrefixTreeStrategy</a>
can effectively search non-point shapes.</li><li>Can index a variable number of shapes per field value. This strategy
can do it via multiple calls to <a class="xref" href="Lucene.Net.Spatial.Prefix.PrefixTreeStrategy.html#Lucene_Net_Spatial_Prefix_PrefixTreeStrategy_CreateIndexableFields_IShape_">CreateIndexableFields(IShape)</a>
for a document or by giving it some sort of Shape aggregate (e.g. NTS
WKT MultiPoint).  The shape&apos;s boundary is approximated to a grid precision.
</li><li>Can query with any shape.  The shape&apos;s boundary is approximated to a grid
precision.</li><li>Only <a class="xref" href="Lucene.Net.Spatial.Queries.SpatialOperation.html#Lucene_Net_Spatial_Queries_SpatialOperation_Intersects">Intersects</a>
is supported.  If only points are indexed then this is effectively equivalent
to IsWithin.</li><li>The strategy supports <a class="xref" href="Lucene.Net.Spatial.Prefix.PrefixTreeStrategy.html#Lucene_Net_Spatial_Prefix_PrefixTreeStrategy_MakeDistanceValueSource_IPoint_System_Double_">MakeDistanceValueSource(IPoint, Double)</a>
even for multi-valued data, so long as the indexed data is all points; the
behavior is undefined otherwise.  However, <code>it will likely be removed in
the future</code> in lieu of using another strategy with a more scalable
implementation.  Use of this call is the only
circumstance in which a cache is used.  The cache is simple but as such
it doesn&apos;t scale to large numbers of points nor is it real-time-search
friendly.</li></ul></p>
<p><h4>Implementation:</h4>
The <a class="xref" href="Lucene.Net.Spatial.Prefix.Tree.SpatialPrefixTree.html">SpatialPrefixTree</a>
does most of the work, for example returning
a list of terms representing grids of various sizes for a supplied shape.
An important
configuration item is <a class="xref" href="Lucene.Net.Spatial.Prefix.PrefixTreeStrategy.html#Lucene_Net_Spatial_Prefix_PrefixTreeStrategy_DistErrPct">DistErrPct</a> which balances
shape precision against scalability.  See those docs.</p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Spatial.Prefix.RecursivePrefixTreeStrategy.html">RecursivePrefixTreeStrategy</a></h4>
      <section><p>A <a class="xref" href="Lucene.Net.Spatial.Prefix.PrefixTreeStrategy.html">PrefixTreeStrategy</a> which uses <a class="xref" href="Lucene.Net.Spatial.Prefix.AbstractVisitingPrefixTreeFilter.html">AbstractVisitingPrefixTreeFilter</a>.
This strategy has support for searching non-point shapes (note: not tested).
Even a query shape with distErrPct=0 (fully precise to the grid) should have
good performance for typical data, unless there is a lot of indexed data
coincident with the shape&apos;s edge.</p>
<div class="lucene-block lucene-experimental">This is a Lucene.NET EXPERIMENTAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Spatial.Prefix.TermQueryPrefixTreeStrategy.html">TermQueryPrefixTreeStrategy</a></h4>
      <section><p>A basic implementation of <a class="xref" href="Lucene.Net.Spatial.Prefix.PrefixTreeStrategy.html">PrefixTreeStrategy</a> using a large
<a class="xref" href="../Lucene.Net.Queries/Lucene.Net.Queries.TermsFilter.html">TermsFilter</a> of all the cells from
<a class="xref" href="Lucene.Net.Spatial.Prefix.Tree.SpatialPrefixTree.html#Lucene_Net_Spatial_Prefix_Tree_SpatialPrefixTree_GetCells_IShape_System_Int32_System_Boolean_System_Boolean_">GetCells(IShape, Int32, Boolean, Boolean)</a>. 
It only supports the search of indexed Point shapes.
<p>
The precision of query shapes (DistErrPct) is an important factor in using
this Strategy. If the precision is too precise then it will result in many
terms which will amount to a slower query.</p>
<div class="lucene-block lucene-experimental">This is a Lucene.NET EXPERIMENTAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Spatial.Prefix.WithinPrefixTreeFilter.html">WithinPrefixTreeFilter</a></h4>
      <section><p>Finds docs where its indexed shape is
<a class="xref" href="Lucene.Net.Spatial.Queries.SpatialOperation.html#Lucene_Net_Spatial_Queries_SpatialOperation_IsWithin">IsWithin</a>
the query shape.  It works by looking at cells outside of the query
shape to ensure documents there are excluded. By default, it will
examine all cells, and it&apos;s fairly slow.  If you know that the indexed shapes
are never comprised of multiple disjoint parts (which also means it is not multi-valued),
then you can pass <code>SpatialPrefixTree.GetDistanceForLevel(maxLevels)</code> as
the <code>queryBuffer</code> constructor parameter to minimally look this distance
beyond the query shape&apos;s edge.  Even if the indexed shapes are sometimes
comprised of multiple disjoint parts, you might want to use this option with
a large buffer as a faster approximation with minimal false-positives.</p>
<div class="lucene-block lucene-experimental">This is a Lucene.NET EXPERIMENTAL API, use at your own risk</div></section>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/apache/lucenenet/blob/docs/4.8.0-beta00007/src/Lucene.Net.Spatial/Prefix/package.md/#L2" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            Copyright © 2020 Licensed to the Apache Software Foundation (ASF)
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
