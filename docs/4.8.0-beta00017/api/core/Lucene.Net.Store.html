<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Namespace Lucene.Net.Store
 | Apache Lucene.NET 4.8.0-beta00017 Documentation </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Namespace Lucene.Net.Store
 | Apache Lucene.NET 4.8.0-beta00017 Documentation ">
    <meta name="generator" content="docfx ">
  
    <link rel="shortcut icon" href="https://lucenenet.apache.org/docs/4.8.0-beta00017/logo/favicon.ico">
    <link rel="stylesheet" href="https://lucenenet.apache.org/docs/4.8.0-beta00017/styles/docfx.vendor.min.css">
    <link rel="stylesheet" href="https://lucenenet.apache.org/docs/4.8.0-beta00017/styles/docfx.css">
    <link rel="stylesheet" href="https://lucenenet.apache.org/docs/4.8.0-beta00017/styles/main.css">
    <meta property="docfx:navrel" content="toc.html">
    <meta property="docfx:tocrel" content="core/toc.html">
  
  <meta property="docfx:rel" content="https://lucenenet.apache.org/docs/4.8.0-beta00017/">
  
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <span id="forkongithub"><a href="https://github.com/apache/lucenenet" target="_blank">Fork me on GitHub</a></span>
    <div id="wrapper">
      <header>

        <nav id="autocollapse" class="navbar ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <a class="navbar-brand" href="/">
                <img id="logo" class="svg" src="https://lucenenet.apache.org/docs/4.8.0-beta00017/logo/lucene-net-color.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>

        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search">
            <ul class="level0 breadcrumb">
                <li>
                    <a href="https://lucenenet.apache.org/docs/4.8.0-beta00017/">API</a>
                     <span id="breadcrumb">
                        <ul class="breadcrumb">
                          <li></li>
                        </ul>
                    </span>   
                </li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">

        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">

        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="Lucene.Net.Store">

  <h1 id="Lucene_Net_Store" data-uid="Lucene.Net.Store" class="text-break">Namespace Lucene.Net.Store
</h1>
  <div class="markdown level0 summary"><!--
 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<p>Binary i/o API, used for all index data.</p>
</div>
  <div class="markdown level0 conceptual"></div>
  <div class="markdown level0 remarks"></div>
    <h3 id="classes">Classes
</h3>
      <h4><a class="xref" href="Lucene.Net.Store.BaseDirectory.html">BaseDirectory</a></h4>
      <section><p>Base implementation for a concrete <a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a>.</p>
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is experimental and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Store.BufferedChecksumIndexInput.html">BufferedChecksumIndexInput</a></h4>
      <section><p>Simple implementation of <a class="xref" href="Lucene.Net.Store.ChecksumIndexInput.html">ChecksumIndexInput</a> that wraps
another input and delegates calls.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.BufferedIndexInput.html">BufferedIndexInput</a></h4>
      <section><p>Base implementation class for buffered <a class="xref" href="Lucene.Net.Store.IndexInput.html">IndexInput</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.BufferedIndexOutput.html">BufferedIndexOutput</a></h4>
      <section><p>Base implementation class for buffered <a class="xref" href="Lucene.Net.Store.IndexOutput.html">IndexOutput</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.ByteArrayDataInput.html">ByteArrayDataInput</a></h4>
      <section><p>DataInput backed by a byte array.
<b>WARNING:</b> this class omits all low-level checks.</p>
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is experimental and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Store.ByteArrayDataOutput.html">ByteArrayDataOutput</a></h4>
      <section><p>DataOutput backed by a byte array.
<b>WARNING:</b> this class omits most low-level checks,
so be sure to test heavily with assertions enabled.</p>
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is experimental and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Store.ByteBufferIndexInput.html">ByteBufferIndexInput</a></h4>
      <section><p>Base <a class="xref" href="Lucene.Net.Store.IndexInput.html">IndexInput</a> implementation that uses an array
of <span class="xref">J2N.IO.ByteBuffer</span>s to represent a file.</p>
<p></p>
Because Java's <span class="xref">J2N.IO.ByteBuffer</span> uses an <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a> to address the
values, it's necessary to access a file greater
<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32.maxvalue">MaxValue</a> in size using multiple byte buffers.
<p></p>
For efficiency, this class requires that the buffers
are a power-of-two (<code>chunkSizePower</code>).
</section>
      <h4><a class="xref" href="Lucene.Net.Store.ChecksumIndexInput.html">ChecksumIndexInput</a></h4>
      <section><p>Extension of <a class="xref" href="Lucene.Net.Store.IndexInput.html">IndexInput</a>, computing checksum as it goes.
Callers can retrieve the checksum via <a class="xref" href="Lucene.Net.Store.ChecksumIndexInput.html#Lucene_Net_Store_ChecksumIndexInput_Checksum">Checksum</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.CompoundFileDirectory.html">CompoundFileDirectory</a></h4>
      <section><p>Class for accessing a compound stream.
This class implements a directory, but is limited to only read operations.
Directory methods that would normally modify data throw an exception.</p>
<p></p>
All files belonging to a segment have the same name with varying extensions.
The extensions correspond to the different file formats used by the <a class="xref" href="Lucene.Net.Codecs.Codec.html">Codec</a>.
When using the Compound File format these files are collapsed into a
single <code>.cfs</code> file (except for the <a class="xref" href="Lucene.Net.Codecs.LiveDocsFormat.html">LiveDocsFormat</a>, with a
corresponding <code>.cfe</code> file indexing its sub-files.
<p></p>
Files:
<ul><li><code>.cfs</code>: An optional "virtual" file consisting of all the other
        index files for systems that frequently run out of file handles.</li><li><code>.cfe</code>: The "virtual" compound file's entry table holding all
        entries in the corresponding .cfs file.</li></ul><p>Description:</p><ul><li>Compound (.cfs) --&gt; Header, FileData <sup>FileCount</sup></li><li>Compound Entry Table (.cfe) --&gt; Header, FileCount, &lt;FileName,
        DataOffset, DataLength&gt; <sup>FileCount</sup>, Footer</li><li>Header --&gt; <a class="xref" href="Lucene.Net.Codecs.CodecUtil.html#Lucene_Net_Codecs_CodecUtil_WriteHeader_Lucene_Net_Store_DataOutput_System_String_System_Int32_">WriteHeader(DataOutput, string, int)</a></li><li>FileCount --&gt; <a class="xref" href="Lucene.Net.Store.DataOutput.html#Lucene_Net_Store_DataOutput_WriteVInt32_System_Int32_">WriteVInt32(int)</a></li><li>DataOffset,DataLength --&gt; <a class="xref" href="Lucene.Net.Store.DataOutput.html#Lucene_Net_Store_DataOutput_WriteInt64_System_Int64_">WriteInt64(long)</a></li><li>FileName --&gt; <a class="xref" href="Lucene.Net.Store.DataOutput.html#Lucene_Net_Store_DataOutput_WriteString_System_String_">WriteString(string)</a></li><li>FileData --&gt; raw file data</li><li>Footer --&gt; <a class="xref" href="Lucene.Net.Codecs.CodecUtil.html#Lucene_Net_Codecs_CodecUtil_WriteFooter_Lucene_Net_Store_IndexOutput_">WriteFooter(IndexOutput)</a></li></ul><p>Notes:</p><ul><li>FileCount indicates how many files are contained in this compound file.
        The entry table that follows has that many entries.</li><li>Each directory entry contains a long pointer to the start of this file's data
        section, the files length, and a <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a> with that file's name.</li></ul><p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is experimental and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Store.CompoundFileDirectory.FileEntry.html">CompoundFileDirectory.FileEntry</a></h4>
      <section><p>Offset/Length for a slice inside of a compound file</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.DataInput.html">DataInput</a></h4>
      <section><p>Abstract base class for performing read operations of Lucene's low-level
data types.</p>
<p></p><a class="xref" href="Lucene.Net.Store.DataInput.html">DataInput</a> may only be used from one thread, because it is not
thread safe (it keeps internal state like file position). To allow
multithreaded use, every <a class="xref" href="Lucene.Net.Store.DataInput.html">DataInput</a> instance must be cloned before
used in another thread. Subclasses must therefore implement <a class="xref" href="Lucene.Net.Store.DataInput.html#Lucene_Net_Store_DataInput_Clone">Clone()</a>,
returning a new <a class="xref" href="Lucene.Net.Store.DataInput.html">DataInput</a> which operates on the same underlying
resource, but positioned independently.
</section>
      <h4><a class="xref" href="Lucene.Net.Store.DataOutput.html">DataOutput</a></h4>
      <section><p>Abstract base class for performing write operations of Lucene's low-level
data types.</p>
<p></p><a class="xref" href="Lucene.Net.Store.DataOutput.html">DataOutput</a> may only be used from one thread, because it is not
thread safe (it keeps internal state like file position).
</section>
      <h4><a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a></h4>
      <section><p>A <a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a> is a flat list of files.  Files may be written once, when they
are created.  Once a file is created it may only be opened for read, or
deleted.  Random access is permitted both when reading and writing.</p>
<p></p>
.NET's i/o APIs not used directly, but rather all i/o is
through this API.  This permits things such as: 
<ul><li> implementation of RAM-based indices;</li><li> implementation indices stored in a database;</li><li> implementation of an index as a single file;</li></ul><p></p>
Directory locking is implemented by an instance of
<a class="xref" href="Lucene.Net.Store.LockFactory.html">LockFactory</a>, and can be changed for each <a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a>
instance using <a class="xref" href="Lucene.Net.Store.Directory.html#Lucene_Net_Store_Directory_SetLockFactory_Lucene_Net_Store_LockFactory_">SetLockFactory(LockFactory)</a>.
</section>
      <h4><a class="xref" href="Lucene.Net.Store.Directory.IndexInputSlicer.html">Directory.IndexInputSlicer</a></h4>
      <section><p>Allows to create one or more sliced <a class="xref" href="Lucene.Net.Store.IndexInput.html">IndexInput</a> instances from a single
file handle. Some <a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a> implementations may be able to efficiently map slices of a file
into memory when only certain parts of a file are required.</p>
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

<div class="NOTE">
<h5>Note</h5>
<p>This API is experimental and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Store.FSDirectory.html">FSDirectory</a></h4>
      <section><p>Base class for <a class="xref" href="Lucene.Net.Store.FSDirectory.html#Lucene_Net_Store_FSDirectory_Directory">Directory</a> implementations that store index
files in the file system.</p>
<p></p>
There are currently three core
subclasses:
<ul><li><a class="xref" href="Lucene.Net.Store.SimpleFSDirectory.html">SimpleFSDirectory</a> is a straightforward
        implementation using <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.io.filestream">FileStream</a>, which is ideal for writing
        without using much RAM. However, it has poor concurrent performance
        (multiple threads will bottleneck) as it
        synchronizes when multiple threads read from the
        same file.</li><li><a class="xref" href="Lucene.Net.Store.NIOFSDirectory.html">NIOFSDirectory</a>
        uses <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.io.filestream">FileStream</a>'s positional seeking,
        which makes it slightly less efficient than using <a class="xref" href="Lucene.Net.Store.SimpleFSDirectory.html">SimpleFSDirectory</a>
        during reading, with similar write performance.</li><li><a class="xref" href="Lucene.Net.Store.MMapDirectory.html">MMapDirectory</a> uses memory-mapped IO when
        reading. This is a good choice if you have plenty
        of virtual memory relative to your index size, eg
        if you are running on a 64 bit runtime, or you are
        running on a 32 bit runtime but your index sizes are
        small enough to fit into the virtual memory space.</li></ul>
<p>Unfortunately, because of system peculiarities, there is
no single overall best implementation.  Therefore, we've
added the <a class="xref" href="Lucene.Net.Store.FSDirectory.html#Lucene_Net_Store_FSDirectory_Open_System_String_">Open(string)</a> method  (or one of its overloads), to allow Lucene to choose
the best <a class="xref" href="Lucene.Net.Store.FSDirectory.html">FSDirectory</a> implementation given your
environment, and the known limitations of each
implementation. For users who have no reason to prefer a
specific implementation, it's best to simply use
<a class="xref" href="Lucene.Net.Store.FSDirectory.html#Lucene_Net_Store_FSDirectory_Open_System_String_">Open(string)</a>  (or one of its overloads). For all others, you should instantiate the
desired implementation directly.</p>
<p></p>The locking implementation is by default
<a class="xref" href="Lucene.Net.Store.NativeFSLockFactory.html">NativeFSLockFactory</a>, but can be changed by
passing in a custom <a class="xref" href="Lucene.Net.Store.LockFactory.html">LockFactory</a> instance.
<p></p><font color="red"><b>NOTE:</b> Unlike in Java, it is not recommended to use
<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.thread.interrupt">Interrupt()</a> in .NET
in conjunction with an open <a class="xref" href="Lucene.Net.Store.FSDirectory.html">FSDirectory</a> because it is not guaranteed to exit atomically.
Any <code>lock</code> statement or <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.monitor.enter#system-threading-monitor-enter(system-object)">Enter(object)</a> call can throw a
<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.threadinterruptedexception">ThreadInterruptedException</a>, which makes shutting down unpredictable.
To exit parallel tasks safely, we recommend using <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task">Task</a>s
and "interrupt" them with <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a>s.</font>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.FSDirectory.FSIndexOutput.html">FSDirectory.FSIndexOutput</a></h4>
      <section><p>Writes output with <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.io.filestream.write#system-io-filestream-write(system-byte()-system-int32-system-int32)">Write(byte[], int, int)</a></p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.FSLockFactory.html">FSLockFactory</a></h4>
      <section><p>Base class for file system based locking implementation.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.FileSwitchDirectory.html">FileSwitchDirectory</a></h4>
      <section><p>Expert: A <a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a> instance that switches files between
two other <a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a> instances.</p>
<p></p>Files with the specified extensions are placed in the
primary directory; others are placed in the secondary
directory.  The provided <span class="xref">ISet{string}</span> must not change once passed
to this class, and must allow multiple threads to call
contains at once.
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is experimental and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Store.FilterDirectory.html">FilterDirectory</a></h4>
      <section><p>Directory implementation that delegates calls to another directory.
This class can be used to add limitations on top of an existing
<a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a> implementation such as
rate limiting (<a class="xref" href="Lucene.Net.Store.RateLimitedDirectoryWrapper.html">RateLimitedDirectoryWrapper</a>) or to add additional
sanity checks for tests. However, if you plan to write your own
<a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a> implementation, you should consider extending directly
<a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a> or <a class="xref" href="Lucene.Net.Store.BaseDirectory.html">BaseDirectory</a> rather than try to reuse
functionality of existing <a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a>s by extending this class.</p>
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Store.FlushInfo.html">FlushInfo</a></h4>
      <section><p>A FlushInfo provides information required for a FLUSH context.
It is used as part of an <a class="xref" href="Lucene.Net.Store.IOContext.html">IOContext</a> in case of FLUSH context.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.IOContext.html">IOContext</a></h4>
      <section><p><a class="xref" href="Lucene.Net.Store.IOContext.html">IOContext</a> holds additional details on the merge/search context. A <a class="xref" href="Lucene.Net.Store.IOContext.html">IOContext</a>
object can never be initialized as null as passed as a parameter to either
<a class="xref" href="Lucene.Net.Store.Directory.html#Lucene_Net_Store_Directory_OpenInput_System_String_Lucene_Net_Store_IOContext_">OpenInput(string, IOContext)</a> or
<a class="xref" href="Lucene.Net.Store.Directory.html#Lucene_Net_Store_Directory_CreateOutput_System_String_Lucene_Net_Store_IOContext_">CreateOutput(string, IOContext)</a></p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.IndexInput.html">IndexInput</a></h4>
      <section><p>Abstract base class for input from a file in a <a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a>.  A
random-access input stream.  Used for all Lucene index input operations.</p>
<p></p><a class="xref" href="Lucene.Net.Store.IndexInput.html">IndexInput</a> may only be used from one thread, because it is not
thread safe (it keeps internal state like file position). To allow
multithreaded use, every <a class="xref" href="Lucene.Net.Store.IndexInput.html">IndexInput</a> instance must be cloned before
used in another thread. Subclasses must therefore implement <a class="xref" href="Lucene.Net.Store.IndexInput.html#Lucene_Net_Store_IndexInput_Clone">Clone()</a>,
returning a new <a class="xref" href="Lucene.Net.Store.IndexInput.html">IndexInput</a> which operates on the same underlying
resource, but positioned independently. Lucene never closes cloned
<a class="xref" href="Lucene.Net.Store.IndexInput.html">IndexInput</a>s, it will only do this on the original one.
The original instance must take care that cloned instances throw
<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.objectdisposedexception">ObjectDisposedException</a> when the original one is closed.
</section>
      <h4><a class="xref" href="Lucene.Net.Store.IndexInputExtensions.html">IndexInputExtensions</a></h4>
      <section><!--
 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<p>Binary i/o API, used for all index data.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.IndexOutput.html">IndexOutput</a></h4>
      <section><p>Abstract base class for output to a file in a <a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a>.  A random-access
output stream.  Used for all Lucene index output operations.</p>
<p></p><a class="xref" href="Lucene.Net.Store.IndexOutput.html">IndexOutput</a> may only be used from one thread, because it is not
thread safe (it keeps internal state like file position).
</section>
      <h4><a class="xref" href="Lucene.Net.Store.IndexOutputExtensions.html">IndexOutputExtensions</a></h4>
      <section><!--
 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<p>Binary i/o API, used for all index data.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.InputStreamDataInput.html">InputStreamDataInput</a></h4>
      <section><p>A <a class="xref" href="Lucene.Net.Store.DataInput.html">DataInput</a> wrapping a plain <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.io.stream">Stream</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.Lock.html">Lock</a></h4>
      <section><p>An interprocess mutex lock.</p>
<p></p>Typical use might look like:
<pre><code class="lang-csharp">var result = Lock.With.NewAnonymous&lt;string&gt;(
    @lock: directory.MakeLock("my.lock"), 
    lockWaitTimeout: Lock.LOCK_OBTAIN_WAIT_FOREVER, 
    doBody: () =&gt;
{
    //... code to execute while locked ...
    return "the result";
}).Run();</code></pre>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.Lock.With-1.html">Lock.With&lt;T&gt;</a></h4>
      <section><p>Utility class for executing code with exclusive access.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.LockFactory.html">LockFactory</a></h4>
      <section><p>Base class for Locking implementation.  <a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a> uses
 instances of this class to implement locking.</p>
<p>Lucene uses <a class="xref" href="Lucene.Net.Store.NativeFSLockFactory.html">NativeFSLockFactory</a> by default for
 <a class="xref" href="Lucene.Net.Store.FSDirectory.html">FSDirectory</a>-based index directories.</p>
<p>Special care needs to be taken if you change the locking
 implementation: First be certain that no writer is in fact
 writing to the index otherwise you can easily corrupt
 your index. Be sure to do the <a class="xref" href="Lucene.Net.Store.LockFactory.html">LockFactory</a> change on all Lucene
 instances and clean up all leftover lock files before starting
 the new configuration for the first time. Different implementations
 can not work together!</p>
<p>If you suspect that some <a class="xref" href="Lucene.Net.Store.LockFactory.html">LockFactory</a> implementation is
 not working properly in your environment, you can easily
 test it by using <a class="xref" href="Lucene.Net.Store.VerifyingLockFactory.html">VerifyingLockFactory</a>, 
 <a class="xref" href="Lucene.Net.Store.LockVerifyServer.html">LockVerifyServer</a> and <a class="xref" href="Lucene.Net.Store.LockStressTest.html">LockStressTest</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.LockObtainFailedException.html">LockObtainFailedException</a></h4>
      <section><p>This exception is thrown when the <code>write.lock</code>
could not be acquired.  This
happens when a writer tries to open an index
that another writer already has open.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.LockReleaseFailedException.html">LockReleaseFailedException</a></h4>
      <section><p>This exception is thrown when the <code>write.lock</code>
could not be released.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.LockStressTest.html">LockStressTest</a></h4>
      <section><p>Simple standalone tool that forever acquires &amp; releases a
lock using a specific <a class="xref" href="Lucene.Net.Store.LockFactory.html">LockFactory</a>.</p>
<p></p>
LUCENENET specific: In the Java implementation, this class' Main method
was intended to be called from the command line. However, in .NET a
method within a DLL can't be directly called from the command line so we
provide a <a href="https://learn.microsoft.com/en-us/dotnet/core/tools/global-tools">.NET tool</a>,
<a href="https://www.nuget.org/packages/lucene-cli">lucene-cli</a>,
with a command that maps to that method:
lock stress-test
</section>
      <h4><a class="xref" href="Lucene.Net.Store.LockVerifyServer.html">LockVerifyServer</a></h4>
      <section><p>Simple standalone server that must be running when you
use <a class="xref" href="Lucene.Net.Store.VerifyingLockFactory.html">VerifyingLockFactory</a>.  This server simply
verifies at most one process holds the lock at a time.</p>
<p></p>
LUCENENET specific: In the Java implementation, this class' Main method
was intended to be called from the command line. However, in .NET a
method within a DLL can't be directly called from the command line so we
provide a <a href="https://learn.microsoft.com/en-us/dotnet/core/tools/global-tools">.NET tool</a>,
<a href="https://www.nuget.org/packages/lucene-cli">lucene-cli</a>,
with a command that maps to that method:
lock verify-server
</section>
      <h4><a class="xref" href="Lucene.Net.Store.MMapDirectory.html">MMapDirectory</a></h4>
      <section><p>File-based <a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a> implementation that uses
<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.io.memorymappedfiles.memorymappedfile">MemoryMappedFile</a> for reading, and
<a class="xref" href="Lucene.Net.Store.FSDirectory.FSIndexOutput.html">FSDirectory.FSIndexOutput</a> for writing.</p>
<p></p><b>NOTE</b>: memory mapping uses up a portion of the
virtual memory address space in your process equal to the
size of the file being mapped.  Before using this class,
be sure your have plenty of virtual address space, e.g. by
using a 64 bit runtime, or a 32 bit runtime with indexes that are
guaranteed to fit within the address space.
On 32 bit platforms also consult <a class="xref" href="Lucene.Net.Store.MMapDirectory.html#Lucene_Net_Store_MMapDirectory__ctor_System_IO_DirectoryInfo_Lucene_Net_Store_LockFactory_System_Int32_">MMapDirectory(DirectoryInfo, LockFactory, int)</a>
if you have problems with mmap failing because of fragmented
address space. If you get an <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.outofmemoryexception">OutOfMemoryException</a>, it is recommended
to reduce the chunk size, until it works.
<p></p><font color="red"><b>NOTE:</b> Unlike in Java, it is not recommended to use
<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.thread.interrupt">Interrupt()</a> in .NET
in conjunction with an open <a class="xref" href="Lucene.Net.Store.FSDirectory.html">FSDirectory</a> because it is not guaranteed to exit atomically.
Any <code>lock</code> statement or <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.monitor.enter#system-threading-monitor-enter(system-object)">Enter(object)</a> call can throw a
<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.threadinterruptedexception">ThreadInterruptedException</a>, which makes shutting down unpredictable.
To exit parallel tasks safely, we recommend using <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task">Task</a>s
and "interrupt" them with <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a>s.</font>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.MMapDirectory.MMapIndexInput.html">MMapDirectory.MMapIndexInput</a></h4>
      <section><!--
 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<p>Binary i/o API, used for all index data.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.MergeInfo.html">MergeInfo</a></h4>
      <section><p>A MergeInfo provides information required for a MERGE context.
It is used as part of an <a class="xref" href="Lucene.Net.Store.IOContext.html">IOContext</a> in case of MERGE context.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.NIOFSDirectory.html">NIOFSDirectory</a></h4>
      <section><p>An <a class="xref" href="Lucene.Net.Store.FSDirectory.html">FSDirectory</a> implementation that uses <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.io.filestream">FileStream</a>'s
positional read, which allows multiple threads to read from the same file
without synchronizing.</p>
<p></p>
This class only uses <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.io.filestream">FileStream</a> when reading; writing is achieved with
<a class="xref" href="Lucene.Net.Store.FSDirectory.FSIndexOutput.html">FSDirectory.FSIndexOutput</a>.
<p></p><b>NOTE</b>: Since the .NET <a class="xref" href="Lucene.Net.Store.NIOFSDirectory.html">NIOFSDirectory</a> uses additional seeking during reads,
it will generally be slightly less efficient than <a class="xref" href="Lucene.Net.Store.SimpleFSDirectory.html">SimpleFSDirectory</a>.
This class has poor concurrent read performance (multiple threads will
bottleneck) as it synchronizes when multiple threads
read from the same file. It's usually better to use
<a class="xref" href="Lucene.Net.Store.MMapDirectory.html">MMapDirectory</a> for reading.
<p></p><font color="red"><b>NOTE:</b> Unlike in Java, it is not recommended to use
<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.thread.interrupt">Interrupt()</a> in .NET
in conjunction with an open <a class="xref" href="Lucene.Net.Store.FSDirectory.html">FSDirectory</a> because it is not guaranteed to exit atomically.
Any <code>lock</code> statement or <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.monitor.enter#system-threading-monitor-enter(system-object)">Enter(object)</a> call can throw a
<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.threadinterruptedexception">ThreadInterruptedException</a>, which makes shutting down unpredictable.
To exit parallel tasks safely, we recommend using <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task">Task</a>s
and "interrupt" them with <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a>s.</font>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.NIOFSDirectory.NIOFSIndexInput.html">NIOFSDirectory.NIOFSIndexInput</a></h4>
      <section><p>Reads bytes with the <a class="xref" href="Lucene.Net.Support.IO.StreamExtensions.html#Lucene_Net_Support_IO_StreamExtensions_Read_System_IO_Stream_J2N_IO_ByteBuffer_System_Int64_">Read(Stream, ByteBuffer, long)</a>
extension method for <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.io.stream">Stream</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.NRTCachingDirectory.html">NRTCachingDirectory</a></h4>
      <section><p>Wraps a <a class="xref" href="Lucene.Net.Store.RAMDirectory.html">RAMDirectory</a>
around any provided delegate directory, to
be used during NRT search.</p>
<p>This class is likely only useful in a near-real-time
context, where indexing rate is lowish but reopen
rate is highish, resulting in many tiny files being
written.  This directory keeps such segments (as well as
the segments produced by merging them, as long as they
are small enough), in RAM.</p><p>This is safe to use: when your app calls <a class="xref" href="Lucene.Net.Index.IndexWriter.html#Lucene_Net_Index_IndexWriter_Commit">Commit()</a>,
all cached files will be flushed from the cached and sync'd.</p><p></p>Here's a simple example usage:
<pre><code class="lang-csharp">using Directory fsDir = FSDirectory.Open(new DirectoryInfo("/path/to/index"));
using NRTCachingDirectory cachedFSDir = new NRTCachingDirectory(fsDir, 5.0, 60.0);
IndexWriterConfig conf = new IndexWriterConfig(Version.LUCENE_48, analyzer);
using IndexWriter writer = new IndexWriter(cachedFSDir, conf);</code></pre><p>This will cache all newly flushed segments, all merges
<p>whose expected segment size is &lt;= 5 MB, unless the net
cached bytes exceeds 60 MB at which point all writes will
not be cached (until the net bytes falls below 60 MB).</p><p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is experimental and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Store.NativeFSLockFactory.html">NativeFSLockFactory</a></h4>
      <section><p>Implements <a class="xref" href="Lucene.Net.Store.LockFactory.html">LockFactory</a> using native OS file
 locks.  For NFS based access to an index, it's
 recommended that you try <a class="xref" href="Lucene.Net.Store.SimpleFSLockFactory.html">SimpleFSLockFactory</a>
 first and work around the one limitation that a lock file
 could be left when the runtime exits abnormally.</p>
<p>The primary benefit of <a class="xref" href="Lucene.Net.Store.NativeFSLockFactory.html">NativeFSLockFactory</a> is
 that locks (not the lock file itsself) will be properly
 removed (by the OS) if the runtime has an abnormal exit.</p>
<p>Note that, unlike <a class="xref" href="Lucene.Net.Store.SimpleFSLockFactory.html">SimpleFSLockFactory</a>, the existence of
 leftover lock files in the filesystem is fine because the OS
 will free the locks held against these files even though the
 files still remain. Lucene will never actively remove the lock
 files, so although you see them, the index may not be locked.</p>
<p>Special care needs to be taken if you change the locking
 implementation: First be certain that no writer is in fact
 writing to the index otherwise you can easily corrupt
 your index. Be sure to do the <a class="xref" href="Lucene.Net.Store.LockFactory.html">LockFactory</a> change on all Lucene
 instances and clean up all leftover lock files before starting
 the new configuration for the first time. Different implementations
 can not work together!</p>
<p>If you suspect that this or any other <a class="xref" href="Lucene.Net.Store.LockFactory.html">LockFactory</a> is
 not working properly in your environment, you can easily
 test it by using <a class="xref" href="Lucene.Net.Store.VerifyingLockFactory.html">VerifyingLockFactory</a>,
 <a class="xref" href="Lucene.Net.Store.LockVerifyServer.html">LockVerifyServer</a> and <a class="xref" href="Lucene.Net.Store.LockStressTest.html">LockStressTest</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.NoLockFactory.html">NoLockFactory</a></h4>
      <section><p>Use this <a class="xref" href="Lucene.Net.Store.LockFactory.html">LockFactory</a> to disable locking entirely.
Only one instance of this lock is created.  You should call
<a class="xref" href="Lucene.Net.Store.NoLockFactory.html#Lucene_Net_Store_NoLockFactory_GetNoLockFactory">GetNoLockFactory()</a> to get the instance.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.OutputStreamDataOutput.html">OutputStreamDataOutput</a></h4>
      <section><p>A <a class="xref" href="Lucene.Net.Store.DataOutput.html">DataOutput</a> wrapping a plain <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.io.stream">Stream</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.RAMDirectory.html">RAMDirectory</a></h4>
      <section><p>A memory-resident <a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a> implementation.  Locking
implementation is by default the <a class="xref" href="Lucene.Net.Store.SingleInstanceLockFactory.html">SingleInstanceLockFactory</a>
but can be changed with <a class="xref" href="Lucene.Net.Store.Directory.html#Lucene_Net_Store_Directory_SetLockFactory_Lucene_Net_Store_LockFactory_">SetLockFactory(LockFactory)</a>.</p>
<p></p><b>Warning:</b> This class is not intended to work with huge
indexes. Everything beyond several hundred megabytes will waste
resources (GC cycles), because it uses an internal buffer size
of 1024 bytes, producing millions of <span class="xref">byte[1024]</span> arrays.
This class is optimized for small memory-resident indexes.
It also has bad concurrency on multithreaded environments.
<p></p>It is recommended to materialize large indexes on disk and use
<a class="xref" href="Lucene.Net.Store.MMapDirectory.html">MMapDirectory</a>, which is a high-performance directory
implementation working directly on the file system cache of the
operating system, so copying data to heap space is not useful.
</section>
      <h4><a class="xref" href="Lucene.Net.Store.RAMFile.html">RAMFile</a></h4>
      <section><p>Represents a file in RAM as a list of <span class="xref">byte[]</span> buffers.</p>
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Store.RAMInputStream.html">RAMInputStream</a></h4>
      <section><p>A memory-resident <a class="xref" href="Lucene.Net.Store.IndexInput.html">IndexInput</a> implementation.</p>
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Store.RAMOutputStream.html">RAMOutputStream</a></h4>
      <section><p>A memory-resident <a class="xref" href="Lucene.Net.Store.IndexOutput.html">IndexOutput</a> implementation.</p>
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Store.RateLimitedDirectoryWrapper.html">RateLimitedDirectoryWrapper</a></h4>
      <section><p>A <a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a> wrapper that allows <a class="xref" href="Lucene.Net.Store.IndexOutput.html">IndexOutput</a> rate limiting using
IO context (<a class="xref" href="Lucene.Net.Store.IOContext.UsageContext.html">IOContext.UsageContext</a>) specific rate limiters (<a class="xref" href="Lucene.Net.Store.RateLimiter.html">RateLimiter</a>).</p>
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is experimental and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Store.RateLimiter.html">RateLimiter</a></h4>
      <section><p>Abstract base class to rate limit IO.  Typically implementations are
shared across multiple <a class="xref" href="Lucene.Net.Store.IndexInput.html">IndexInput</a>s or <a class="xref" href="Lucene.Net.Store.IndexOutput.html">IndexOutput</a>s (for example
those involved all merging).  Those <a class="xref" href="Lucene.Net.Store.IndexInput.html">IndexInput</a>s and
<a class="xref" href="Lucene.Net.Store.IndexOutput.html">IndexOutput</a>s would call <a class="xref" href="Lucene.Net.Store.RateLimiter.html#Lucene_Net_Store_RateLimiter_Pause_System_Int64_">Pause(long)</a> whenever they
want to read bytes or write bytes.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.RateLimiter.SimpleRateLimiter.html">RateLimiter.SimpleRateLimiter</a></h4>
      <section><p>Simple class to rate limit IO.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.SimpleFSDirectory.html">SimpleFSDirectory</a></h4>
      <section><p>A straightforward implementation of <a class="xref" href="Lucene.Net.Store.FSDirectory.html">FSDirectory</a>
using <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.io.filestream">FileStream</a>.</p>
<p></p><a class="xref" href="Lucene.Net.Store.FSDirectory.html">FSDirectory</a> is ideal for use cases where efficient
writing is required without utilizing too much RAM. However, reading
is less efficient than when using <a class="xref" href="Lucene.Net.Store.MMapDirectory.html">MMapDirectory</a>.
This class has poor concurrent read performance (multiple threads will
bottleneck) as it synchronizes when multiple threads
read from the same file. It's usually better to use
<a class="xref" href="Lucene.Net.Store.MMapDirectory.html">MMapDirectory</a> for reading.
<p></p><font color="red"><b>NOTE:</b> Unlike in Java, it is not recommended to use
<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.thread.interrupt">Interrupt()</a> in .NET
in conjunction with an open <a class="xref" href="Lucene.Net.Store.FSDirectory.html">FSDirectory</a> because it is not guaranteed to exit atomically.
Any <code>lock</code> statement or <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.monitor.enter#system-threading-monitor-enter(system-object)">Enter(object)</a> call can throw a
<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.threadinterruptedexception">ThreadInterruptedException</a>, which makes shutting down unpredictable.
To exit parallel tasks safely, we recommend using <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task">Task</a>s
and "interrupt" them with <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a>s.</font>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.SimpleFSDirectory.SimpleFSIndexInput.html">SimpleFSDirectory.SimpleFSIndexInput</a></h4>
      <section><p>Reads bytes with <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.io.filestream.seek">Seek(long, SeekOrigin)</a> followed by
<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.io.filestream.read#system-io-filestream-read(system-byte()-system-int32-system-int32)">Read(byte[], int, int)</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.SimpleFSLockFactory.html">SimpleFSLockFactory</a></h4>
      <section><p>Implements <a class="xref" href="Lucene.Net.Store.LockFactory.html">LockFactory</a> using 
 <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.io.file.writealltext#system-io-file-writealltext(system-string-system-string-system-text-encoding)">WriteAllText(string, string, Encoding)</a> 
 (writes the file with UTF8 encoding and no byte order mark).</p>
<p>Special care needs to be taken if you change the locking
 implementation: First be certain that no writer is in fact
 writing to the index otherwise you can easily corrupt
 your index. Be sure to do the <a class="xref" href="Lucene.Net.Store.LockFactory.html">LockFactory</a> change to all Lucene
 instances and clean up all leftover lock files before starting
 the new configuration for the first time. Different implementations
 can not work together!</p>
<p>If you suspect that this or any other <a class="xref" href="Lucene.Net.Store.LockFactory.html">LockFactory</a> is
 not working properly in your environment, you can easily
 test it by using <a class="xref" href="Lucene.Net.Store.VerifyingLockFactory.html">VerifyingLockFactory</a>, 
 <a class="xref" href="Lucene.Net.Store.LockVerifyServer.html">LockVerifyServer</a> and <a class="xref" href="Lucene.Net.Store.LockStressTest.html">LockStressTest</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.SingleInstanceLockFactory.html">SingleInstanceLockFactory</a></h4>
      <section><p>Implements <a class="xref" href="Lucene.Net.Store.LockFactory.html">LockFactory</a> for a single in-process instance,
meaning all locking will take place through this one instance.
Only use this <a class="xref" href="Lucene.Net.Store.LockFactory.html">LockFactory</a> when you are certain all
<a class="xref" href="Lucene.Net.Index.IndexReader.html">IndexReader</a>s and <a class="xref" href="Lucene.Net.Index.IndexWriter.html">IndexWriter</a>s for a given index are running
against a single shared in-process <a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a> instance.  This is
currently the default locking for <a class="xref" href="Lucene.Net.Store.RAMDirectory.html">RAMDirectory</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.TrackingDirectoryWrapper.html">TrackingDirectoryWrapper</a></h4>
      <section><p>A delegating <a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a> that records which files were
written to and deleted.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.VerifyingLockFactory.html">VerifyingLockFactory</a></h4>
      <section><p>A <a class="xref" href="Lucene.Net.Store.LockFactory.html">LockFactory</a> that wraps another
<a class="xref" href="Lucene.Net.Store.LockFactory.html">LockFactory</a> and verifies that each lock obtain/release
is &quot;correct&quot; (never results in two processes holding the
lock at the same time).  It does this by contacting an
external server (<a class="xref" href="Lucene.Net.Store.LockVerifyServer.html">LockVerifyServer</a>) to assert that
at most one process holds the lock at a time.  To use
this, you should also run <a class="xref" href="Lucene.Net.Store.LockVerifyServer.html">LockVerifyServer</a> on the
host &amp; port matching what you pass to the constructor.</p>
</section>
    <h3 id="enums">Enums
</h3>
      <h4><a class="xref" href="Lucene.Net.Store.IOContext.UsageContext.html">IOContext.UsageContext</a></h4>
      <section><p><a class="xref" href="Lucene.Net.Store.IOContext.UsageContext.html">IOContext.UsageContext</a> is a enumeration which specifies the context in which the <a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a>
is being used for.</p>
<p></p>
NOTE: This was Context in Lucene
</section>
</article>
          </div>

          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>

      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
      Copyright &copy; 2024 The Apache Software Foundation, Licensed under the <a href='http://www.apache.org/licenses/LICENSE-2.0' target='_blank'>Apache License, Version 2.0</a><br> <small>Apache Lucene.Net, Lucene.Net, Apache, the Apache feather logo, and the Apache Lucene.Net project logo are trademarks of The Apache Software Foundation. <br>All other marks mentioned may be trademarks or registered trademarks of their respective owners.</small>
      
          </div>
        </div>
      </footer>
    </div>

    <script type="text/javascript" src="https://lucenenet.apache.org/docs/4.8.0-beta00017/styles/docfx.vendor.min.js"></script>
    <script type="text/javascript" src="https://lucenenet.apache.org/docs/4.8.0-beta00017/styles/docfx.js"></script>
    <script type="text/javascript" src="https://lucenenet.apache.org/docs/4.8.0-beta00017/styles/main.js"></script>
  </body>
</html>
