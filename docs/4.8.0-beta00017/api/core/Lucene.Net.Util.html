<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Namespace Lucene.Net.Util
 | Apache Lucene.NET 4.8.0-beta00017 Documentation </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Namespace Lucene.Net.Util
 | Apache Lucene.NET 4.8.0-beta00017 Documentation ">
    <meta name="generator" content="docfx ">
  
    <link rel="shortcut icon" href="https://lucenenet.apache.org/docs/4.8.0-beta00017/logo/favicon.ico">
    <link rel="stylesheet" href="https://lucenenet.apache.org/docs/4.8.0-beta00017/styles/docfx.vendor.min.css">
    <link rel="stylesheet" href="https://lucenenet.apache.org/docs/4.8.0-beta00017/styles/docfx.css">
    <link rel="stylesheet" href="https://lucenenet.apache.org/docs/4.8.0-beta00017/styles/main.css">
    <meta property="docfx:navrel" content="toc.html">
    <meta property="docfx:tocrel" content="core/toc.html">
  
  <meta property="docfx:rel" content="https://lucenenet.apache.org/docs/4.8.0-beta00017/">
  
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <span id="forkongithub"><a href="https://github.com/apache/lucenenet" target="_blank">Fork me on GitHub</a></span>
    <div id="wrapper">
      <header>

        <nav id="autocollapse" class="navbar ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <a class="navbar-brand" href="/">
                <img id="logo" class="svg" src="https://lucenenet.apache.org/docs/4.8.0-beta00017/logo/lucene-net-color.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>

        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search">
            <ul class="level0 breadcrumb">
                <li>
                    <a href="https://lucenenet.apache.org/docs/4.8.0-beta00017/">API</a>
                     <span id="breadcrumb">
                        <ul class="breadcrumb">
                          <li></li>
                        </ul>
                    </span>   
                </li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">

        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">

        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="Lucene.Net.Util">

  <h1 id="Lucene_Net_Util" data-uid="Lucene.Net.Util" class="text-break">Namespace Lucene.Net.Util
</h1>
  <div class="markdown level0 summary"><!--
 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<p>Some utility classes.</p>
</div>
  <div class="markdown level0 conceptual"></div>
  <div class="markdown level0 remarks"></div>
    <h3 id="classes">Classes
</h3>
      <h4><a class="xref" href="Lucene.Net.Util.AlreadySetException.html">AlreadySetException</a></h4>
      <section><p>Thrown when <a class="xref" href="Lucene.Net.Util.SetOnce-1.html#Lucene_Net_Util_SetOnce_1_Set__0_">Set(T)</a> is called more than once.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.ArrayUtil.html">ArrayUtil</a></h4>
      <section><p>Methods for manipulating arrays.</p>
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.Attribute.html">Attribute</a></h4>
      <section><p>Base class for Attributes that can be added to a
<a class="xref" href="Lucene.Net.Util.AttributeSource.html">AttributeSource</a>.</p>
   <p></p>
   Attributes are used to add data in a dynamic, yet type-safe way to a source
   of usually streamed objects, e. g. a <a class="xref" href="Lucene.Net.Analysis.TokenStream.html">TokenStream</a>.
</section>
      <h4><a class="xref" href="Lucene.Net.Util.AttributeSource.html">AttributeSource</a></h4>
      <section><p>An <a class="xref" href="Lucene.Net.Util.AttributeSource.html">AttributeSource</a> contains a list of different <a class="xref" href="Lucene.Net.Util.Attribute.html">Attribute</a>s,
and methods to add and get them. There can only be a single instance
of an attribute in the same <a class="xref" href="Lucene.Net.Util.AttributeSource.html">AttributeSource</a> instance. This is ensured
by passing in the actual type of the <a class="xref" href="Lucene.Net.Util.IAttribute.html">IAttribute</a> to
the <a class="xref" href="Lucene.Net.Util.AttributeSource.html#Lucene_Net_Util_AttributeSource_AddAttribute__1">AddAttribute&lt;T&gt;()</a>, which then checks if an instance of
that type is already present. If yes, it returns the instance, otherwise
it creates a new instance and returns it.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.AttributeSource.AttributeFactory.html">AttributeSource.AttributeFactory</a></h4>
      <section><p>An <a class="xref" href="Lucene.Net.Util.AttributeSource.AttributeFactory.html">AttributeSource.AttributeFactory</a> creates instances of <a class="xref" href="Lucene.Net.Util.Attribute.html">Attribute</a>s.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.AttributeSource.State.html">AttributeSource.State</a></h4>
      <section><p>This class holds the state of an <a class="xref" href="Lucene.Net.Util.AttributeSource.html">AttributeSource</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.BitUtil.html">BitUtil</a></h4>
      <section><p>A variety of high efficiency bit twiddling routines.</p>
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.Bits.html">Bits</a></h4>
      <section><!--
 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<p>Some utility classes.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.Bits.MatchAllBits.html">Bits.MatchAllBits</a></h4>
      <section><p>Bits impl of the specified length with all bits set.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.Bits.MatchNoBits.html">Bits.MatchNoBits</a></h4>
      <section><p>Bits impl of the specified length with no bits set.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.BroadWord.html">BroadWord</a></h4>
      <section><p>Methods and constants inspired by the article
&quot;Broadword Implementation of Rank/Select Queries&quot; by Sebastiano Vigna, January 30, 2012:</p>
<ul><li>algorithm 1: <a class="xref" href="Lucene.Net.Util.BroadWord.html#Lucene_Net_Util_BroadWord_BitCount_System_Int64_">BitCount(long)</a>, count of set bits in a <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int64">long</a></li><li>algorithm 2: <a class="xref" href="Lucene.Net.Util.BroadWord.html#Lucene_Net_Util_BroadWord_Select_System_Int64_System_Int32_">Select(long, int)</a>, selection of a set bit in a <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int64">long</a>,</li><li>bytewise signed smaller &lt;<sub><small>8</small></sub> operator: <a class="xref" href="Lucene.Net.Util.BroadWord.html#Lucene_Net_Util_BroadWord_SmallerUpTo7_8_System_Int64_System_Int64_">SmallerUpTo7_8(long, long)</a>.</li><li>shortwise signed smaller &lt;<sub><small>16</small></sub> operator: <a class="xref" href="Lucene.Net.Util.BroadWord.html#Lucene_Net_Util_BroadWord_SmallerUpto15_16_System_Int64_System_Int64_">SmallerUpto15_16(long, long)</a>.</li><li>some of the Lk and Hk constants that are used by the above:
        L8 <a class="xref" href="Lucene.Net.Util.BroadWord.html#Lucene_Net_Util_BroadWord_L8_L">L8_L</a>, H8 <a class="xref" href="Lucene.Net.Util.BroadWord.html#Lucene_Net_Util_BroadWord_H8_L">H8_L</a>, L9 <a class="xref" href="Lucene.Net.Util.BroadWord.html#Lucene_Net_Util_BroadWord_L9_L">L9_L</a>, L16 <a class="xref" href="Lucene.Net.Util.BroadWord.html#Lucene_Net_Util_BroadWord_L16_L">L16_L</a>and H16 <a class="xref" href="Lucene.Net.Util.BroadWord.html#Lucene_Net_Util_BroadWord_H8_L">H8_L</a>.</li></ul>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.ByteBlockPool.html">ByteBlockPool</a></h4>
      <section><p>Class that Posting and PostingVector use to write byte
streams into shared fixed-size <span class="xref">byte[]</span> arrays.  The idea
is to allocate slices of increasing lengths. For
example, the first slice is 5 bytes, the next slice is
14, etc.  We start by writing our bytes into the first
5 bytes.  When we hit the end of the slice, we allocate
the next slice and then write the address of the new
slice into the last 4 bytes of the previous slice (the
&quot;forwarding address&quot;).</p>
<p></p>
Each slice is filled with 0's initially, and we mark
the end with a non-zero byte.  This way the methods
that are writing into the slice don't need to record
its length and instead allocate a new slice once they
hit a non-zero byte.
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.ByteBlockPool.Allocator.html">ByteBlockPool.Allocator</a></h4>
      <section><p>Abstract class for allocating and freeing byte
blocks.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.ByteBlockPool.DirectAllocator.html">ByteBlockPool.DirectAllocator</a></h4>
      <section><p>A simple <a class="xref" href="Lucene.Net.Util.ByteBlockPool.Allocator.html">ByteBlockPool.Allocator</a> that never recycles.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.ByteBlockPool.DirectTrackingAllocator.html">ByteBlockPool.DirectTrackingAllocator</a></h4>
      <section><p>A simple <a class="xref" href="Lucene.Net.Util.ByteBlockPool.Allocator.html">ByteBlockPool.Allocator</a> that never recycles, but
tracks how much total RAM is in use.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.BytesRef.html">BytesRef</a></h4>
      <section><p>Represents <span class="xref">byte[]</span>, as a slice (offset + length) into an
existing <span class="xref">byte[]</span>.  The <a class="xref" href="Lucene.Net.Util.BytesRef.html#Lucene_Net_Util_BytesRef_Bytes">Bytes</a> property should never be <code>null</code>;
use <a class="xref" href="Lucene.Net.Util.BytesRef.html#Lucene_Net_Util_BytesRef_EMPTY_BYTES">EMPTY_BYTES</a> if necessary.</p>
<p></p><b>Important note:</b> Unless otherwise noted, Lucene uses this class to
represent terms that are encoded as <b>UTF8</b> bytes in the index. To
convert them to a .NET <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a> (which is UTF16), use <a class="xref" href="Lucene.Net.Util.BytesRef.html#Lucene_Net_Util_BytesRef_Utf8ToString">Utf8ToString()</a>.
Using code like <code>new String(bytes, offset, length)</code> to do this
is <b>wrong</b>, as it does not respect the correct character set
and may return wrong results (depending on the platform's defaults)!
</section>
      <h4><a class="xref" href="Lucene.Net.Util.BytesRefArray.html">BytesRefArray</a></h4>
      <section><p>A simple append only random-access <a class="xref" href="Lucene.Net.Util.BytesRef.html">BytesRef</a> array that stores full
copies of the appended bytes in a <a class="xref" href="Lucene.Net.Util.ByteBlockPool.html">ByteBlockPool</a>.</p>
<p></p><b>Note: this class is not Thread-Safe!</b><p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

<div class="NOTE">
<h5>Note</h5>
<p>This API is experimental and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.BytesRefEnumerator.html">BytesRefEnumerator</a></h4>
      <section><p>LUCENENET specific class to make the syntax of creating an empty
<a class="xref" href="Lucene.Net.Util.IBytesRefEnumerator.html">IBytesRefEnumerator</a> the same as it was in Lucene. Example:</p>
<pre><code class="lang-csharp">var iter = BytesRefEnumerator.EMPTY;</code></pre>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.BytesRefHash.html">BytesRefHash</a></h4>
      <section><p><a class="xref" href="Lucene.Net.Util.BytesRefHash.html">BytesRefHash</a> is a special purpose hash-map like data-structure
optimized for <a class="xref" href="Lucene.Net.Util.BytesRef.html">BytesRef</a> instances. <a class="xref" href="Lucene.Net.Util.BytesRefHash.html">BytesRefHash</a> maintains mappings of
byte arrays to ids (Map&lt;BytesRef,int&gt;) storing the hashed bytes
efficiently in continuous storage. The mapping to the id is
encapsulated inside <a class="xref" href="Lucene.Net.Util.BytesRefHash.html">BytesRefHash</a> and is guaranteed to be increased
for each added <a class="xref" href="Lucene.Net.Util.BytesRef.html">BytesRef</a>.</p>
 <p>
 Note: The maximum capacity <a class="xref" href="Lucene.Net.Util.BytesRef.html">BytesRef</a> instance passed to
 <a class="xref" href="Lucene.Net.Util.BytesRefHash.html#Lucene_Net_Util_BytesRefHash_Add_Lucene_Net_Util_BytesRef_">Add(BytesRef)</a> must not be longer than <a class="xref" href="Lucene.Net.Util.ByteBlockPool.html#Lucene_Net_Util_ByteBlockPool_BYTE_BLOCK_SIZE">BYTE_BLOCK_SIZE</a>-2.
 The internal storage is limited to 2GB total byte storage.
 </p>
<p><div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>
</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.BytesRefHash.BytesStartArray.html">BytesRefHash.BytesStartArray</a></h4>
      <section><p>Manages allocation of the per-term addresses.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.BytesRefHash.DirectBytesStartArray.html">BytesRefHash.DirectBytesStartArray</a></h4>
      <section><p>A simple <a class="xref" href="Lucene.Net.Util.BytesRefHash.BytesStartArray.html">BytesRefHash.BytesStartArray</a> that tracks
memory allocation using a private <a class="xref" href="Lucene.Net.Util.Counter.html">Counter</a>
instance.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.BytesRefHash.MaxBytesLengthExceededException.html">BytesRefHash.MaxBytesLengthExceededException</a></h4>
      <section><p>Thrown if a <a class="xref" href="Lucene.Net.Util.BytesRef.html">BytesRef</a> exceeds the <a class="xref" href="Lucene.Net.Util.BytesRefHash.html">BytesRefHash</a> limit of
<a class="xref" href="Lucene.Net.Util.ByteBlockPool.html#Lucene_Net_Util_ByteBlockPool_BYTE_BLOCK_SIZE">BYTE_BLOCK_SIZE</a>-2.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.CharsRef.html">CharsRef</a></h4>
      <section><p>Represents <span class="xref">char[]</span>, as a slice (offset + Length) into an existing <span class="xref">char[]</span>.
The <a class="xref" href="Lucene.Net.Util.CharsRef.html#Lucene_Net_Util_CharsRef_Chars">Chars</a> property should never be <code>null</code>; use
<a class="xref" href="Lucene.Net.Util.CharsRef.html#Lucene_Net_Util_CharsRef_EMPTY_CHARS">EMPTY_CHARS</a> if necessary.</p>
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.CollectionUtil.html">CollectionUtil</a></h4>
      <section><p>Methods for manipulating (sorting) collections.
Sort methods work directly on the supplied lists and don't copy to/from arrays
before/after. For medium size collections as used in the Lucene indexer that is
much more efficient.</p>
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.CommandLineUtil.html">CommandLineUtil</a></h4>
      <section><p>Class containing some useful methods used by command line tools</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.Constants.html">Constants</a></h4>
      <section><p>Some useful constants.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.Counter.html">Counter</a></h4>
      <section><p>Simple counter class</p>
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

<div class="NOTE">
<h5>Note</h5>
<p>This API is experimental and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.DisposableThreadLocal-1.html">DisposableThreadLocal&lt;T&gt;</a></h4>
      <section><p>.NET's built-in <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.threadlocal-1">ThreadLocal&lt;T&gt;</a> has a serious flaw:
internally, it creates an array with an internal lattice structure
which in turn causes the garbage collector to cause long blocking pauses
when tearing the structure down. See
<a href="https://ayende.com/blog/189761-A/production-postmortem-the-slow-slowdown-of-large-systems">
https://ayende.com/blog/189761-A/production-postmortem-the-slow-slowdown-of-large-systems</a>
for a more detailed explanation.</p>
<p></p>
This is a completely different problem than in Java which the ClosableThreadLocal&lt;T&gt; class is
meant to solve, so <a class="xref" href="Lucene.Net.Util.DisposableThreadLocal-1.html">DisposableThreadLocal&lt;T&gt;</a> is specific to Lucene.NET and can be used
as a direct replacement for ClosableThreadLocal&lt;T&gt;.
<p></p>
This class works around the issue by using an alternative approach than using <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.threadlocal-1">ThreadLocal&lt;T&gt;</a>.
It keeps track of each thread's local and global state in order to later optimize garbage collection.
A complete explanation can be found at 
<a href="https://ayende.com/blog/189793-A/the-design-and-implementation-of-a-better-threadlocal-t">
https://ayende.com/blog/189793-A/the-design-and-implementation-of-a-better-threadlocal-t</a>.
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.DocIdBitSet.html">DocIdBitSet</a></h4>
      <section><p>Simple <a class="xref" href="Lucene.Net.Search.DocIdSet.html">DocIdSet</a> and <a class="xref" href="Lucene.Net.Search.DocIdSetIterator.html">DocIdSetIterator</a> backed by a <a class="xref" href="Lucene.Net.Util.DocIdBitSet.html#Lucene_Net_Util_DocIdBitSet_BitSet">BitSet</a></p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.DoubleBarrelLRUCache.html">DoubleBarrelLRUCache</a></h4>
      <section><p>LUCENENET specific class to nest the <a class="xref" href="Lucene.Net.Util.DoubleBarrelLRUCache.CloneableKey.html">DoubleBarrelLRUCache.CloneableKey</a>
so it can be accessed without referencing the generic closing types
of <a class="xref" href="Lucene.Net.Util.DoubleBarrelLRUCache-2.html">DoubleBarrelLRUCache&lt;TKey, TValue&gt;</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.DoubleBarrelLRUCache.CloneableKey.html">DoubleBarrelLRUCache.CloneableKey</a></h4>
      <section><p>Object providing clone(); the key class must subclass this.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.DoubleBarrelLRUCache-2.html">DoubleBarrelLRUCache&lt;TKey, TValue&gt;</a></h4>
      <section><p>Simple concurrent LRU cache, using a &quot;double barrel&quot;
approach where two ConcurrentHashMaps record entries.</p>
<p>At any given time, one hash is primary and the other
is secondary.  <a class="xref" href="Lucene.Net.Util.DoubleBarrelLRUCache-2.html#Lucene_Net_Util_DoubleBarrelLRUCache_2_Get__0_">Get(TKey)</a> first checks primary, and if
that's a miss, checks secondary.  If secondary has the
entry, it's promoted to primary (<b>NOTE</b>: the key is
cloned at this point).  Once primary is full, the
secondary is cleared and the two are swapped.</p><p>This is not as space efficient as other possible
concurrent approaches (see LUCENE-2075): to achieve
perfect LRU(N) it requires 2*N storage.  But, this
approach is relatively simple and seems in practice to
not grow unbounded in size when under hideously high
load.</p>
<p><div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>
</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.ExceptionExtensions.html">ExceptionExtensions</a></h4>
      <section><p>Extensions to the <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.exception">Exception</a> class to allow for
adding and retrieving suppressed exceptions, like you can do in Java.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.ExcludeFromRamUsageEstimationAttribute.html">ExcludeFromRamUsageEstimationAttribute</a></h4>
      <section><p>Marks a field exempt from the <a class="xref" href="Lucene.Net.Util.RamUsageEstimator.html#Lucene_Net_Util_RamUsageEstimator_SizeOf_System_Object_">SizeOf(object)</a> calculation.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.ExcludeServiceAttribute.html">ExcludeServiceAttribute</a></h4>
      <section><p>Base class for <a class="xref" href="Lucene.Net.Util.Attribute.html">Attribute</a> types that exclude services from Reflection scanning.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.FieldCacheSanityChecker.html">FieldCacheSanityChecker</a></h4>
      <section><p>
Provides methods for sanity checking that entries in the FieldCache
are not wasteful or inconsistent.
</p>
<p>
Lucene 2.9 Introduced numerous enhancements into how the FieldCache
is used by the low levels of Lucene searching (for Sorting and
ValueSourceQueries) to improve both the speed for Sorting, as well
as reopening of IndexReaders.  But these changes have shifted the
usage of FieldCache from "top level" IndexReaders (frequently a
MultiReader or DirectoryReader) down to the leaf level SegmentReaders.
As a result, existing applications that directly access the FieldCache
may find RAM usage increase significantly when upgrading to 2.9 or
Later.  This class provides an API for these applications (or their
Unit tests) to check at run time if the FieldCache contains "insane"
usages of the FieldCache.
</p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is experimental and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.FieldCacheSanityChecker.Insanity.html">FieldCacheSanityChecker.Insanity</a></h4>
      <section><p>Simple container for a collection of related <a class="xref" href="Lucene.Net.Search.FieldCache.CacheEntry.html">FieldCache.CacheEntry</a> objects that
in conjunction with each other represent some &quot;insane&quot; usage of the
<a class="xref" href="Lucene.Net.Search.IFieldCache.html">IFieldCache</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.FieldCacheSanityChecker.InsanityType.html">FieldCacheSanityChecker.InsanityType</a></h4>
      <section><p>An Enumeration of the different types of &quot;insane&quot; behavior that
may be detected in a <a class="xref" href="Lucene.Net.Search.IFieldCache.html">IFieldCache</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.FilterEnumerator-1.html">FilterEnumerator&lt;T&gt;</a></h4>
      <section><p>An <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.collections.generic.ienumerator-1">IEnumerator&lt;T&gt;</a> implementation that filters elements with a boolean predicate.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.FixedBitSet.html">FixedBitSet</a></h4>
      <section><p>BitSet of fixed length (numBits), backed by accessible (<a class="xref" href="Lucene.Net.Util.FixedBitSet.html#Lucene_Net_Util_FixedBitSet_GetBits">GetBits()</a>)
long[], accessed with an int index, implementing <a class="xref" href="Lucene.Net.Util.FixedBitSet.html#Lucene_Net_Util_FixedBitSet_GetBits">GetBits()</a> and
<a class="xref" href="Lucene.Net.Search.DocIdSet.html">DocIdSet</a>. If you need to manage more than 2.1B bits, use
<a class="xref" href="Lucene.Net.Util.Int64BitSet.html">Int64BitSet</a>.</p>
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.FixedBitSet.FixedBitSetIterator.html">FixedBitSet.FixedBitSetIterator</a></h4>
      <section><p>A <a class="xref" href="Lucene.Net.Search.DocIdSetIterator.html">DocIdSetIterator</a> which iterates over set bits in a
<a class="xref" href="Lucene.Net.Util.FixedBitSet.html">FixedBitSet</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.FixedBitSetExtensions.html">FixedBitSetExtensions</a></h4>
      <section><!--
 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<p>Some utility classes.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.GrowableByteArrayDataOutput.html">GrowableByteArrayDataOutput</a></h4>
      <section><p>A <a class="xref" href="Lucene.Net.Store.DataOutput.html">DataOutput</a> that can be used to build a <span class="xref">byte[]</span>.</p>
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.IOUtils.html">IOUtils</a></h4>
      <section><p>This class emulates the new Java 7 &quot;Try-With-Resources&quot; statement.
Remove once Lucene is on Java 7.</p>
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.InPlaceMergeSorter.html">InPlaceMergeSorter</a></h4>
      <section><p><a class="xref" href="Lucene.Net.Util.Sorter.html">Sorter</a> implementation based on the merge-sort algorithm that merges
in place (no extra memory will be allocated). Small arrays are sorted with
insertion sort.</p>
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.IndexableBinaryStringTools.html">IndexableBinaryStringTools</a></h4>
      <section><p>Provides support for converting byte sequences to <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a>s and back again.
The resulting <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a>s preserve the original byte sequences' sort order.</p>
<p></p>
The <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a>s are constructed using a Base 8000h encoding of the original
binary data - each char of an encoded <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a> represents a 15-bit chunk
from the byte sequence.  Base 8000h was chosen because it allows for all
lower 15 bits of char to be used without restriction; the surrogate range
[U+D8000-U+DFFF] does not represent valid chars, and would require
complicated handling to avoid them and allow use of char's high bit.
<p></p>
Although unset bits are used as padding in the final char, the original
byte sequence could contain trailing bytes with no set bits (null bytes):
padding is indistinguishable from valid information.  To overcome this
problem, a char is appended, indicating the number of encoded bytes in the
final content char.
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is experimental and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.InfoStream.html">InfoStream</a></h4>
      <section><p>Debugging API for Lucene classes such as <a class="xref" href="Lucene.Net.Index.IndexWriter.html">IndexWriter</a>
and <a class="xref" href="Lucene.Net.Index.SegmentInfos.html">SegmentInfos</a>.</p>
<p>
NOTE: Enabling infostreams may cause performance degradation
in some components.
</p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.Int32BlockPool.html">Int32BlockPool</a></h4>
      <section><p>A pool for <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a> blocks similar to <a class="xref" href="Lucene.Net.Util.ByteBlockPool.html">ByteBlockPool</a>.</p>
<p></p>
NOTE: This was IntBlockPool in Lucene
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.Int32BlockPool.Allocator.html">Int32BlockPool.Allocator</a></h4>
      <section><p>Abstract class for allocating and freeing <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a>
blocks.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.Int32BlockPool.DirectAllocator.html">Int32BlockPool.DirectAllocator</a></h4>
      <section><p>A simple <a class="xref" href="Lucene.Net.Util.Int32BlockPool.Allocator.html">Int32BlockPool.Allocator</a> that never recycles.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.Int32BlockPool.SliceReader.html">Int32BlockPool.SliceReader</a></h4>
      <section><p>A <a class="xref" href="Lucene.Net.Util.Int32BlockPool.SliceReader.html">Int32BlockPool.SliceReader</a> that can read <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a> slices written by a <a class="xref" href="Lucene.Net.Util.Int32BlockPool.SliceWriter.html">Int32BlockPool.SliceWriter</a>.</p>
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.Int32BlockPool.SliceWriter.html">Int32BlockPool.SliceWriter</a></h4>
      <section><p>A <a class="xref" href="Lucene.Net.Util.Int32BlockPool.SliceWriter.html">Int32BlockPool.SliceWriter</a> that allows to write multiple integer slices into a given <a class="xref" href="Lucene.Net.Util.Int32BlockPool.html">Int32BlockPool</a>.</p>
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.Int32sRef.html">Int32sRef</a></h4>
      <section><p>Represents <span class="xref">int[]</span>, as a slice (offset + length) into an
existing <span class="xref">int[]</span>.  The <a class="xref" href="Lucene.Net.Util.Int32sRef.html#Lucene_Net_Util_Int32sRef_Int32s">Int32s</a> member should never be <code>null</code>; use
<a class="xref" href="Lucene.Net.Util.Int32sRef.html#Lucene_Net_Util_Int32sRef_EMPTY_INT32S">EMPTY_INT32S</a> if necessary.</p>
<p></p>
NOTE: This was IntsRef in Lucene
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.Int64BitSet.html">Int64BitSet</a></h4>
      <section><p>BitSet of fixed length (<a class="xref" href="Lucene.Net.Util.Int64BitSet.html#Lucene_Net_Util_Int64BitSet_numBits">numBits</a>), backed by accessible (<a class="xref" href="Lucene.Net.Util.Int64BitSet.html#Lucene_Net_Util_Int64BitSet_GetBits">GetBits()</a>)
<span class="xref">long[]</span>, accessed with a <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int64">long</a> index. Use it only if you intend to store more
than 2.1B bits, otherwise you should use <a class="xref" href="Lucene.Net.Util.FixedBitSet.html">FixedBitSet</a>.</p>
<p></p>
NOTE: This was LongBitSet in Lucene
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.Int64BitSetExtensions.html">Int64BitSetExtensions</a></h4>
      <section><!--
 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<p>Some utility classes.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.Int64Values.html">Int64Values</a></h4>
      <section><p>Abstraction over an array of <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int64">long</a>s.
This class extends <a class="xref" href="Lucene.Net.Index.NumericDocValues.html">NumericDocValues</a> so that we don't need to add another
level of abstraction every time we want eg. to use the <a class="xref" href="Lucene.Net.Util.Packed.PackedInt32s.html">PackedInt32s</a>
utility classes to represent a <a class="xref" href="Lucene.Net.Index.NumericDocValues.html">NumericDocValues</a> instance.</p>
<p></p>
NOTE: This was LongValues in Lucene
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.Int64sRef.html">Int64sRef</a></h4>
      <section><p>Represents <span class="xref">long[]</span>, as a slice (offset + length) into an
existing <span class="xref">long[]</span>.  The <a class="xref" href="Lucene.Net.Util.Int64sRef.html#Lucene_Net_Util_Int64sRef_Int64s">Int64s</a> member should never be <code>null</code>; use
<a class="xref" href="Lucene.Net.Util.Int64sRef.html#Lucene_Net_Util_Int64sRef_EMPTY_INT64S">EMPTY_INT64S</a> if necessary.</p>
<p></p>
NOTE: This was LongsRef in Lucene
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.IntroSorter.html">IntroSorter</a></h4>
      <section><p><a class="xref" href="Lucene.Net.Util.Sorter.html">Sorter</a> implementation based on a variant of the quicksort algorithm
called <a href="http://en.wikipedia.org/wiki/Introsort">introsort</a>: when
the recursion level exceeds the log of the length of the array to sort, it
falls back to heapsort. This prevents quicksort from running into its
worst-case quadratic runtime. Small arrays are sorted with
insertion sort.</p>
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.ListExtensions.html">ListExtensions</a></h4>
      <section><p>Extensions to <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.collections.generic.ilist-1">IList&lt;T&gt;</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.LuceneVersionExtensions.html">LuceneVersionExtensions</a></h4>
      <section><p>Extension methods to the <a class="xref" href="Lucene.Net.Util.LuceneVersion.html">LuceneVersion</a> enumeration to provide
version comparison and parsing functionality.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.MapOfSets-2.html">MapOfSets&lt;TKey, TValue&gt;</a></h4>
      <section><p>Helper class for keeping Lists of Objects associated with keys. <b>WARNING: this CLASS IS NOT THREAD SAFE</b><p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.MathUtil.html">MathUtil</a></h4>
      <section><p>Math static utility methods.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.MergedEnumerator-1.html">MergedEnumerator&lt;T&gt;</a></h4>
      <section><p>Provides a merged sorted view from several sorted iterators.</p>
<p></p>
If built with <a class="xref" href="Lucene.Net.Util.MergedEnumerator-1.html#Lucene_Net_Util_MergedEnumerator_1_removeDuplicates">removeDuplicates</a> set to <code>true</code> and an element
appears in multiple iterators then it is deduplicated, that is this iterator
returns the sorted union of elements.
<p></p>
If built with <a class="xref" href="Lucene.Net.Util.MergedEnumerator-1.html#Lucene_Net_Util_MergedEnumerator_1_removeDuplicates">removeDuplicates</a> set to <code>false</code> then all elements
in all iterators are returned.
<p></p>
Caveats:
<ul><li>The behavior is undefined if the iterators are not actually sorted.</li><li>Null elements are unsupported.</li><li>If <a class="xref" href="Lucene.Net.Util.MergedEnumerator-1.html#Lucene_Net_Util_MergedEnumerator_1_removeDuplicates">removeDuplicates</a> is set to <code>true</code> and if a single iterator contains
      duplicates then they will not be deduplicated.</li><li>When elements are deduplicated it is not defined which one is returned.</li><li>If <a class="xref" href="Lucene.Net.Util.MergedEnumerator-1.html#Lucene_Net_Util_MergedEnumerator_1_removeDuplicates">removeDuplicates</a> is set to <code>false</code> then the order in which duplicates
      are returned isn't defined.</li></ul><p></p>
The caller is responsible for disposing the <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.collections.generic.ienumerator-1">IEnumerator&lt;T&gt;</a> instances that are passed
into the constructor, <a class="xref" href="Lucene.Net.Util.MergedEnumerator-1.html">MergedEnumerator&lt;T&gt;</a> doesn't do it automatically.
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.NamedServiceFactory-1.html">NamedServiceFactory&lt;TService&gt;</a></h4>
      <section><p>LUCENENET specific abstract class containing common fuctionality for named service factories.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.NumberFormat.html">NumberFormat</a></h4>
      <section><p>A LUCENENET specific class that represents a numeric format. This class
mimicks the design of Java's NumberFormat class, which unlike the
<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.globalization.numberformatinfo">NumberFormatInfo</a> class in .NET, can be subclassed.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.NumericUtils.html">NumericUtils</a></h4>
      <section><p>This is a helper class to generate prefix-encoded representations for numerical values
and supplies converters to represent float/double values as sortable integers/longs.</p>
<p></p>To quickly execute range queries in Apache Lucene, a range is divided recursively
into multiple intervals for searching: The center of the range is searched only with
the lowest possible precision in the trie, while the boundaries are matched
more exactly. this reduces the number of terms dramatically.
<p></p>This class generates terms to achieve this: First the numerical integer values need to
be converted to bytes. For that integer values (32 bit or 64 bit) are made unsigned
and the bits are converted to ASCII chars with each 7 bit. The resulting byte[] is
sortable like the original integer value (even using UTF-8 sort order). Each value is also
prefixed (in the first char) by the <code>shift</code> value (number of bits removed) used
during encoding.
<p></p>To also index floating point numbers, this class supplies two methods to convert them
to integer values by changing their bit layout: <a class="xref" href="Lucene.Net.Util.NumericUtils.html#Lucene_Net_Util_NumericUtils_DoubleToSortableInt64_System_Double_">DoubleToSortableInt64(double)</a>,
<a class="xref" href="Lucene.Net.Util.NumericUtils.html#Lucene_Net_Util_NumericUtils_SingleToSortableInt32_System_Single_">SingleToSortableInt32(float)</a>. You will have no precision loss by
converting floating point numbers to integers and back (only that the integer form
is not usable). Other data types like dates can easily converted to <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int64">long</a>s or <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a>s (e.g.
date to long: <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.datetime.ticks">Ticks</a>).
<p></p>For easy usage, the trie algorithm is implemented for indexing inside
<a class="xref" href="Lucene.Net.Analysis.NumericTokenStream.html">NumericTokenStream</a> that can index <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a>, <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int64">long</a>,
<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.single">float</a>, and <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.double">double</a>. For querying,
<a class="xref" href="Lucene.Net.Search.NumericRangeQuery.html">NumericRangeQuery</a> and <a class="xref" href="Lucene.Net.Search.NumericRangeFilter.html">NumericRangeFilter</a> implement the query part
for the same data types.
<p></p>This class can also be used, to generate lexicographically sortable (according to
<a class="xref" href="Lucene.Net.Util.BytesRef.html#Lucene_Net_Util_BytesRef_UTF8SortedAsUTF16Comparer">UTF8SortedAsUTF16Comparer</a>) representations of numeric data
types for other usages (e.g. sorting).
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

@since 2.9, API changed non backwards-compliant in 4.0
</section>
      <h4><a class="xref" href="Lucene.Net.Util.NumericUtils.Int32RangeBuilder.html">NumericUtils.Int32RangeBuilder</a></h4>
      <section><p>Callback for <a class="xref" href="Lucene.Net.Util.NumericUtils.html#Lucene_Net_Util_NumericUtils_SplitInt32Range_Lucene_Net_Util_NumericUtils_Int32RangeBuilder_System_Int32_System_Int32_System_Int32_">SplitInt32Range(Int32RangeBuilder, int, int, int)</a>.
You need to override only one of the methods.</p>
<p></p>
NOTE: This was IntRangeBuilder in Lucene
<p><div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

@since 2.9, API changed non backwards-compliant in 4.0</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.NumericUtils.Int64RangeBuilder.html">NumericUtils.Int64RangeBuilder</a></h4>
      <section><p>Callback for <a class="xref" href="Lucene.Net.Util.NumericUtils.html#Lucene_Net_Util_NumericUtils_SplitInt64Range_Lucene_Net_Util_NumericUtils_Int64RangeBuilder_System_Int32_System_Int64_System_Int64_">SplitInt64Range(Int64RangeBuilder, int, long, long)</a>.
You need to override only one of the methods.</p>
<p></p>
NOTE: This was LongRangeBuilder in Lucene
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

@since 2.9, API changed non backwards-compliant in 4.0
</section>
      <h4><a class="xref" href="Lucene.Net.Util.OfflineSorter.html">OfflineSorter</a></h4>
      <section><p>On-disk sorting of byte arrays. Each byte array (entry) is a composed of the following
fields:</p>
<ul><li>(two bytes) length of the following byte array,</li><li>exactly the above count of bytes for the sequence to be sorted.</li></ul>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.OfflineSorter.BufferSize.html">OfflineSorter.BufferSize</a></h4>
      <section><p>A bit more descriptive unit for constructors.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.OfflineSorter.ByteSequencesReader.html">OfflineSorter.ByteSequencesReader</a></h4>
      <section><p>Utility class to read length-prefixed <span class="xref">byte[]</span> entries from an input.
Complementary to <a class="xref" href="Lucene.Net.Util.OfflineSorter.ByteSequencesWriter.html">OfflineSorter.ByteSequencesWriter</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.OfflineSorter.ByteSequencesWriter.html">OfflineSorter.ByteSequencesWriter</a></h4>
      <section><p>Utility class to emit length-prefixed <span class="xref">byte[]</span> entries to an output stream for sorting.
Complementary to <a class="xref" href="Lucene.Net.Util.OfflineSorter.ByteSequencesReader.html">OfflineSorter.ByteSequencesReader</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.OfflineSorter.SortInfo.html">OfflineSorter.SortInfo</a></h4>
      <section><p>Sort info (debugging mostly).</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.OpenBitSet.html">OpenBitSet</a></h4>
      <section><p>An &quot;open&quot; BitSet implementation that allows direct access to the array of words
storing the bits.</p>
<p></p>
NOTE: This can be used in .NET any place where a <code>java.util.BitSet</code> is used in Java.
<p></p>
Unlike <code>java.util.BitSet</code>, the fact that bits are packed into an array of longs
is part of the interface.  This allows efficient implementation of other algorithms
by someone other than the author.  It also allows one to efficiently implement
alternate serialization or interchange formats.
<p></p><a class="xref" href="Lucene.Net.Util.OpenBitSet.html">OpenBitSet</a> is faster than <code>java.util.BitSet</code> in most operations
and *much* faster at calculating cardinality of sets and results of set operations.
It can also handle sets of larger cardinality (up to 64 * 2**32-1)
<p></p>
The goals of <a class="xref" href="Lucene.Net.Util.OpenBitSet.html">OpenBitSet</a> are the fastest implementation possible, and
maximum code reuse.  Extra safety and encapsulation
may always be built on top, but if that's built in, the cost can never be removed (and
hence people re-implement their own version in order to get better performance).
<p></p><h3>Performance Results</h3>
<p>Test system: Pentium 4, Sun Java 1.5_06 -server -Xbatch -Xmx64M</p>
<p></p>BitSet size = 1,000,000
<p></p>Results are java.util.BitSet time divided by OpenBitSet time.
<table><thead><tr><th class="term"></th><th class="term">cardinality</th><th class="term">IntersectionCount</th><th class="term">Union</th><th class="term">NextSetBit</th><th class="term">Get</th><th class="term">GetIterator</th></tr></thead><tbody><tr><td class="term">50% full</td><td class="description">3.36</td><td class="description">3.96</td><td class="description">1.44</td><td class="description">1.46</td><td class="description">1.99</td><td class="description">1.58</td></tr><tr><td class="term">1% full</td><td class="description">3.31</td><td class="description">3.90</td><td class="description"> </td><td class="description">1.04</td><td class="description"> </td><td class="description">0.99</td></tr></tbody></table><p></p><p></p>
Test system: AMD Opteron, 64 bit linux, Sun Java 1.5_06 -server -Xbatch -Xmx64M
<p></p>BitSet size = 1,000,000
<p></p>Results are java.util.BitSet time divided by OpenBitSet time.
<table><thead><tr><th class="term"></th><th class="term">cardinality</th><th class="term">IntersectionCount</th><th class="term">Union</th><th class="term">NextSetBit</th><th class="term">Get</th><th class="term">GetIterator</th></tr></thead><tbody><tr><td class="term">50% full</td><td class="description">2.50</td><td class="description">3.50</td><td class="description">1.00</td><td class="description">1.03</td><td class="description">1.12</td><td class="description">1.25</td></tr><tr><td class="term">1% full</td><td class="description">2.51</td><td class="description">3.49</td><td class="description"> </td><td class="description">1.00</td><td class="description"> </td><td class="description">1.02</td></tr></tbody></table>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.OpenBitSetDISI.html">OpenBitSetDISI</a></h4>
      <section><p><a class="xref" href="Lucene.Net.Util.OpenBitSet.html">OpenBitSet</a> with added methods to bulk-update the bits
from a <a class="xref" href="Lucene.Net.Search.DocIdSetIterator.html">DocIdSetIterator</a>. (DISI stands for <a class="xref" href="Lucene.Net.Search.DocIdSetIterator.html">DocIdSetIterator</a>).</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.OpenBitSetExtensions.html">OpenBitSetExtensions</a></h4>
      <section><!--
 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<p>Some utility classes.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.OpenBitSetIterator.html">OpenBitSetIterator</a></h4>
      <section><p>An iterator to iterate over set bits in an <a class="xref" href="Lucene.Net.Util.OpenBitSet.html">OpenBitSet</a>.
this is faster than <a class="xref" href="Lucene.Net.Util.OpenBitSet.html#Lucene_Net_Util_OpenBitSet_NextSetBit_System_Int64_">NextSetBit(long)</a> for iterating over the complete set of bits,
especially when the density of the bits set is high.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.PForDeltaDocIdSet.html">PForDeltaDocIdSet</a></h4>
      <section><p><a class="xref" href="Lucene.Net.Search.DocIdSet.html">DocIdSet</a> implementation based on pfor-delta encoding.</p>
<p>This implementation is inspired from LinkedIn's Kamikaze
(http://data.linkedin.com/opensource/kamikaze) and Daniel Lemire's JavaFastPFOR
(https://github.com/lemire/JavaFastPFOR).</p><p>On the contrary to the original PFOR paper, exceptions are encoded with
FOR instead of Simple16.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.PForDeltaDocIdSet.Builder.html">PForDeltaDocIdSet.Builder</a></h4>
      <section><p>A builder for <a class="xref" href="Lucene.Net.Util.PForDeltaDocIdSet.html">PForDeltaDocIdSet</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.PForDeltaDocIdSetExtensions.html">PForDeltaDocIdSetExtensions</a></h4>
      <section><!--
 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<p>Some utility classes.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.PagedBytes.html">PagedBytes</a></h4>
      <section><p>Represents a logical <span class="xref">byte[]</span> as a series of pages.  You
can write-once into the logical <span class="xref">byte[]</span> (append only),
using copy, and then retrieve slices (<a class="xref" href="Lucene.Net.Util.BytesRef.html">BytesRef</a>) into it
using fill.</p>
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.PagedBytes.PagedBytesDataInput.html">PagedBytes.PagedBytesDataInput</a></h4>
      <section><!--
 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<p>Some utility classes.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.PagedBytes.PagedBytesDataOutput.html">PagedBytes.PagedBytesDataOutput</a></h4>
      <section><!--
 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<p>Some utility classes.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.PagedBytes.Reader.html">PagedBytes.Reader</a></h4>
      <section><p>Provides methods to read <a class="xref" href="Lucene.Net.Util.BytesRef.html">BytesRef</a>s from a frozen
<a class="xref" href="Lucene.Net.Util.PagedBytes.html">PagedBytes</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.PrintStreamInfoStream.html">PrintStreamInfoStream</a></h4>
      <section><p>LUCENENET specific stub to assist with migration to <a class="xref" href="Lucene.Net.Util.TextWriterInfoStream.html">TextWriterInfoStream</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.PriorityComparer-1.html">PriorityComparer&lt;T&gt;</a></h4>
      <section><p>An adapter comparer for use with <a class="xref" href="Lucene.Net.Util.ValuePriorityQueue-1.html">ValuePriorityQueue&lt;T&gt;</a>.</p>
<p></p>
This comparer makes it easy to convert <a class="xref" href="Lucene.Net.Util.PriorityQueue-1.html">PriorityQueue&lt;T&gt;</a>-derived
subclasses into comparers that can be used with <a class="xref" href="Lucene.Net.Util.ValuePriorityQueue-1.html">ValuePriorityQueue&lt;T&gt;</a>.
<p></p><b>NOTE:</b> This adapter converts the 2-state <a class="xref" href="Lucene.Net.Util.PriorityComparer-1.html#Lucene_Net_Util_PriorityComparer_1_LessThan__0__0_">LessThan(T, T)</a>
method to the 3-state <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.collections.generic.icomparer-1.compare">Compare(T, T)</a> by always assuming if
<a class="xref" href="Lucene.Net.Util.PriorityComparer-1.html#Lucene_Net_Util_PriorityComparer_1_LessThan__0__0_">LessThan(T, T)</a> returns <code>false</code> that the left node is greater than
the right node. This means nodes will never compare equal, even if they actually are.
Therefore, it may not work correctly for most applications of <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.collections.generic.icomparer-1">IComparer&lt;T&gt;</a>,
but will work correctly with <a class="xref" href="Lucene.Net.Util.ValuePriorityQueue-1.html">ValuePriorityQueue&lt;T&gt;</a>.
</section>
      <h4><a class="xref" href="Lucene.Net.Util.PriorityQueue.html">PriorityQueue</a></h4>
      <section><p>LUCENENET specific static methods for managing priority queues.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.PriorityQueue-1.html">PriorityQueue&lt;T&gt;</a></h4>
      <section><p>A <a class="xref" href="Lucene.Net.Util.PriorityQueue-1.html">PriorityQueue&lt;T&gt;</a> maintains a partial ordering of its elements such that the
element with least priority can always be found in constant time. Put()'s and Pop()'s
require log(size) time.</p>
<p></p><b>NOTE</b>: this class will pre-allocate a full array of
length <code>maxSize+1</code> if instantiated with a constructor that
accepts a <a class="xref" href="Lucene.Net.Util.ISentinelFactory-1.html">ISentinelFactory&lt;T&gt;</a>. That maximum size can
grow as we insert elements over time.
<p></p><b>NOTE</b>: The type of <code class="typeparamref">T</code> may be either a class
or a value type. But do note that it was specifically designed with
nullable types in mind, so there may be cases where you need to use a
nullable value type to get it to behave correctly.
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.QueryBuilder.html">QueryBuilder</a></h4>
      <section><p>Creates queries from the <a class="xref" href="Lucene.Net.Util.QueryBuilder.html#Lucene_Net_Util_QueryBuilder_Analyzer">Analyzer</a> chain.</p>
<p></p>
Example usage:
<pre><code class="lang-csharp">QueryBuilder builder = new QueryBuilder(analyzer);
Query a = builder.CreateBooleanQuery("body", "just a test");
Query b = builder.CreatePhraseQuery("body", "another test");
Query c = builder.CreateMinShouldMatchQuery("body", "another test", 0.5f);</code></pre><p></p>
This can also be used as a subclass for query parsers to make it easier
to interact with the analysis chain. Factory methods such as <a class="xref" href="Lucene.Net.Util.QueryBuilder.html#Lucene_Net_Util_QueryBuilder_NewTermQuery_Lucene_Net_Index_Term_">NewTermQuery(Term)</a>
are provided so that the generated queries can be customized.
</section>
      <h4><a class="xref" href="Lucene.Net.Util.RamUsageEstimator.html">RamUsageEstimator</a></h4>
      <section><p>Estimates the size (memory representation) of .NET objects.</p>
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.RecyclingByteBlockAllocator.html">RecyclingByteBlockAllocator</a></h4>
      <section><p>A <a class="xref" href="Lucene.Net.Util.ByteBlockPool.Allocator.html">ByteBlockPool.Allocator</a> implementation that recycles unused byte
blocks in a buffer and reuses them in subsequent calls to
<a class="xref" href="Lucene.Net.Util.RecyclingByteBlockAllocator.html#Lucene_Net_Util_RecyclingByteBlockAllocator_GetByteBlock">GetByteBlock()</a>.</p>
<p>
Note: this class is not thread-safe.
</p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.RecyclingInt32BlockAllocator.html">RecyclingInt32BlockAllocator</a></h4>
      <section><p>A <a class="xref" href="Lucene.Net.Util.Int32BlockPool.Allocator.html">Int32BlockPool.Allocator</a> implementation that recycles unused <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a>
blocks in a buffer and reuses them in subsequent calls to
<a class="xref" href="Lucene.Net.Util.RecyclingInt32BlockAllocator.html#Lucene_Net_Util_RecyclingInt32BlockAllocator_GetInt32Block">GetInt32Block()</a>.</p>
<p>
Note: this class is not thread-safe.
</p><p>
NOTE: This was RecyclingIntBlockAllocator in Lucene
</p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.RefCount-1.html">RefCount&lt;T&gt;</a></h4>
      <section><p>Manages reference counting for a given object. Extensions can override
<a class="xref" href="Lucene.Net.Util.RefCount-1.html#Lucene_Net_Util_RefCount_1_Release">Release()</a> to do custom logic when reference counting hits 0.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.RollingBufferItemFactory-1.html">RollingBufferItemFactory&lt;T&gt;</a></h4>
      <section><p>LUCENENET specific class that provides default implementation for
<a class="xref" href="Lucene.Net.Util.IRollingBufferItemFactory-1.html">IRollingBufferItemFactory&lt;T&gt;</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.RollingBuffer-1.html">RollingBuffer&lt;T&gt;</a></h4>
      <section><p>Acts like forever growing <span class="xref">T[]</span>, but internally uses a
circular buffer to reuse instances of <typeparam name="T"></typeparam>.</p>
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.SPIClassIterator-1.html">SPIClassIterator&lt;S&gt;</a></h4>
      <section><p>Helper class for loading SPI classes from classpath (META-INF files).
This is a light impl of <code>java.util.ServiceLoader</code> but is guaranteed to
be bug-free regarding classpath order and does not instantiate or initialize
the classes found.</p>
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.SentinelInt32Set.html">SentinelInt32Set</a></h4>
      <section><p>A native <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a> hash-based set where one value is reserved to mean &quot;EMPTY&quot; internally. The space overhead is fairly low
as there is only one power-of-two sized <span class="xref">int[]</span> to hold the values.  The set is re-hashed when adding a value that
would make it &gt;= 75% full.  Consider extending and over-riding <a class="xref" href="Lucene.Net.Util.SentinelInt32Set.html#Lucene_Net_Util_SentinelInt32Set_Hash_System_Int32_">Hash(int)</a> if the values might be poor
hash keys; Lucene docids should be fine.
The internal fields are exposed publicly to enable more efficient use at the expense of better O-O principles.</p>
<p></p>
To iterate over the integers held in this set, simply use code like this:
<pre><code class="lang-csharp">SentinelIntSet set = ...
foreach (int v in set.keys) 
{
    if (v == set.EmptyVal)
        continue;
    //use v...
}</code></pre><p></p>
NOTE: This was SentinelIntSet in Lucene
<p></p>
<p>If you need to extend this class and subclass it, keep in mind that constructor
calls a private &quot;ClearInternal&quot; method and not virtual Clear. So if you need
to do some specific initialization in subclass constructor, call your own private
method with whatever custom initialization you need.
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>
</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.ServiceNameAttribute.html">ServiceNameAttribute</a></h4>
      <section><p>LUCENENET specific abstract class for <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.attribute">Attribute</a>s that can
be used to override the default convention-based names of services. For example,
&quot;Lucene40Codec&quot; will by convention be named &quot;Lucene40&quot;. Using the <a class="xref" href="Lucene.Net.Codecs.CodecNameAttribute.html">CodecNameAttribute</a>,
the name can be overridden with a custom value.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.SetOnce-1.html">SetOnce&lt;T&gt;</a></h4>
      <section><p>A convenient class which offers a semi-immutable object wrapper
implementation which allows one to set the value of an object exactly once,
and retrieve it many times. If <a class="xref" href="Lucene.Net.Util.SetOnce-1.html#Lucene_Net_Util_SetOnce_1_Set__0_">Set(T)</a> is called more than once,
<a class="xref" href="Lucene.Net.Util.AlreadySetException.html">AlreadySetException</a> is thrown and the operation
will fail.</p>
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is experimental and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.SloppyMath.html">SloppyMath</a></h4>
      <section><p>Math functions that trade off accuracy for speed.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.SmallSingle.html">SmallSingle</a></h4>
      <section><p>Floating point numbers smaller than 32 bits.</p>
<p></p>
NOTE: This was SmallFloat in Lucene
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.Sorter.html">Sorter</a></h4>
      <section><p>Base class for sorting algorithms implementations.</p>
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.StringHelper.html">StringHelper</a></h4>
      <section><p>Methods for manipulating strings.</p>
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.SystemConsole.html">SystemConsole</a></h4>
      <section><p>Mimics <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.console">Console</a>, but allows for swapping
the <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.io.textwriter">TextWriter</a> of
<a class="xref" href="Lucene.Net.Util.SystemConsole.html#Lucene_Net_Util_SystemConsole_Out">Out</a> and <a class="xref" href="Lucene.Net.Util.SystemConsole.html#Lucene_Net_Util_SystemConsole_Error">Error</a>
with user-defined implementations.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.TextWriterInfoStream.html">TextWriterInfoStream</a></h4>
      <section><p><a class="xref" href="Lucene.Net.Util.InfoStream.html">InfoStream</a> implementation over a <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.io.textwriter">TextWriter</a>
such as <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.console.out">Out</a>.</p>
<p></p>
NOTE: This is analogous to PrintStreamInfoStream in Lucene.
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.ThreadInterruptedException.html">ThreadInterruptedException</a></h4>
      <section><p>Thrown by Lucene on detecing that <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.thread.interrupt">Interrupt()</a> had been
called. This exception has the specific purpose of being allowed to pass through to the
calling thread of <span class="xref">J2N.Threading.ThreadJob</span> so it reaches the appropriate handler.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.TimSorter.html">TimSorter</a></h4>
      <section><p><a class="xref" href="Lucene.Net.Util.Sorter.html">Sorter</a> implementation based on the
<a href="http://svn.python.org/projects/python/trunk/Objects/listsort.txt">TimSort</a>
algorithm.</p>
<p></p>This implementation is especially good at sorting partially-sorted
arrays and sorts small arrays with binary sort.
<p></p><b>NOTE</b>:There are a few differences with the original implementation:
<ul><li><a name="maxTempSlots"></a>The extra amount of memory to perform merges is
        configurable. This allows small merges to be very fast while large merges
        will be performed in-place (slightly slower). You can make sure that the
        fast merge routine will always be used by having <code>maxTempSlots</code>
        equal to half of the length of the slice of data to sort.</li><li>Only the fast merge routine can gallop (the one that doesn't run
        in-place) and it only gallops on the longest slice.</li></ul><p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.ToStringUtils.html">ToStringUtils</a></h4>
      <section><p>Helper methods to ease implementing <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.tostring">ToString()</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.UnicodeUtil.html">UnicodeUtil</a></h4>
      <section><p>Class to encode .NET's UTF16 <span class="xref">char[]</span> into UTF8 <span class="xref">byte[]</span>
without always allocating a new <span class="xref">byte[]</span> as
<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.text.encoding.getbytes#system-text-encoding-getbytes(system-string)">GetBytes(string)</a> of <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.text.encoding.utf8">UTF8</a> does.</p>
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.VirtualMethod.html">VirtualMethod</a></h4>
      <section><p>A utility for keeping backwards compatibility on previously abstract methods
(or similar replacements).</p>
<p>Before the replacement method can be made abstract, the old method must kept deprecated.
If somebody still overrides the deprecated method in a non-sealed class,
you must keep track, of this and maybe delegate to the old method in the subclass.
The cost of reflection is minimized by the following usage of this class:</p><p>Define <strong>static readonly</strong> fields in the base class (<code>BaseClass</code>),
where the old and new method are declared:</p><pre><code class="lang-csharp">internal static readonly VirtualMethod newMethod =
                                                  new VirtualMethod(typeof(BaseClass), "newName", parameters...);
                                              internal static readonly VirtualMethod oldMethod =
                                                  new VirtualMethod(typeof(BaseClass), "oldName", parameters...);</code></pre><p>this enforces the singleton status of these objects, as the maintenance of the cache would be too costly else.
If you try to create a second instance of for the same method/<code>baseClass</code> combination, an exception is thrown.</p><p>To detect if e.g. the old method was overridden by a more far subclass on the inheritance path to the current
instance's class, use a <strong>non-static</strong> field:</p><pre><code class="lang-csharp">bool isDeprecatedMethodOverridden =
                                                                  oldMethod.GetImplementationDistance(this.GetType()) &gt; newMethod.GetImplementationDistance(this.GetType());
<pre><code>                                                          // alternatively (more readable):
                                                          bool isDeprecatedMethodOverridden =
                                                              VirtualMethod.CompareImplementationDistance(this.GetType(), oldMethod, newMethod) &gt; 0&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;xref href=&quot;Lucene.Net.Util.VirtualMethod.GetImplementationDistance(System.Type)&quot; data-throw-if-not-resolved=&quot;false&quot;&gt;&lt;/xref&gt; returns the distance of the subclass that overrides this method.
</code></pre>
<p>The one with the larger distance should be used preferable.
this way also more complicated method rename scenarios can be handled
(think of 2.9 <a class="xref" href="Lucene.Net.Analysis.TokenStream.html">TokenStream</a> deprecations).</p>
<p><div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>
</p>
</code></pre></section>
      <h4><a class="xref" href="Lucene.Net.Util.WAH8DocIdSet.html">WAH8DocIdSet</a></h4>
      <section><p><a class="xref" href="Lucene.Net.Search.DocIdSet.html">DocIdSet</a> implementation based on word-aligned hybrid encoding on
words of 8 bits.</p>
<p>This implementation doesn't support random-access but has a fast
<a class="xref" href="Lucene.Net.Search.DocIdSetIterator.html">DocIdSetIterator</a> which can advance in logarithmic time thanks to
an index.</p><p>The compression scheme is simplistic and should work well with sparse and
very dense doc id sets while being only slightly larger than a
<a class="xref" href="Lucene.Net.Util.FixedBitSet.html">FixedBitSet</a> for incompressible sets (overhead&lt;2% in the worst
case) in spite of the index.</p><p><b>Format</b>: The format is byte-aligned. An 8-bits word is either clean,
meaning composed only of zeros or ones, or dirty, meaning that it contains
between 1 and 7 bits set. The idea is to encode sequences of clean words
using run-length encoding and to leave sequences of dirty words as-is.</p><table><thead><tr><th class="term">Token</th><th class="term">Clean length+</th><th class="term">Dirty length+</th><th class="term">Dirty words</th></tr></thead><tbody><tr><td class="term">1 byte</td><td class="term">0-n bytes</td><td class="term">0-n bytes</td><td class="term">0-n bytes</td></tr></tbody></table><ul><li><span class="term"><b>Token</b></span> encodes whether clean means full of zeros or ones in the
        first bit, the number of clean words minus 2 on the next 3 bits and the
        number of dirty words on the last 4 bits. The higher-order bit is a
        continuation bit, meaning that the number is incomplete and needs additional
        bytes to be read.</li><li><span class="term"><b>Clean length+</b>:</span> If clean length has its higher-order bit set,
        you need to read a vint (<a class="xref" href="Lucene.Net.Store.DataInput.html#Lucene_Net_Store_DataInput_ReadVInt32">ReadVInt32()</a>), shift it by 3 bits on
        the left side and add it to the 3 bits which have been read in the token.</li><li><span class="term"><b>Dirty length+</b></span> works the same way as <b>Clean length+</b> but
        on 4 bits and for the length of dirty words.</li><li><span class="term"><b>Dirty words</b></span>are the dirty words, there are <b>Dirty length</b>
        of them.</li></ul><p>This format cannot encode sequences of less than 2 clean words and 0 dirty
word. The reason is that if you find a single clean word, you should rather
encode it as a dirty word. This takes the same space as starting a new
sequence (since you need one byte for the token) but will be lighter to
decode. There is however an exception for the first sequence. Since the first
sequence may start directly with a dirty word, the clean length is encoded
directly, without subtracting 2.</p><p>There is an additional restriction on the format: the sequence of dirty
words is not allowed to contain two consecutive clean words. This restriction
exists to make sure no space is wasted and to make sure iterators can read
the next doc ID by reading at most 2 dirty words.</p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is experimental and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.WAH8DocIdSet.Builder.html">WAH8DocIdSet.Builder</a></h4>
      <section><p>A builder for <a class="xref" href="Lucene.Net.Util.WAH8DocIdSet.html">WAH8DocIdSet</a>s.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.WAH8DocIdSet.WordBuilder.html">WAH8DocIdSet.WordBuilder</a></h4>
      <section><p>Word-based builder.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.WAH8DocIdSetExtensions.html">WAH8DocIdSetExtensions</a></h4>
      <section><!--
 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<p>Some utility classes.</p>
</section>
    <h3 id="structs">Structs
</h3>
      <h4><a class="xref" href="Lucene.Net.Util.ValuePriorityQueue-1.html">ValuePriorityQueue&lt;T&gt;</a></h4>
      <section><p>A <a class="xref" href="Lucene.Net.Util.ValuePriorityQueue-1.html">ValuePriorityQueue&lt;T&gt;</a> maintains a partial ordering of its elements such that the
element with least priority can always be found in constant time. Put()'s and Pop()'s
require log(size) time.</p>
<p></p>
This ref struct has the same behavior as <a class="xref" href="Lucene.Net.Util.PriorityQueue-1.html">PriorityQueue&lt;T&gt;</a>, but can be
used to reduce allocations in scenarios where ref structs are allowed. If the type of
<code class="typeparamref">T</code> is a struct the passed in <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span&lt;T&gt;</a> buffer
may also be allocated on the stack, as allowed.
<p></p><b>NOTE</b>: The allocation size of the supplied <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span&lt;T&gt;</a> buffer
must be <code>maxSize+1</code>. The <a class="xref" href="Lucene.Net.Util.PriorityQueue.html#Lucene_Net_Util_PriorityQueue_GetArrayHeapSize_System_Int32_">GetArrayHeapSize(int)</a> method
can be used to get the correct calculation and to validate bounds of maxSize.
<p></p>
If instantiated with a constructor that accepts a <a class="xref" href="Lucene.Net.Util.ISentinelFactory-1.html">ISentinelFactory&lt;T&gt;</a>,
that factory will be used to populate the elements of the array.
<p></p><b>NOTE</b>: The type of <code class="typeparamref">T</code> may be either a class
or a value type. But do note that it was specifically designed with
nullable types in mind, so there may be cases where you need to use a
nullable value type to get it to behave correctly.
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
    <h3 id="interfaces">Interfaces
</h3>
      <h4><a class="xref" href="Lucene.Net.Util.IAccountable.html">IAccountable</a></h4>
      <section><p>An object whose RAM usage can be computed.</p>
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is for internal purposes only and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.IAttribute.html">IAttribute</a></h4>
      <section><p>Base interface for attributes.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.IAttributeReflector.html">IAttributeReflector</a></h4>
      <section><p>This interface is used to reflect contents of <a class="xref" href="Lucene.Net.Util.AttributeSource.html">AttributeSource</a> or <a class="xref" href="Lucene.Net.Util.Attribute.html">Attribute</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.IBits.html">IBits</a></h4>
      <section><p>Interface for Bitset-like structures.</p>
<p></p>
<div class="NOTE">
<h5>Note</h5>
<p>This API is experimental and might change in incompatible ways in the next release.</p>
</div>

</section>
      <h4><a class="xref" href="Lucene.Net.Util.IBytesRefEnumerator.html">IBytesRefEnumerator</a></h4>
      <section><p>A simple enumerator interface for <a class="xref" href="Lucene.Net.Util.BytesRef.html">BytesRef</a> iteration.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.IMutableBits.html">IMutableBits</a></h4>
      <section><p>Extension of <a class="xref" href="Lucene.Net.Util.IBits.html">IBits</a> for live documents.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.IResettable.html">IResettable</a></h4>
      <section><p>Implement to reset an instance</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.IResourceProvider.html">IResourceProvider</a></h4>
      <section><p>Contract for a set of localized resources. Generally, this is an abstraction over one or
more <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.resources.resourcemanager">ResourceManager</a> instances.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.IRollingBufferItemFactory-1.html">IRollingBufferItemFactory&lt;T&gt;</a></h4>
      <section><p>LUCENENET specific interface to allow overriding rolling buffer item creation
without having to call virtual methods from the constructor</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.ISentinelFactory-1.html">ISentinelFactory&lt;T&gt;</a></h4>
      <section><p>Provides the sentinel instances of <code class="typeparamref">T</code> to a
<a class="xref" href="Lucene.Net.Util.PriorityQueue-1.html">PriorityQueue&lt;T&gt;</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.IServiceListable.html">IServiceListable</a></h4>
      <section><p>LUCENENET specific contract that provides support for <a class="xref" href="Lucene.Net.Codecs.Codec.html#Lucene_Net_Codecs_Codec_AvailableCodecs">AvailableCodecs</a>,
<a class="xref" href="Lucene.Net.Codecs.DocValuesFormat.html#Lucene_Net_Codecs_DocValuesFormat_AvailableDocValuesFormats">AvailableDocValuesFormats</a>,
and <a class="xref" href="Lucene.Net.Codecs.PostingsFormat.html#Lucene_Net_Codecs_PostingsFormat_AvailablePostingsFormats">AvailablePostingsFormats</a>. Implement this
interface in addition to <a class="xref" href="Lucene.Net.Codecs.ICodecFactory.html">ICodecFactory</a>, <a class="xref" href="Lucene.Net.Codecs.IDocValuesFormatFactory.html">IDocValuesFormatFactory</a>,
or <a class="xref" href="Lucene.Net.Codecs.IPostingsFormatFactory.html">IPostingsFormatFactory</a> to provide optional support for the above
methods when providing a custom implementation. If this interface is not supported by
the corresponding factory, a <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.notsupportedexception">NotSupportedException</a> will be thrown from the above methods.</p>
</section>
    <h3 id="enums">Enums
</h3>
      <h4><a class="xref" href="Lucene.Net.Util.LuceneVersion.html">LuceneVersion</a></h4>
      <section><p>Use by certain classes to match version compatibility
across releases of Lucene.</p>
<p><b>WARNING</b>: When changing the version parameter
that you supply to components in Lucene, do not simply
change the version at search-time, but instead also adjust
your indexing code to match, and re-index.</p>
</section>
</article>
          </div>

          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/NightOwl888/lucenenet/blob/docs/4.8.0-beta00017/src/Lucene.Net/Util/package.md/#L2" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>

      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
      Copyright &copy; 2024 The Apache Software Foundation, Licensed under the <a href='http://www.apache.org/licenses/LICENSE-2.0' target='_blank'>Apache License, Version 2.0</a><br> <small>Apache Lucene.Net, Lucene.Net, Apache, the Apache feather logo, and the Apache Lucene.Net project logo are trademarks of The Apache Software Foundation. <br>All other marks mentioned may be trademarks or registered trademarks of their respective owners.</small>
      
          </div>
        </div>
      </footer>
    </div>

    <script type="text/javascript" src="https://lucenenet.apache.org/docs/4.8.0-beta00017/styles/docfx.vendor.min.js"></script>
    <script type="text/javascript" src="https://lucenenet.apache.org/docs/4.8.0-beta00017/styles/docfx.js"></script>
    <script type="text/javascript" src="https://lucenenet.apache.org/docs/4.8.0-beta00017/styles/main.js"></script>
  </body>
</html>
