<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Class XMLWriter
 | Apache Lucene.NET 4.8.0-beta00017 Documentation </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Class XMLWriter
 | Apache Lucene.NET 4.8.0-beta00017 Documentation ">
    <meta name="generator" content="docfx ">
  
    <link rel="shortcut icon" href="https://lucenenet.apache.org/docs/4.8.0-beta00017/logo/favicon.ico">
    <link rel="stylesheet" href="https://lucenenet.apache.org/docs/4.8.0-beta00017/styles/docfx.vendor.min.css">
    <link rel="stylesheet" href="https://lucenenet.apache.org/docs/4.8.0-beta00017/styles/docfx.css">
    <link rel="stylesheet" href="https://lucenenet.apache.org/docs/4.8.0-beta00017/styles/main.css">
    <meta property="docfx:navrel" content="toc.html">
    <meta property="docfx:tocrel" content="benchmark/toc.html">
  
  <meta property="docfx:rel" content="https://lucenenet.apache.org/docs/4.8.0-beta00017/">
  
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <span id="forkongithub"><a href="https://github.com/apache/lucenenet" target="_blank">Fork me on GitHub</a></span>
    <div id="wrapper">
      <header>

        <nav id="autocollapse" class="navbar ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <a class="navbar-brand" href="/">
                <img id="logo" class="svg" src="https://lucenenet.apache.org/docs/4.8.0-beta00017/logo/lucene-net-color.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>

        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search">
            <ul class="level0 breadcrumb">
                <li>
                    <a href="https://lucenenet.apache.org/docs/4.8.0-beta00017/">API</a>
                     <span id="breadcrumb">
                        <ul class="breadcrumb">
                          <li></li>
                        </ul>
                    </span>   
                </li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">

        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">

        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="TagSoup.XMLWriter">


  <h1 id="TagSoup_XMLWriter" data-uid="TagSoup.XMLWriter" class="text-break">Class XMLWriter
</h1>
  <div class="markdown level0 summary"><p>Filter to write an XML document from a SAX event stream.</p>
</div>
  <div class="markdown level0 conceptual"></div>
  <div class="inheritance">
    <h5>Inheritance</h5>
    <div class="level0"><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object">object</a></div>
    <div class="level1"><a class="xref" href="Sax.Helpers.XMLFilter.html">XMLFilter</a></div>
    <div class="level2"><span class="xref">XMLWriter</span></div>
  </div>
  <div classs="implements">
    <h5>Implements</h5>
    <div><a class="xref" href="Sax.IXMLFilter.html">IXMLFilter</a></div>
    <div><a class="xref" href="Sax.IXMLReader.html">IXMLReader</a></div>
    <div><a class="xref" href="Sax.IEntityResolver.html">IEntityResolver</a></div>
    <div><a class="xref" href="Sax.IDTDHandler.html">IDTDHandler</a></div>
    <div><a class="xref" href="Sax.IContentHandler.html">IContentHandler</a></div>
    <div><a class="xref" href="Sax.IErrorHandler.html">IErrorHandler</a></div>
    <div><a class="xref" href="Sax.Ext.ILexicalHandler.html">ILexicalHandler</a></div>
  </div>
  <div class="inheritedMembers">
    <h5>Inherited Members</h5>
    <div>
      <a class="xref" href="Sax.Helpers.XMLFilter.html#Sax_Helpers_XMLFilter_Parent">XMLFilter.Parent</a>
    </div>
    <div>
      <a class="xref" href="Sax.Helpers.XMLFilter.html#Sax_Helpers_XMLFilter_SetFeature_System_String_System_Boolean_">XMLFilter.SetFeature(string, bool)</a>
    </div>
    <div>
      <a class="xref" href="Sax.Helpers.XMLFilter.html#Sax_Helpers_XMLFilter_GetFeature_System_String_">XMLFilter.GetFeature(string)</a>
    </div>
    <div>
      <a class="xref" href="Sax.Helpers.XMLFilter.html#Sax_Helpers_XMLFilter_SetProperty_System_String_System_Object_">XMLFilter.SetProperty(string, object)</a>
    </div>
    <div>
      <a class="xref" href="Sax.Helpers.XMLFilter.html#Sax_Helpers_XMLFilter_GetProperty_System_String_">XMLFilter.GetProperty(string)</a>
    </div>
    <div>
      <a class="xref" href="Sax.Helpers.XMLFilter.html#Sax_Helpers_XMLFilter_EntityResolver">XMLFilter.EntityResolver</a>
    </div>
    <div>
      <a class="xref" href="Sax.Helpers.XMLFilter.html#Sax_Helpers_XMLFilter_DTDHandler">XMLFilter.DTDHandler</a>
    </div>
    <div>
      <a class="xref" href="Sax.Helpers.XMLFilter.html#Sax_Helpers_XMLFilter_ContentHandler">XMLFilter.ContentHandler</a>
    </div>
    <div>
      <a class="xref" href="Sax.Helpers.XMLFilter.html#Sax_Helpers_XMLFilter_ErrorHandler">XMLFilter.ErrorHandler</a>
    </div>
    <div>
      <a class="xref" href="Sax.Helpers.XMLFilter.html#Sax_Helpers_XMLFilter_Parse_Sax_InputSource_">XMLFilter.Parse(InputSource)</a>
    </div>
    <div>
      <a class="xref" href="Sax.Helpers.XMLFilter.html#Sax_Helpers_XMLFilter_Parse_System_String_">XMLFilter.Parse(string)</a>
    </div>
    <div>
      <a class="xref" href="Sax.Helpers.XMLFilter.html#Sax_Helpers_XMLFilter_ResolveEntity_System_String_System_String_">XMLFilter.ResolveEntity(string, string)</a>
    </div>
    <div>
      <a class="xref" href="Sax.Helpers.XMLFilter.html#Sax_Helpers_XMLFilter_NotationDecl_System_String_System_String_System_String_">XMLFilter.NotationDecl(string, string, string)</a>
    </div>
    <div>
      <a class="xref" href="Sax.Helpers.XMLFilter.html#Sax_Helpers_XMLFilter_UnparsedEntityDecl_System_String_System_String_System_String_System_String_">XMLFilter.UnparsedEntityDecl(string, string, string, string)</a>
    </div>
    <div>
      <a class="xref" href="Sax.Helpers.XMLFilter.html#Sax_Helpers_XMLFilter_SetDocumentLocator_Sax_ILocator_">XMLFilter.SetDocumentLocator(ILocator)</a>
    </div>
    <div>
      <a class="xref" href="Sax.Helpers.XMLFilter.html#Sax_Helpers_XMLFilter_StartPrefixMapping_System_String_System_String_">XMLFilter.StartPrefixMapping(string, string)</a>
    </div>
    <div>
      <a class="xref" href="Sax.Helpers.XMLFilter.html#Sax_Helpers_XMLFilter_EndPrefixMapping_System_String_">XMLFilter.EndPrefixMapping(string)</a>
    </div>
    <div>
      <a class="xref" href="Sax.Helpers.XMLFilter.html#Sax_Helpers_XMLFilter_SkippedEntity_System_String_">XMLFilter.SkippedEntity(string)</a>
    </div>
    <div>
      <a class="xref" href="Sax.Helpers.XMLFilter.html#Sax_Helpers_XMLFilter_Warning_Sax_SAXParseException_">XMLFilter.Warning(SAXParseException)</a>
    </div>
    <div>
      <a class="xref" href="Sax.Helpers.XMLFilter.html#Sax_Helpers_XMLFilter_Error_Sax_SAXParseException_">XMLFilter.Error(SAXParseException)</a>
    </div>
    <div>
      <a class="xref" href="Sax.Helpers.XMLFilter.html#Sax_Helpers_XMLFilter_FatalError_Sax_SAXParseException_">XMLFilter.FatalError(SAXParseException)</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.equals#system-object-equals(system-object)">object.Equals(object)</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.equals#system-object-equals(system-object-system-object)">object.Equals(object, object)</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.gethashcode">object.GetHashCode()</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.gettype">object.GetType()</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.memberwiseclone">object.MemberwiseClone()</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.referenceequals">object.ReferenceEquals(object, object)</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.tostring">object.ToString()</a>
    </div>
  </div>
  <h6><strong>Namespace</strong>: <a class="xref" href="TagSoup.html">TagSoup</a></h6>
  <h6><strong>Assembly</strong>: Lucene.Net.Benchmark.dll</h6>
  <h5 id="TagSoup_XMLWriter_syntax">Syntax</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public class XMLWriter : XMLFilter, IXMLFilter, IXMLReader, IEntityResolver, IDTDHandler, IContentHandler, IErrorHandler, ILexicalHandler</code></pre>
  </div>
  <h5 id="TagSoup_XMLWriter_remarks"><strong>Remarks</strong></h5>
  <div class="markdown level0 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h3 id="constructors">Constructors
</h3>
  <a id="TagSoup_XMLWriter__ctor_" data-uid="TagSoup.XMLWriter.#ctor*"></a>
  <h4 id="TagSoup_XMLWriter__ctor" data-uid="TagSoup.XMLWriter.#ctor">XMLWriter()</h4>
  <div class="markdown level1 summary"><p>Create a new XML writer.</p>
<p>Write to standard output.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public XMLWriter()</code></pre>
  </div>
  <h5 id="TagSoup_XMLWriter__ctor_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 id="TagSoup_XMLWriter__ctor_seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="Sax.IXMLFilter.html">IXMLFilter</a></div>
      <div><a class="xref" href="Sax.IContentHandler.html">IContentHandler</a></div>
  </div>
  <a id="TagSoup_XMLWriter__ctor_" data-uid="TagSoup.XMLWriter.#ctor*"></a>
  <h4 id="TagSoup_XMLWriter__ctor_Sax_IXMLReader_" data-uid="TagSoup.XMLWriter.#ctor(Sax.IXMLReader)">XMLWriter(IXMLReader)</h4>
  <div class="markdown level1 summary"><p>Create a new XML writer.</p>
<p>Use the specified XML reader as the parent.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public XMLWriter(IXMLReader xmlreader)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Sax.IXMLReader.html">IXMLReader</a></td>
        <td><span class="parametername">xmlreader</span></td>
        <td><p>The parent in the filter chain, or null
for no parent.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter__ctor_Sax_IXMLReader__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 id="TagSoup_XMLWriter__ctor_Sax_IXMLReader__seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="Sax.IXMLFilter.html">IXMLFilter</a></div>
      <div><a class="xref" href="Sax.IContentHandler.html">IContentHandler</a></div>
  </div>
  <a id="TagSoup_XMLWriter__ctor_" data-uid="TagSoup.XMLWriter.#ctor*"></a>
  <h4 id="TagSoup_XMLWriter__ctor_Sax_IXMLReader_System_IO_TextWriter_" data-uid="TagSoup.XMLWriter.#ctor(Sax.IXMLReader,System.IO.TextWriter)">XMLWriter(IXMLReader, TextWriter)</h4>
  <div class="markdown level1 summary"><p>Create a new XML writer.</p>
<p>
Use the specified XML reader as the parent, and write
to the specified writer.
</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public XMLWriter(IXMLReader xmlreader, TextWriter writer)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Sax.IXMLReader.html">IXMLReader</a></td>
        <td><span class="parametername">xmlreader</span></td>
        <td><p>The parent in the filter chain, or null
for no parent.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.io.textwriter">TextWriter</a></td>
        <td><span class="parametername">writer</span></td>
        <td><p>The output destination, or null to use standard
output.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter__ctor_Sax_IXMLReader_System_IO_TextWriter__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 id="TagSoup_XMLWriter__ctor_Sax_IXMLReader_System_IO_TextWriter__seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="Sax.IXMLFilter.html">IXMLFilter</a></div>
      <div><a class="xref" href="Sax.IContentHandler.html">IContentHandler</a></div>
  </div>
  <a id="TagSoup_XMLWriter__ctor_" data-uid="TagSoup.XMLWriter.#ctor*"></a>
  <h4 id="TagSoup_XMLWriter__ctor_System_IO_TextWriter_" data-uid="TagSoup.XMLWriter.#ctor(System.IO.TextWriter)">XMLWriter(TextWriter)</h4>
  <div class="markdown level1 summary"><p>Create a new XML writer.</p>
<p>Write to the writer provided.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public XMLWriter(TextWriter writer)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.io.textwriter">TextWriter</a></td>
        <td><span class="parametername">writer</span></td>
        <td><p>The output destination, or null to use standard
output.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter__ctor_System_IO_TextWriter__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 id="TagSoup_XMLWriter__ctor_System_IO_TextWriter__seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="Sax.IXMLFilter.html">IXMLFilter</a></div>
      <div><a class="xref" href="Sax.IContentHandler.html">IContentHandler</a></div>
  </div>
  <h3 id="fields">Fields
</h3>
  <h4 id="TagSoup_XMLWriter_CDATA_SECTION_ELEMENTS" data-uid="TagSoup.XMLWriter.CDATA_SECTION_ELEMENTS">CDATA_SECTION_ELEMENTS</h4>
  <div class="markdown level1 summary"><p>Filter to write an XML document from a SAX event stream.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public const string CDATA_SECTION_ELEMENTS = &quot;cdata-section-elements&quot;</code></pre>
  </div>
  <h5 class="fieldValue">Field Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_CDATA_SECTION_ELEMENTS_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 id="TagSoup_XMLWriter_CDATA_SECTION_ELEMENTS_seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="Sax.IXMLFilter.html">IXMLFilter</a></div>
      <div><a class="xref" href="Sax.IContentHandler.html">IContentHandler</a></div>
  </div>
  <h4 id="TagSoup_XMLWriter_DOCTYPE_PUBLIC" data-uid="TagSoup.XMLWriter.DOCTYPE_PUBLIC">DOCTYPE_PUBLIC</h4>
  <div class="markdown level1 summary"><p>Filter to write an XML document from a SAX event stream.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public const string DOCTYPE_PUBLIC = &quot;doctype-public&quot;</code></pre>
  </div>
  <h5 class="fieldValue">Field Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_DOCTYPE_PUBLIC_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 id="TagSoup_XMLWriter_DOCTYPE_PUBLIC_seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="Sax.IXMLFilter.html">IXMLFilter</a></div>
      <div><a class="xref" href="Sax.IContentHandler.html">IContentHandler</a></div>
  </div>
  <h4 id="TagSoup_XMLWriter_DOCTYPE_SYSTEM" data-uid="TagSoup.XMLWriter.DOCTYPE_SYSTEM">DOCTYPE_SYSTEM</h4>
  <div class="markdown level1 summary"><p>Filter to write an XML document from a SAX event stream.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public const string DOCTYPE_SYSTEM = &quot;doctype-system&quot;</code></pre>
  </div>
  <h5 class="fieldValue">Field Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_DOCTYPE_SYSTEM_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 id="TagSoup_XMLWriter_DOCTYPE_SYSTEM_seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="Sax.IXMLFilter.html">IXMLFilter</a></div>
      <div><a class="xref" href="Sax.IContentHandler.html">IContentHandler</a></div>
  </div>
  <h4 id="TagSoup_XMLWriter_ENCODING" data-uid="TagSoup.XMLWriter.ENCODING">ENCODING</h4>
  <div class="markdown level1 summary"><p>Filter to write an XML document from a SAX event stream.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public const string ENCODING = &quot;encoding&quot;</code></pre>
  </div>
  <h5 class="fieldValue">Field Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_ENCODING_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 id="TagSoup_XMLWriter_ENCODING_seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="Sax.IXMLFilter.html">IXMLFilter</a></div>
      <div><a class="xref" href="Sax.IContentHandler.html">IContentHandler</a></div>
  </div>
  <h4 id="TagSoup_XMLWriter_INDENT" data-uid="TagSoup.XMLWriter.INDENT">INDENT</h4>
  <div class="markdown level1 summary"><p>Filter to write an XML document from a SAX event stream.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public const string INDENT = &quot;indent&quot;</code></pre>
  </div>
  <h5 class="fieldValue">Field Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_INDENT_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 id="TagSoup_XMLWriter_INDENT_seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="Sax.IXMLFilter.html">IXMLFilter</a></div>
      <div><a class="xref" href="Sax.IContentHandler.html">IContentHandler</a></div>
  </div>
  <h4 id="TagSoup_XMLWriter_MEDIA_TYPE" data-uid="TagSoup.XMLWriter.MEDIA_TYPE">MEDIA_TYPE</h4>
  <div class="markdown level1 summary"><p>Filter to write an XML document from a SAX event stream.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public const string MEDIA_TYPE = &quot;media-type&quot;</code></pre>
  </div>
  <h5 class="fieldValue">Field Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_MEDIA_TYPE_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 id="TagSoup_XMLWriter_MEDIA_TYPE_seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="Sax.IXMLFilter.html">IXMLFilter</a></div>
      <div><a class="xref" href="Sax.IContentHandler.html">IContentHandler</a></div>
  </div>
  <h4 id="TagSoup_XMLWriter_METHOD" data-uid="TagSoup.XMLWriter.METHOD">METHOD</h4>
  <div class="markdown level1 summary"><p>Filter to write an XML document from a SAX event stream.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public const string METHOD = &quot;method&quot;</code></pre>
  </div>
  <h5 class="fieldValue">Field Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_METHOD_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 id="TagSoup_XMLWriter_METHOD_seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="Sax.IXMLFilter.html">IXMLFilter</a></div>
      <div><a class="xref" href="Sax.IContentHandler.html">IContentHandler</a></div>
  </div>
  <h4 id="TagSoup_XMLWriter_OMIT_XML_DECLARATION" data-uid="TagSoup.XMLWriter.OMIT_XML_DECLARATION">OMIT_XML_DECLARATION</h4>
  <div class="markdown level1 summary"><p>Filter to write an XML document from a SAX event stream.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public const string OMIT_XML_DECLARATION = &quot;omit-xml-declaration&quot;</code></pre>
  </div>
  <h5 class="fieldValue">Field Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_OMIT_XML_DECLARATION_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 id="TagSoup_XMLWriter_OMIT_XML_DECLARATION_seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="Sax.IXMLFilter.html">IXMLFilter</a></div>
      <div><a class="xref" href="Sax.IContentHandler.html">IContentHandler</a></div>
  </div>
  <h4 id="TagSoup_XMLWriter_STANDALONE" data-uid="TagSoup.XMLWriter.STANDALONE">STANDALONE</h4>
  <div class="markdown level1 summary"><p>Filter to write an XML document from a SAX event stream.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public const string STANDALONE = &quot;standalone&quot;</code></pre>
  </div>
  <h5 class="fieldValue">Field Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_STANDALONE_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 id="TagSoup_XMLWriter_STANDALONE_seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="Sax.IXMLFilter.html">IXMLFilter</a></div>
      <div><a class="xref" href="Sax.IContentHandler.html">IContentHandler</a></div>
  </div>
  <h4 id="TagSoup_XMLWriter_VERSION" data-uid="TagSoup.XMLWriter.VERSION">VERSION</h4>
  <div class="markdown level1 summary"><p>Filter to write an XML document from a SAX event stream.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public const string VERSION = &quot;version&quot;</code></pre>
  </div>
  <h5 class="fieldValue">Field Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_VERSION_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 id="TagSoup_XMLWriter_VERSION_seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="Sax.IXMLFilter.html">IXMLFilter</a></div>
      <div><a class="xref" href="Sax.IContentHandler.html">IContentHandler</a></div>
  </div>
  <h3 id="methods">Methods
</h3>
  <a id="TagSoup_XMLWriter_Characters_" data-uid="TagSoup.XMLWriter.Characters*"></a>
  <h4 id="TagSoup_XMLWriter_Characters_System_Char___System_Int32_System_Int32_" data-uid="TagSoup.XMLWriter.Characters(System.Char[],System.Int32,System.Int32)">Characters(char[], int, int)</h4>
  <div class="markdown level1 summary"><p>Write character data.
Pass the event on down the filter chain for further processing.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public override void Characters(char[] ch, int start, int length)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.char">char</a>[]</td>
        <td><span class="parametername">ch</span></td>
        <td><p>The array of characters to write.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></td>
        <td><span class="parametername">start</span></td>
        <td><p>The starting position in the array.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></td>
        <td><span class="parametername">length</span></td>
        <td><p>The number of characters to write.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><a class="xref" href="Sax.Helpers.XMLFilter.html#Sax_Helpers_XMLFilter_Characters_System_Char___System_Int32_System_Int32_">XMLFilter.Characters(char[], int, int)</a></div>
  <h5 id="TagSoup_XMLWriter_Characters_System_Char___System_Int32_System_Int32__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Sax.SAXException.html">SAXException</a></td>
        <td><p>If there is an error
writing the characters, or if a handler further down
the filter chain raises an exception.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_Characters_System_Char___System_Int32_System_Int32__seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="Sax.IContentHandler.html#Sax_IContentHandler_Characters_System_Char___System_Int32_System_Int32_">Characters</a>(<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.char">char</a>[], <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a>, <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a>)</div>
  </div>
  <a id="TagSoup_XMLWriter_Characters_" data-uid="TagSoup.XMLWriter.Characters*"></a>
  <h4 id="TagSoup_XMLWriter_Characters_System_String_" data-uid="TagSoup.XMLWriter.Characters(System.String)">Characters(string)</h4>
  <div class="markdown level1 summary"><p>Write a string of character data, with XML escaping.</p>
<p>
This is a convenience method that takes an XML
string, converts it to a character array, then invokes
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_Characters_System_Char___System_Int32_System_Int32_">Characters(char[], int, int)</a>.
</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public virtual void Characters(string data)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">data</span></td>
        <td><p>The character data.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_Characters_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Sax.SAXException.html">SAXException</a></td>
        <td><p>If there is an error
writing the string, or if a handler further down
the filter chain raises an exception.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_Characters_System_String__seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_Characters_System_Char___System_Int32_System_Int32_">Characters(char[], int, int)</a></div>
  </div>
  <a id="TagSoup_XMLWriter_Comment_" data-uid="TagSoup.XMLWriter.Comment*"></a>
  <h4 id="TagSoup_XMLWriter_Comment_System_Char___System_Int32_System_Int32_" data-uid="TagSoup.XMLWriter.Comment(System.Char[],System.Int32,System.Int32)">Comment(char[], int, int)</h4>
  <div class="markdown level1 summary"><p>Report an XML comment anywhere in the document.</p>
<p></p>
This callback will be used for comments inside or outside the
document element, including comments in the external DTD
subset(if read).  Comments in the DTD must be properly
nested inside start/endDTD and start/endEntity events(if
used).
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public virtual void Comment(char[] ch, int start, int length)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.char">char</a>[]</td>
        <td><span class="parametername">ch</span></td>
        <td><p>An array holding the characters in the comment.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></td>
        <td><span class="parametername">start</span></td>
        <td><p>The starting position in the array.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></td>
        <td><span class="parametername">length</span></td>
        <td><p>The number of characters to use from the array.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_Comment_System_Char___System_Int32_System_Int32__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Sax.SAXException.html">SAXException</a></td>
        <td><p>The application may raise an exception.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_Comment_System_Char___System_Int32_System_Int32__seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="Sax.IXMLFilter.html">IXMLFilter</a></div>
      <div><a class="xref" href="Sax.IContentHandler.html">IContentHandler</a></div>
  </div>
  <a id="TagSoup_XMLWriter_DataElement_" data-uid="TagSoup.XMLWriter.DataElement*"></a>
  <h4 id="TagSoup_XMLWriter_DataElement_System_String_System_String_" data-uid="TagSoup.XMLWriter.DataElement(System.String,System.String)">DataElement(string, string)</h4>
  <div class="markdown level1 summary"><p>Write an element with character data content but no attributes or Namespace URI.</p>
<p>
This is a convenience method to write a complete element
with character data content, including the start tag
and end tag.  The method provides an empty string for the
Namespace URI, and empty string for the qualified name,
and an empty attribute list.
</p><p>
This method invokes
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartElement_System_String_System_String_System_String_Sax_IAttributes_">StartElement(string, string, string, IAttributes)</a>,
followed by
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_Characters_System_String_">Characters(string)</a>, followed by
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndElement_System_String_System_String_System_String_">EndElement(string, string, string)</a>.
</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public virtual void DataElement(string localName, string content)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">localName</span></td>
        <td><p>The element's local name.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">content</span></td>
        <td><p>The character data content.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_DataElement_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Sax.SAXException.html">SAXException</a></td>
        <td><p>If there is an error
writing the empty tag, or if a handler further down
the filter chain raises an exception.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_DataElement_System_String_System_String__seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartElement_System_String_System_String_System_String_Sax_IAttributes_">StartElement(string, string, string, IAttributes)</a></div>
      <div><a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_Characters_System_String_">Characters(string)</a></div>
      <div><a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndElement_System_String_System_String_System_String_">EndElement(string, string, string)</a></div>
  </div>
  <a id="TagSoup_XMLWriter_DataElement_" data-uid="TagSoup.XMLWriter.DataElement*"></a>
  <h4 id="TagSoup_XMLWriter_DataElement_System_String_System_String_System_String_" data-uid="TagSoup.XMLWriter.DataElement(System.String,System.String,System.String)">DataElement(string, string, string)</h4>
  <div class="markdown level1 summary"><p>Write an element with character data content but no attributes.</p>
<p>
This is a convenience method to write a complete element
with character data content, including the start tag
and end tag.  This method provides an empty string
for the qname and an empty attribute list.
</p><p>
This method invokes
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartElement_System_String_System_String_System_String_Sax_IAttributes_">StartElement(string, string, string, IAttributes)</a>,
followed by
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_Characters_System_String_">Characters(string)</a>, followed by
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndElement_System_String_System_String_System_String_">EndElement(string, string, string)</a>.
</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public virtual void DataElement(string uri, string localName, string content)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">uri</span></td>
        <td><p>The element's Namespace URI.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">localName</span></td>
        <td><p>The element's local name.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">content</span></td>
        <td><p>The character data content.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_DataElement_System_String_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Sax.SAXException.html">SAXException</a></td>
        <td><p>If there is an error
writing the empty tag, or if a handler further down
the filter chain raises an exception.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_DataElement_System_String_System_String_System_String__seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartElement_System_String_System_String_System_String_Sax_IAttributes_">StartElement(string, string, string, IAttributes)</a></div>
      <div><a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_Characters_System_String_">Characters(string)</a></div>
      <div><a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndElement_System_String_System_String_System_String_">EndElement(string, string, string)</a></div>
  </div>
  <a id="TagSoup_XMLWriter_DataElement_" data-uid="TagSoup.XMLWriter.DataElement*"></a>
  <h4 id="TagSoup_XMLWriter_DataElement_System_String_System_String_System_String_Sax_IAttributes_System_String_" data-uid="TagSoup.XMLWriter.DataElement(System.String,System.String,System.String,Sax.IAttributes,System.String)">DataElement(string, string, string, IAttributes, string)</h4>
  <div class="markdown level1 summary"><p>Write an element with character data content.</p>
<p>
This is a convenience method to write a complete element
with character data content, including the start tag
and end tag.
</p><p>
This method invokes
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartElement_System_String_System_String_System_String_Sax_IAttributes_">StartElement(string, string, string, IAttributes)</a>,
followed by
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_Characters_System_String_">Characters(string)</a>, followed by
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndElement_System_String_System_String_System_String_">EndElement(string, string, string)</a>.
</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public virtual void DataElement(string uri, string localName, string qName, IAttributes atts, string content)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">uri</span></td>
        <td><p>The element's Namespace URI.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">localName</span></td>
        <td><p>The element's local name.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">qName</span></td>
        <td><p>The element's default qualified name.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="Sax.IAttributes.html">IAttributes</a></td>
        <td><span class="parametername">atts</span></td>
        <td><p>The element's attributes.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">content</span></td>
        <td><p>The character data content.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_DataElement_System_String_System_String_System_String_Sax_IAttributes_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Sax.SAXException.html">SAXException</a></td>
        <td><p>If there is an error
writing the empty tag, or if a handler further down
the filter chain raises an exception.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_DataElement_System_String_System_String_System_String_Sax_IAttributes_System_String__seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartElement_System_String_System_String_System_String_Sax_IAttributes_">StartElement(string, string, string, IAttributes)</a></div>
      <div><a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_Characters_System_String_">Characters(string)</a></div>
      <div><a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndElement_System_String_System_String_System_String_">EndElement(string, string, string)</a></div>
  </div>
  <a id="TagSoup_XMLWriter_EmptyElement_" data-uid="TagSoup.XMLWriter.EmptyElement*"></a>
  <h4 id="TagSoup_XMLWriter_EmptyElement_System_String_" data-uid="TagSoup.XMLWriter.EmptyElement(System.String)">EmptyElement(string)</h4>
  <div class="markdown level1 summary"><p>Add an empty element without a Namespace URI, qname or attributes.</p>
<p>
This method will supply an empty string for the qname,
and empty string for the Namespace URI, and an empty
attribute list.  It invokes
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EmptyElement_System_String_System_String_System_String_Sax_IAttributes_">EmptyElement(string, string, string, IAttributes)</a>
directly.
</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public virtual void EmptyElement(string localName)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">localName</span></td>
        <td><p>The element's local name.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_EmptyElement_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Sax.SAXException.html">SAXException</a></td>
        <td><p>If there is an error
writing the empty tag, or if a handler further down
the filter chain raises an exception.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_EmptyElement_System_String__seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EmptyElement_System_String_System_String_System_String_Sax_IAttributes_">EmptyElement(string, string, string, IAttributes)</a></div>
  </div>
  <a id="TagSoup_XMLWriter_EmptyElement_" data-uid="TagSoup.XMLWriter.EmptyElement*"></a>
  <h4 id="TagSoup_XMLWriter_EmptyElement_System_String_System_String_" data-uid="TagSoup.XMLWriter.EmptyElement(System.String,System.String)">EmptyElement(string, string)</h4>
  <div class="markdown level1 summary"><p>Add an empty element without a qname or attributes.</p>
<p>
This method will supply an empty string for the qname
and an empty attribute list.  It invokes
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EmptyElement_System_String_System_String_System_String_Sax_IAttributes_">EmptyElement(string, string, string, IAttributes)</a>
directly.
</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public virtual void EmptyElement(string uri, string localName)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">uri</span></td>
        <td><p>The element's Namespace URI.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">localName</span></td>
        <td><p>The element's local name.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_EmptyElement_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Sax.SAXException.html">SAXException</a></td>
        <td><p>If there is an error
writing the empty tag, or if a handler further down
the filter chain raises an exception.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_EmptyElement_System_String_System_String__seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EmptyElement_System_String_System_String_System_String_Sax_IAttributes_">EmptyElement(string, string, string, IAttributes)</a></div>
  </div>
  <a id="TagSoup_XMLWriter_EmptyElement_" data-uid="TagSoup.XMLWriter.EmptyElement*"></a>
  <h4 id="TagSoup_XMLWriter_EmptyElement_System_String_System_String_System_String_Sax_IAttributes_" data-uid="TagSoup.XMLWriter.EmptyElement(System.String,System.String,System.String,Sax.IAttributes)">EmptyElement(string, string, string, IAttributes)</h4>
  <div class="markdown level1 summary"><p>Write an empty element.
This method writes an empty element tag rather than a start tag
followed by an end tag.  Both a <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartElement_System_String_System_String_System_String_Sax_IAttributes_">StartElement(string, string, string, IAttributes)</a>
and an <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndElement_System_String_System_String_System_String_">EndElement(string, string, string)</a> event will
be passed on down the filter chain.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public virtual void EmptyElement(string uri, string localName, string qName, IAttributes atts)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">uri</span></td>
        <td><p>The element's Namespace URI, or the empty string
if the element has no Namespace or if Namespace
processing is not being performed.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">localName</span></td>
        <td><p>The element's local name (without prefix).  This
parameter must be provided.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">qName</span></td>
        <td><p>The element's qualified name (with prefix), or
the empty string if none is available.  This parameter
is strictly advisory: the writer may or may not use
the prefix attached.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="Sax.IAttributes.html">IAttributes</a></td>
        <td><span class="parametername">atts</span></td>
        <td><p>The element's attribute list.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_EmptyElement_System_String_System_String_System_String_Sax_IAttributes__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Sax.SAXException.html">SAXException</a></td>
        <td><p>If there is an error
writing the empty tag, or if a handler further down
the filter chain raises an exception.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_EmptyElement_System_String_System_String_System_String_Sax_IAttributes__seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartElement_System_String_">StartElement(string)</a></div>
      <div><a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartElement_System_String_System_String_">StartElement(string, string)</a></div>
      <div><a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartElement_System_String_System_String_System_String_Sax_IAttributes_">StartElement(string, string, string, IAttributes)</a></div>
      <div><a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndElement_System_String_">EndElement(string)</a></div>
      <div><a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndElement_System_String_System_String_">EndElement(string, string)</a></div>
      <div><a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndElement_System_String_System_String_System_String_">EndElement(string, string, string)</a></div>
  </div>
  <a id="TagSoup_XMLWriter_EndCDATA_" data-uid="TagSoup.XMLWriter.EndCDATA*"></a>
  <h4 id="TagSoup_XMLWriter_EndCDATA" data-uid="TagSoup.XMLWriter.EndCDATA">EndCDATA()</h4>
  <div class="markdown level1 summary"><p>Report the end of a CDATA section.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public virtual void EndCDATA()</code></pre>
  </div>
  <h5 id="TagSoup_XMLWriter_EndCDATA_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Sax.SAXException.html">SAXException</a></td>
        <td><p>The application may raise an exception.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_EndCDATA_seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="Sax.Ext.ILexicalHandler.html#Sax_Ext_ILexicalHandler_StartCDATA">StartCDATA</a>()</div>
  </div>
  <a id="TagSoup_XMLWriter_EndDTD_" data-uid="TagSoup.XMLWriter.EndDTD*"></a>
  <h4 id="TagSoup_XMLWriter_EndDTD" data-uid="TagSoup.XMLWriter.EndDTD">EndDTD()</h4>
  <div class="markdown level1 summary"><p>Report the end of DTD declarations.</p>
<p></p>
This method is intended to report the end of the
DOCTYPE declaration; if the document has no DOCTYPE declaration,
this method will not be invoked.
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public virtual void EndDTD()</code></pre>
  </div>
  <h5 id="TagSoup_XMLWriter_EndDTD_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Sax.SAXException.html">SAXException</a></td>
        <td><p>The application may raise an exception.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_EndDTD_seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="Sax.Ext.ILexicalHandler.html#Sax_Ext_ILexicalHandler_StartDTD_System_String_System_String_System_String_">StartDTD</a>(<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a>, <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a>, <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a>)</div>
  </div>
  <a id="TagSoup_XMLWriter_EndDocument_" data-uid="TagSoup.XMLWriter.EndDocument*"></a>
  <h4 id="TagSoup_XMLWriter_EndDocument" data-uid="TagSoup.XMLWriter.EndDocument">EndDocument()</h4>
  <div class="markdown level1 summary"><p>Write a newline at the end of the document.
Pass the event on down the filter chain for further processing.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public override void EndDocument()</code></pre>
  </div>
  <h5 class="overrides">Overrides</h5>
  <div><a class="xref" href="Sax.Helpers.XMLFilter.html#Sax_Helpers_XMLFilter_EndDocument">XMLFilter.EndDocument()</a></div>
  <h5 id="TagSoup_XMLWriter_EndDocument_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Sax.SAXException.html">SAXException</a></td>
        <td><p>If there is an error
writing the newline, or if a handler further down
the filter chain raises an exception.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_EndDocument_seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="Sax.IContentHandler.html#Sax_IContentHandler_EndDocument">EndDocument</a>()</div>
  </div>
  <a id="TagSoup_XMLWriter_EndElement_" data-uid="TagSoup.XMLWriter.EndElement*"></a>
  <h4 id="TagSoup_XMLWriter_EndElement_System_String_" data-uid="TagSoup.XMLWriter.EndElement(System.String)">EndElement(string)</h4>
  <div class="markdown level1 summary"><p>End an element without a Namespace URI or qname.</p>
<p>
This method will supply an empty string for the qName
and an empty string for the Namespace URI.
It invokes <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndElement_System_String_System_String_System_String_">EndElement(string, string, string)</a>
directly.
</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public virtual void EndElement(string localName)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">localName</span></td>
        <td><p>The element's local name.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_EndElement_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Sax.SAXException.html">SAXException</a></td>
        <td><p>If there is an error
writing the end tag, or if a handler further down
the filter chain raises an exception.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_EndElement_System_String__seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndElement_System_String_System_String_System_String_">EndElement(string, string, string)</a></div>
  </div>
  <a id="TagSoup_XMLWriter_EndElement_" data-uid="TagSoup.XMLWriter.EndElement*"></a>
  <h4 id="TagSoup_XMLWriter_EndElement_System_String_System_String_" data-uid="TagSoup.XMLWriter.EndElement(System.String,System.String)">EndElement(string, string)</h4>
  <div class="markdown level1 summary"><p>End an element without a qname.</p>
<p>
This method will supply an empty string for the qName.
It invokes <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndElement_System_String_System_String_System_String_">EndElement(string, string, string)</a>
directly.
</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public virtual void EndElement(string uri, string localName)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">uri</span></td>
        <td><p>The element's Namespace URI.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">localName</span></td>
        <td><p>The element's local name.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_EndElement_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Sax.SAXException.html">SAXException</a></td>
        <td><p>If there is an error
writing the end tag, or if a handler further down
the filter chain raises an exception.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_EndElement_System_String_System_String__seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndElement_System_String_System_String_System_String_">EndElement(string, string, string)</a></div>
  </div>
  <a id="TagSoup_XMLWriter_EndElement_" data-uid="TagSoup.XMLWriter.EndElement*"></a>
  <h4 id="TagSoup_XMLWriter_EndElement_System_String_System_String_System_String_" data-uid="TagSoup.XMLWriter.EndElement(System.String,System.String,System.String)">EndElement(string, string, string)</h4>
  <div class="markdown level1 summary"><p>Write an end tag.
Pass the event on down the filter chain for further processing.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public override void EndElement(string uri, string localName, string qName)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">uri</span></td>
        <td><p>The Namespace URI, or the empty string if none
is available.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">localName</span></td>
        <td><p>The element's local (unprefixed) name (required).</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">qName</span></td>
        <td><p>The element's qualified (prefixed) name, or the
empty string is none is available.  This method will
use the qName as a template for generating a prefix
if necessary, but it is not guaranteed to use the
same qName.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><a class="xref" href="Sax.Helpers.XMLFilter.html#Sax_Helpers_XMLFilter_EndElement_System_String_System_String_System_String_">XMLFilter.EndElement(string, string, string)</a></div>
  <h5 id="TagSoup_XMLWriter_EndElement_System_String_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Sax.SAXException.html">SAXException</a></td>
        <td><p>If there is an error
writing the end tag, or if a handler further down
the filter chain raises an exception.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_EndElement_System_String_System_String_System_String__seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="Sax.IContentHandler.html#Sax_IContentHandler_EndElement_System_String_System_String_System_String_">EndElement</a>(<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a>, <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a>, <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a>)</div>
  </div>
  <a id="TagSoup_XMLWriter_EndEntity_" data-uid="TagSoup.XMLWriter.EndEntity*"></a>
  <h4 id="TagSoup_XMLWriter_EndEntity_System_String_" data-uid="TagSoup.XMLWriter.EndEntity(System.String)">EndEntity(string)</h4>
  <div class="markdown level1 summary"><p>Report the end of an entity.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public virtual void EndEntity(string name)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">name</span></td>
        <td><p>The name of the entity that is ending.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_EndEntity_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Sax.SAXException.html">SAXException</a></td>
        <td><p>The application may raise an exception.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_EndEntity_System_String__seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="Sax.Ext.ILexicalHandler.html#Sax_Ext_ILexicalHandler_StartEntity_System_String_">StartEntity</a>(<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a>)</div>
  </div>
  <a id="TagSoup_XMLWriter_Flush_" data-uid="TagSoup.XMLWriter.Flush*"></a>
  <h4 id="TagSoup_XMLWriter_Flush" data-uid="TagSoup.XMLWriter.Flush">Flush()</h4>
  <div class="markdown level1 summary"><p>Flush the output.</p>
<p>
This method flushes the output stream.  It is especially useful
when you need to make certain that the entire document has
been written to output but do not want to close the output
stream.
</p><p>
This method is invoked automatically by the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method after writing a
document.
</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public virtual void Flush()</code></pre>
  </div>
  <h5 id="TagSoup_XMLWriter_Flush_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 id="TagSoup_XMLWriter_Flush_seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_Reset">Reset()</a></div>
  </div>
  <a id="TagSoup_XMLWriter_ForceNSDecl_" data-uid="TagSoup.XMLWriter.ForceNSDecl*"></a>
  <h4 id="TagSoup_XMLWriter_ForceNSDecl_System_String_" data-uid="TagSoup.XMLWriter.ForceNSDecl(System.String)">ForceNSDecl(string)</h4>
  <div class="markdown level1 summary"><p>Force a Namespace to be declared on the root element.</p>
<p>
By default, the XMLWriter will declare only the Namespaces
needed for an element; as a result, a Namespace may be
declared many places in a document if it is not used on the
root element.
</p><p>
This method forces a Namespace to be declared on the root
element even if it is not used there, and reduces the number
of xmlns attributes in the document.
</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public virtual void ForceNSDecl(string uri)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">uri</span></td>
        <td><p>The Namespace URI to declare.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_ForceNSDecl_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 id="TagSoup_XMLWriter_ForceNSDecl_System_String__seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_ForceNSDecl_System_String_System_String_">ForceNSDecl(string, string)</a></div>
      <div><a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a></div>
  </div>
  <a id="TagSoup_XMLWriter_ForceNSDecl_" data-uid="TagSoup.XMLWriter.ForceNSDecl*"></a>
  <h4 id="TagSoup_XMLWriter_ForceNSDecl_System_String_System_String_" data-uid="TagSoup.XMLWriter.ForceNSDecl(System.String,System.String)">ForceNSDecl(string, string)</h4>
  <div class="markdown level1 summary"><p>Force a Namespace declaration with a preferred prefix.</p>
<p>
This is a convenience method that invokes <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a>
then <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_ForceNSDecl_System_String_">ForceNSDecl(string)</a>.
</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public virtual void ForceNSDecl(string uri, string prefix)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">uri</span></td>
        <td><p>The Namespace URI to declare on the root element.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">prefix</span></td>
        <td><p>The preferred prefix for the Namespace, or &quot;&quot;
for the default Namespace.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_ForceNSDecl_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 id="TagSoup_XMLWriter_ForceNSDecl_System_String_System_String__seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a></div>
      <div><a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_ForceNSDecl_System_String_">ForceNSDecl(string)</a></div>
  </div>
  <a id="TagSoup_XMLWriter_GetOutputProperty_" data-uid="TagSoup.XMLWriter.GetOutputProperty*"></a>
  <h4 id="TagSoup_XMLWriter_GetOutputProperty_System_String_" data-uid="TagSoup.XMLWriter.GetOutputProperty(System.String)">GetOutputProperty(string)</h4>
  <div class="markdown level1 summary"><p>Filter to write an XML document from a SAX event stream.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public virtual string GetOutputProperty(string key)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">key</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_GetOutputProperty_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 id="TagSoup_XMLWriter_GetOutputProperty_System_String__seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="Sax.IXMLFilter.html">IXMLFilter</a></div>
      <div><a class="xref" href="Sax.IContentHandler.html">IContentHandler</a></div>
  </div>
  <a id="TagSoup_XMLWriter_GetPrefix_" data-uid="TagSoup.XMLWriter.GetPrefix*"></a>
  <h4 id="TagSoup_XMLWriter_GetPrefix_System_String_" data-uid="TagSoup.XMLWriter.GetPrefix(System.String)">GetPrefix(string)</h4>
  <div class="markdown level1 summary"><p>Get the current or preferred prefix for a Namespace URI.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public virtual string GetPrefix(string uri)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">uri</span></td>
        <td><p>The Namespace URI.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><p>The preferred prefix, or &quot;&quot; for the default Namespace.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_GetPrefix_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 id="TagSoup_XMLWriter_GetPrefix_System_String__seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a></div>
  </div>
  <a id="TagSoup_XMLWriter_IgnorableWhitespace_" data-uid="TagSoup.XMLWriter.IgnorableWhitespace*"></a>
  <h4 id="TagSoup_XMLWriter_IgnorableWhitespace_System_Char___System_Int32_System_Int32_" data-uid="TagSoup.XMLWriter.IgnorableWhitespace(System.Char[],System.Int32,System.Int32)">IgnorableWhitespace(char[], int, int)</h4>
  <div class="markdown level1 summary"><p>Write ignorable whitespace.
Pass the event on down the filter chain for further processing.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public override void IgnorableWhitespace(char[] ch, int start, int length)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.char">char</a>[]</td>
        <td><span class="parametername">ch</span></td>
        <td><p>The array of characters to write.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></td>
        <td><span class="parametername">start</span></td>
        <td><p>The starting position in the array.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></td>
        <td><span class="parametername">length</span></td>
        <td><p>The number of characters to write.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><a class="xref" href="Sax.Helpers.XMLFilter.html#Sax_Helpers_XMLFilter_IgnorableWhitespace_System_Char___System_Int32_System_Int32_">XMLFilter.IgnorableWhitespace(char[], int, int)</a></div>
  <h5 id="TagSoup_XMLWriter_IgnorableWhitespace_System_Char___System_Int32_System_Int32__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Sax.SAXException.html">SAXException</a></td>
        <td><p>If there is an error
writing the whitespace, or if a handler further down
the filter chain raises an exception.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_IgnorableWhitespace_System_Char___System_Int32_System_Int32__seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="Sax.IContentHandler.html#Sax_IContentHandler_IgnorableWhitespace_System_Char___System_Int32_System_Int32_">IgnorableWhitespace</a>(<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.char">char</a>[], <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a>, <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a>)</div>
  </div>
  <a id="TagSoup_XMLWriter_ProcessingInstruction_" data-uid="TagSoup.XMLWriter.ProcessingInstruction*"></a>
  <h4 id="TagSoup_XMLWriter_ProcessingInstruction_System_String_System_String_" data-uid="TagSoup.XMLWriter.ProcessingInstruction(System.String,System.String)">ProcessingInstruction(string, string)</h4>
  <div class="markdown level1 summary"><p>Write a processing instruction.
Pass the event on down the filter chain for further processing.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public override void ProcessingInstruction(string target, string data)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">target</span></td>
        <td><p>The PI target.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">data</span></td>
        <td><p>The PI data.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><a class="xref" href="Sax.Helpers.XMLFilter.html#Sax_Helpers_XMLFilter_ProcessingInstruction_System_String_System_String_">XMLFilter.ProcessingInstruction(string, string)</a></div>
  <h5 id="TagSoup_XMLWriter_ProcessingInstruction_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Sax.SAXException.html">SAXException</a></td>
        <td><p>If there is an error
writing the PI, or if a handler further down
the filter chain raises an exception.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_ProcessingInstruction_System_String_System_String__seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="Sax.IContentHandler.html#Sax_IContentHandler_ProcessingInstruction_System_String_System_String_">ProcessingInstruction</a>(<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a>, <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a>)</div>
  </div>
  <a id="TagSoup_XMLWriter_Reset_" data-uid="TagSoup.XMLWriter.Reset*"></a>
  <h4 id="TagSoup_XMLWriter_Reset" data-uid="TagSoup.XMLWriter.Reset">Reset()</h4>
  <div class="markdown level1 summary"><p>Reset the writer.</p>
<p>
This method is especially useful if the writer throws an
exception before it is finished, and you want to reuse the
writer for a new document.  It is usually a good idea to
invoke <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_Flush">Flush()</a> before resetting the writer,
to make sure that no output is lost.
</p><p>
This method is invoked automatically by the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method before writing
a new document.
</p><p><strong>Note:</strong> this method will <em>not</em>
clear the prefix or URI information in the writer or
the selected output writer.
</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public virtual void Reset()</code></pre>
  </div>
  <h5 id="TagSoup_XMLWriter_Reset_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 id="TagSoup_XMLWriter_Reset_seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_Flush">Flush()</a></div>
  </div>
  <a id="TagSoup_XMLWriter_SetOutput_" data-uid="TagSoup.XMLWriter.SetOutput*"></a>
  <h4 id="TagSoup_XMLWriter_SetOutput_System_IO_TextWriter_" data-uid="TagSoup.XMLWriter.SetOutput(System.IO.TextWriter)">SetOutput(TextWriter)</h4>
  <div class="markdown level1 summary"><p>Set a new output destination for the document.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public virtual void SetOutput(TextWriter writer)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.io.textwriter">TextWriter</a></td>
        <td><span class="parametername">writer</span></td>
        <td><p>The output destination, or null to use
standard output.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_SetOutput_System_IO_TextWriter__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 id="TagSoup_XMLWriter_SetOutput_System_IO_TextWriter__seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_Flush">Flush()</a></div>
  </div>
  <a id="TagSoup_XMLWriter_SetOutputProperty_" data-uid="TagSoup.XMLWriter.SetOutputProperty*"></a>
  <h4 id="TagSoup_XMLWriter_SetOutputProperty_System_String_System_String_" data-uid="TagSoup.XMLWriter.SetOutputProperty(System.String,System.String)">SetOutputProperty(string, string)</h4>
  <div class="markdown level1 summary"><p>Filter to write an XML document from a SAX event stream.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public virtual void SetOutputProperty(string key, string value)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">key</span></td>
        <td></td>
      </tr>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">value</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_SetOutputProperty_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 id="TagSoup_XMLWriter_SetOutputProperty_System_String_System_String__seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="Sax.IXMLFilter.html">IXMLFilter</a></div>
      <div><a class="xref" href="Sax.IContentHandler.html">IContentHandler</a></div>
  </div>
  <a id="TagSoup_XMLWriter_SetPrefix_" data-uid="TagSoup.XMLWriter.SetPrefix*"></a>
  <h4 id="TagSoup_XMLWriter_SetPrefix_System_String_System_String_" data-uid="TagSoup.XMLWriter.SetPrefix(System.String,System.String)">SetPrefix(string, string)</h4>
  <div class="markdown level1 summary"><p>Specify a preferred prefix for a Namespace URI.</p>
<p>
Note that this method does not actually force the Namespace
to be declared; to do that, use the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_ForceNSDecl_System_String_">ForceNSDecl(string)</a>
method as well.
</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public virtual void SetPrefix(string uri, string prefix)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">uri</span></td>
        <td><p>The Namespace URI.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">prefix</span></td>
        <td><p>The preferred prefix, or &quot;&quot; to select
the default Namespace.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_SetPrefix_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 id="TagSoup_XMLWriter_SetPrefix_System_String_System_String__seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_GetPrefix_System_String_">GetPrefix(string)</a></div>
      <div><a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_ForceNSDecl_System_String_">ForceNSDecl(string)</a></div>
      <div><a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_ForceNSDecl_System_String_System_String_">ForceNSDecl(string, string)</a></div>
  </div>
  <a id="TagSoup_XMLWriter_StartCDATA_" data-uid="TagSoup.XMLWriter.StartCDATA*"></a>
  <h4 id="TagSoup_XMLWriter_StartCDATA" data-uid="TagSoup.XMLWriter.StartCDATA">StartCDATA()</h4>
  <div class="markdown level1 summary"><p>Report the start of a CDATA section.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public virtual void StartCDATA()</code></pre>
  </div>
  <h5 id="TagSoup_XMLWriter_StartCDATA_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The contents of the CDATA section will be reported through
the regular <a class="xref" href="Sax.IContentHandler.html#Sax_IContentHandler_Characters_System_Char___System_Int32_System_Int32_">Characters(char[], int, int)</a>
event; this event is intended only to report
the boundary.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Sax.SAXException.html">SAXException</a></td>
        <td><p>The application may raise an exception.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_StartCDATA_seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="Sax.Ext.ILexicalHandler.html#Sax_Ext_ILexicalHandler_EndEntity_System_String_">EndEntity</a>(<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a>)</div>
  </div>
  <a id="TagSoup_XMLWriter_StartDTD_" data-uid="TagSoup.XMLWriter.StartDTD*"></a>
  <h4 id="TagSoup_XMLWriter_StartDTD_System_String_System_String_System_String_" data-uid="TagSoup.XMLWriter.StartDTD(System.String,System.String,System.String)">StartDTD(string, string, string)</h4>
  <div class="markdown level1 summary"><p>Report the start of DTD declarations, if any.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public virtual void StartDTD(string name, string publicId, string systemId)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">name</span></td>
        <td><p>The document type name.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">publicId</span></td>
        <td><p>The declared public identifier for the
external DTD subset, or null if none was declared.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">systemId</span></td>
        <td><p>The declared system identifier for the
external DTD subset, or null if none was declared.
(Note that this is not resolved against the document
base URI.)</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_StartDTD_System_String_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This method is intended to report the beginning of the
DOCTYPE declaration; if the document has no DOCTYPE declaration,
this method will not be invoked.</p>
<p></p>
All declarations reported through 
<a class="xref" href="Sax.IDTDHandler.html">IDTDHandler</a> or
<a class="xref" href="Sax.Ext.IDeclHandler.html">IDeclHandler</a> events must appear
between the startDTD and <a class="xref" href="Sax.Ext.ILexicalHandler.html#Sax_Ext_ILexicalHandler_EndDTD">EndDTD()</a> events.
Declarations are assumed to belong to the internal DTD subset
unless they appear between <a class="xref" href="Sax.Ext.ILexicalHandler.html#Sax_Ext_ILexicalHandler_StartEntity_System_String_">StartEntity(string)</a>
and <a class="xref" href="Sax.Ext.ILexicalHandler.html#Sax_Ext_ILexicalHandler_EndEntity_System_String_">EndEntity(string)</a> events.  Comments and
processing instructions from the DTD should also be reported
between the <a class="xref" href="Sax.Ext.ILexicalHandler.html#Sax_Ext_ILexicalHandler_StartDTD_System_String_System_String_System_String_">StartDTD(string, string, string)</a> and <a class="xref" href="Sax.Ext.ILexicalHandler.html#Sax_Ext_ILexicalHandler_EndDTD">EndDTD()</a> events, in their original
order of(logical) occurrence; they are not required to
appear in their correct locations relative to <a class="xref" href="Sax.IDTDHandler.html">IDTDHandler</a>
or <a class="xref" href="Sax.Ext.IDeclHandler.html">IDeclHandler</a> events, however.
<p></p>
Note that the start / endDTD events will appear within
the start / endDocument events from <a class="xref" href="Sax.IContentHandler.html">IContentHandler</a> and
before the first <a class="xref" href="Sax.IContentHandler.html#Sax_IContentHandler_StartElement_System_String_System_String_System_String_Sax_IAttributes_">StartElement(string, string, string, IAttributes)</a>
event.
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Sax.SAXException.html">SAXException</a></td>
        <td><p>The application may raise an exception.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_StartDTD_System_String_System_String_System_String__seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="Sax.IXMLFilter.html">IXMLFilter</a></div>
      <div><a class="xref" href="Sax.IContentHandler.html">IContentHandler</a></div>
  </div>
  <a id="TagSoup_XMLWriter_StartDocument_" data-uid="TagSoup.XMLWriter.StartDocument*"></a>
  <h4 id="TagSoup_XMLWriter_StartDocument" data-uid="TagSoup.XMLWriter.StartDocument">StartDocument()</h4>
  <div class="markdown level1 summary"><p>Write the XML declaration at the beginning of the document.
Pass the event on down the filter chain for further processing.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public override void StartDocument()</code></pre>
  </div>
  <h5 class="overrides">Overrides</h5>
  <div><a class="xref" href="Sax.Helpers.XMLFilter.html#Sax_Helpers_XMLFilter_StartDocument">XMLFilter.StartDocument()</a></div>
  <h5 id="TagSoup_XMLWriter_StartDocument_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Sax.SAXException.html">SAXException</a></td>
        <td><p>If there is an error
writing the XML declaration, or if a handler further down
the filter chain raises an exception.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_StartDocument_seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="Sax.IContentHandler.html#Sax_IContentHandler_StartDocument">StartDocument</a>()</div>
  </div>
  <a id="TagSoup_XMLWriter_StartElement_" data-uid="TagSoup.XMLWriter.StartElement*"></a>
  <h4 id="TagSoup_XMLWriter_StartElement_System_String_" data-uid="TagSoup.XMLWriter.StartElement(System.String)">StartElement(string)</h4>
  <div class="markdown level1 summary"><p>Start a new element without a qname, attributes or a Namespace URI.</p>
<p>
This method will provide an empty string for the
Namespace URI, and empty string for the qualified name,
and a default empty attribute list. It invokes
#startElement(string, string, string, Attributes)}
directly.
</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public virtual void StartElement(string localName)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">localName</span></td>
        <td><p>The element's local name.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_StartElement_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Sax.SAXException.html">SAXException</a></td>
        <td><p>If there is an error
writing the start tag, or if a handler further down
the filter chain raises an exception.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_StartElement_System_String__seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartElement_System_String_System_String_System_String_Sax_IAttributes_">StartElement(string, string, string, IAttributes)</a></div>
  </div>
  <a id="TagSoup_XMLWriter_StartElement_" data-uid="TagSoup.XMLWriter.StartElement*"></a>
  <h4 id="TagSoup_XMLWriter_StartElement_System_String_System_String_" data-uid="TagSoup.XMLWriter.StartElement(System.String,System.String)">StartElement(string, string)</h4>
  <div class="markdown level1 summary"><p>Start a new element without a qname or attributes.</p>
<p>
This method will provide a default empty attribute
list and an empty string for the qualified name.
It invokes <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartElement_System_String_System_String_System_String_Sax_IAttributes_">StartElement(string, string, string, IAttributes)</a>
directly.
</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public virtual void StartElement(string uri, string localName)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">uri</span></td>
        <td><p>The element's Namespace URI.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">localName</span></td>
        <td><p>The element's local name.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_StartElement_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Sax.SAXException.html">SAXException</a></td>
        <td><p>If there is an error
writing the start tag, or if a handler further down
the filter chain raises an exception.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_StartElement_System_String_System_String__seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartElement_System_String_System_String_System_String_Sax_IAttributes_">StartElement(string, string, string, IAttributes)</a></div>
  </div>
  <a id="TagSoup_XMLWriter_StartElement_" data-uid="TagSoup.XMLWriter.StartElement*"></a>
  <h4 id="TagSoup_XMLWriter_StartElement_System_String_System_String_System_String_Sax_IAttributes_" data-uid="TagSoup.XMLWriter.StartElement(System.String,System.String,System.String,Sax.IAttributes)">StartElement(string, string, string, IAttributes)</h4>
  <div class="markdown level1 summary"><p>Write a start tag.
Pass the event on down the filter chain for further processing.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public override void StartElement(string uri, string localName, string qName, IAttributes atts)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">uri</span></td>
        <td><p>The Namespace URI, or the empty string if none
is available.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">localName</span></td>
        <td><p>The element's local (unprefixed) name (required).</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">qName</span></td>
        <td><p>The element's qualified (prefixed) name, or the
empty string is none is available.  This method will
use the qName as a template for generating a prefix
if necessary, but it is not guaranteed to use the
same qName.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="Sax.IAttributes.html">IAttributes</a></td>
        <td><span class="parametername">atts</span></td>
        <td><p>The element's attribute list (must not be null).</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><a class="xref" href="Sax.Helpers.XMLFilter.html#Sax_Helpers_XMLFilter_StartElement_System_String_System_String_System_String_Sax_IAttributes_">XMLFilter.StartElement(string, string, string, IAttributes)</a></div>
  <h5 id="TagSoup_XMLWriter_StartElement_System_String_System_String_System_String_Sax_IAttributes__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This class can be used by itself or as part of a SAX event
stream: it takes as input a series of SAX2 ContentHandler
events and uses the information in those events to write
an XML document.  Since this class is a filter, it can also
pass the events on down a filter chain for further processing
(you can use the XMLWriter to take a snapshot of the current
state at any point in a filter chain), and it can be
used directly as a ContentHandler for a SAX2 XMLReader.</p>
<p>
The client creates a document by invoking the methods for
standard SAX2 events, always beginning with the
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_StartDocument">StartDocument()</a> method and ending with
the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_EndDocument">EndDocument()</a> method.  There are convenience
methods provided so that clients to not have to create empty
attribute lists or provide empty strings as parameters; for
example, the method invocation
</p><pre><code class="lang-csharp">w.StartElement("foo");</code></pre><p>is equivalent to the regular SAX2 ContentHandler method</p><pre><code class="lang-csharp">w.StartElement("", "foo", "", new Attributes());</code></pre><p>
Except that it is more efficient because it does not allocate
a new empty attribute list each time.  The following code will send
a simple XML document to standard output:
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.StartElement("greeting");
    w.Characters("Hello, world!");
    w.EndElement("greeting");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;greeting&gt;Hello, world!&lt;/greeting&gt;</code></pre><p>
In fact, there is an even simpler convenience method,
<a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_DataElement_System_String_System_String_">DataElement(string, string)</a>, designed for writing elements that
contain only character data, so the code to generate the
document could be shortened to
</p><pre><code class="lang-csharp">XMLWriter w = new XMLWriter();
    w.StartDocument();
    w.DataElement("greeting", "Hello, world!");
    w.EndDocument();</code></pre><h2>Whitespace</h2><p>
According to the XML Recommendation, <em>all</em> whitespace
in an XML document is potentially significant to an application,
so this class never adds newlines or indentation.  If you
insert three elements in a row, as in
</p><pre><code class="lang-csharp">w.DataElement("item", "1");
    w.DataElement("item", "2");
    w.DataElement("item", "3");</code></pre><p>you will end up with</p><pre><code class="lang-csharp">&lt;item&gt;1&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;&lt;item&gt;3&lt;/item&gt;</code></pre><p>
You need to invoke one of the <code>Characters</code> methods
explicitly to add newlines or indentation.  Alternatively, you
can use DataWriter, which
is derived from this class -- it is optimized for writing
purely data-oriented (or field-oriented) XML, and does automatic
linebreaks and indentation (but does not support mixed content
properly).
</p><h2>Namespace Support</h2><p>
The writer contains extensive support for XML Namespaces, so that
a client application does not have to keep track of prefixes and
supply <code>xmlns</code> attributes.  By default, the XML writer will
generate Namespace declarations in the form _NS1, _NS2, etc., wherever
they are needed, as in the following example:
</p><pre><code class="lang-csharp">w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;_NS1:foo xmlns:_NS1="http://www.foo.com/ns/"/&gt;</code></pre><p>
In many cases, document authors will prefer to choose their
own prefixes rather than using the (ugly) default names.  The
XML writer allows two methods for selecting prefixes:
</p><ol><li>the qualified name</li><li>the <a class="xref" href="TagSoup.XMLWriter.html#TagSoup_XMLWriter_SetPrefix_System_String_System_String_">SetPrefix(string, string)</a> method.</li></ol><p>
Whenever the XML writer finds a new Namespace URI, it checks
to see if a qualified (prefixed) name is also available; if so
it attempts to use the name's prefix (as long as the prefix is
not already in use for another Namespace URI).
</p><p>
Before writing a document, the client can also pre-map a prefix
to a Namespace URI with the setPrefix method:
</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "foo");
    w.StartDocument();
    w.EmptyElement("http://www.foo.com/ns/", "foo");
    w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo:foo xmlns:foo="http://www.foo.com/ns/"/&gt;</code></pre><p>The default Namespace simply uses an empty string as the prefix:</p><pre><code class="lang-csharp">w.SetPrefix("http://www.foo.com/ns/", "");
                                                                              w.StartDocument();
                                                                              w.EmptyElement("http://www.foo.com/ns/", "foo");
                                                                              w.EndDocument();</code></pre><p>The resulting document will look like this:</p><pre><code class="lang-csharp">&lt;?xml version="1.0" standalone="yes"?&gt;
                                                         &lt;foo xmlns="http://www.foo.com/ns/"/&gt;</code></pre><p>
By default, the XML writer will not declare a Namespace until
it is actually used.  Sometimes, this approach will create
a large number of Namespace declarations, as in the following
example:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title xmlns:dc="http://www.purl.org/dc/"&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator xmlns:dc="http://www.purl.org/dc/"&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date xmlns:dc="http://www.purl.org/dc/"&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
The "rdf" prefix is declared only once, because the RDF Namespace
is used by the root element and can be inherited by all of its
descendants; the "dc" prefix, on the other hand, is declared three
times, because no higher element uses the Namespace.  To solve this
problem, you can instruct the XML writer to predeclare Namespaces
on the root element even if they are not used there:
</p><pre><code class="lang-csharp">w.ForceNSDecl("http://www.purl.org/dc/");</code></pre><p>
Now, the "dc" prefix will be declared on the root element even
though it's not needed there, and can be inherited by its
descendants:
</p><pre><code class="lang-csharp">&lt;xml version="1.0" standalone="yes"?&gt;
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://www.purl.org/dc/"&gt;
    &lt;rdf:Description about="http://www.foo.com/ids/books/12345"&gt;
    &lt;dc:title&gt;A Dark Night&lt;/dc:title&gt;
    &lt;dc:creator&gt;Jane Smith&lt;/dc:title&gt;
    &lt;dc:date&gt;2000-09-09&lt;/dc:title&gt;
    &lt;/rdf:Description&gt;
    &lt;/rdf:RDF&gt;</code></pre><p>
This approach is also useful for declaring Namespace prefixes
that be used by qualified names appearing in attribute values or
character data.
</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Sax.SAXException.html">SAXException</a></td>
        <td><p>If there is an error
writing the start tag, or if a handler further down
the filter chain raises an exception.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_StartElement_System_String_System_String_System_String_Sax_IAttributes__seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="Sax.IContentHandler.html#Sax_IContentHandler_StartElement_System_String_System_String_System_String_Sax_IAttributes_">StartElement</a>(<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a>, <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a>, <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a>, <a class="xref" href="Sax.IAttributes.html">IAttributes</a>)</div>
  </div>
  <a id="TagSoup_XMLWriter_StartEntity_" data-uid="TagSoup.XMLWriter.StartEntity*"></a>
  <h4 id="TagSoup_XMLWriter_StartEntity_System_String_" data-uid="TagSoup.XMLWriter.StartEntity(System.String)">StartEntity(string)</h4>
  <div class="markdown level1 summary"><p>Report the beginning of some internal and external XML entities.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang- hljs">public virtual void StartEntity(string name)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></td>
        <td><span class="parametername">name</span></td>
        <td><p>The name of the entity.  If it is a parameter
entity, the name will begin with '%', and if it is the
external DTD subset, it will be &quot;[dtd]&quot;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_StartEntity_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The reporting of parameter entities (including
the external DTD subset) is optional, and SAX2 drivers that
report LexicalHandler events may not implement it; you can use the
<a href="http://xml.org/sax/features/lexical-handler/parameter-entities">http://xml.org/sax/features/lexical-handler/parameter-entities</a>
feature to query or control the reporting of parameter entities.</p>
<p></p>
General entities are reported with their regular names,
parameter entities have '%' prepended to their names, and 
the external DTD subset has the pseudo-entity name "[dtd]".
<p></p>
When a SAX2 driver is providing these events, all other 
events must be properly nested within start/end entity 
events. There is no additional requirement that events from 
<a class="xref" href="Sax.Ext.IDeclHandler.html">IDeclHandler</a> or
<a class="xref" href="Sax.IDTDHandler.html">IDTDHandler</a> be properly ordered.
<p></p>
Note that skipped entities will be reported through the
<a class="xref" href="Sax.IContentHandler.html#Sax_IContentHandler_SkippedEntity_System_String_">SkippedEntity(string)</a>
event, which is part of the ContentHandler interface.
<p></p>Because of the streaming event model that SAX uses, some
entity boundaries cannot be reported under any
circumstances:
<ul><li>general entities within attribute values</li><li>parameter entities within declarations</li></ul><p></p>These will be silently expanded, with no indication of where
the original entity boundaries were.
<p></p>Note also that the boundaries of character references (which
are not really entities anyway) are not reported.
<p></p>All start/endEntity events must be properly nested.
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Sax.SAXException.html">SAXException</a></td>
        <td><p>The application may raise an exception.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TagSoup_XMLWriter_StartEntity_System_String__seealso">See Also</h5>
  <div class="seealso">
      <div><a class="xref" href="Sax.Ext.ILexicalHandler.html#Sax_Ext_ILexicalHandler_EndEntity_System_String_">EndEntity</a>(<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a>)</div>
      <div><a class="xref" href="Sax.Ext.IDeclHandler.html#Sax_Ext_IDeclHandler_InternalEntityDecl_System_String_System_String_">InternalEntityDecl</a>(<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a>, <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a>)</div>
      <div><a class="xref" href="Sax.Ext.IDeclHandler.html#Sax_Ext_IDeclHandler_ExternalEntityDecl_System_String_System_String_System_String_">ExternalEntityDecl</a>(<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a>, <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a>, <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a>)</div>
  </div>
  <h3 id="implements">Implements</h3>
  <div>
      <a class="xref" href="Sax.IXMLFilter.html">IXMLFilter</a>
  </div>
  <div>
      <a class="xref" href="Sax.IXMLReader.html">IXMLReader</a>
  </div>
  <div>
      <a class="xref" href="Sax.IEntityResolver.html">IEntityResolver</a>
  </div>
  <div>
      <a class="xref" href="Sax.IDTDHandler.html">IDTDHandler</a>
  </div>
  <div>
      <a class="xref" href="Sax.IContentHandler.html">IContentHandler</a>
  </div>
  <div>
      <a class="xref" href="Sax.IErrorHandler.html">IErrorHandler</a>
  </div>
  <div>
      <a class="xref" href="Sax.Ext.ILexicalHandler.html">ILexicalHandler</a>
  </div>
  <h3 id="seealso">See Also</h3>
  <div class="seealso">
      <div><a class="xref" href="Sax.IXMLFilter.html">IXMLFilter</a></div>
      <div><a class="xref" href="Sax.IContentHandler.html">IContentHandler</a></div>
  </div>
</article>
          </div>

          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>

      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
      Copyright &copy; 2024 The Apache Software Foundation, Licensed under the <a href='http://www.apache.org/licenses/LICENSE-2.0' target='_blank'>Apache License, Version 2.0</a><br> <small>Apache Lucene.Net, Lucene.Net, Apache, the Apache feather logo, and the Apache Lucene.Net project logo are trademarks of The Apache Software Foundation. <br>All other marks mentioned may be trademarks or registered trademarks of their respective owners.</small>
      
          </div>
        </div>
      </footer>
    </div>

    <script type="text/javascript" src="https://lucenenet.apache.org/docs/4.8.0-beta00017/styles/docfx.vendor.min.js"></script>
    <script type="text/javascript" src="https://lucenenet.apache.org/docs/4.8.0-beta00017/styles/docfx.js"></script>
    <script type="text/javascript" src="https://lucenenet.apache.org/docs/4.8.0-beta00017/styles/main.js"></script>
  </body>
</html>
