{
  "Lucene.Net.Demo.Facet.AssociationsFacetsExample.html": {
    "href": "Lucene.Net.Demo.Facet.AssociationsFacetsExample.html",
    "title": "Class AssociationsFacetsExample | Apache Lucene.NET 4.8.0-beta00015 Documentation",
    "keywords": "Class AssociationsFacetsExample Shows example usage of category associations. Inheritance System.Object AssociationsFacetsExample Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Lucene.Net.Demo.Facet Assembly : Lucene.Net.Demo.dll Syntax public class AssociationsFacetsExample Examples using Lucene.Net.Analysis.Core; using Lucene.Net.Documents; using Lucene.Net.Facet; using Lucene.Net.Facet.Taxonomy; using Lucene.Net.Facet.Taxonomy.Directory; using Lucene.Net.Index; using Lucene.Net.Search; using Lucene.Net.Store; using Lucene.Net.Util; using System; using System.Collections.Generic; namespace Lucene.Net.Demo.Facet { /// <summary> /// Shows example usage of category associations. /// </summary> public class AssociationsFacetsExample { /// <summary> /// Using a constant for all functionality related to a specific index /// is the best strategy. This allows you to upgrade Lucene.Net first /// and plan the upgrade of the index binary format for a later time. /// Once the index is upgraded, you simply need to update the constant /// version and redeploy your application. /// </summary> private const LuceneVersion EXAMPLE_VERSION = LuceneVersion.LUCENE_48; private readonly Directory indexDir = new RAMDirectory(); private readonly Directory taxoDir = new RAMDirectory(); private readonly FacetsConfig config; /// <summary>Empty constructor</summary> public AssociationsFacetsExample() { config = new FacetsConfig(); config.SetMultiValued(\"tags\", true); config.SetIndexFieldName(\"tags\", \"$tags\"); config.SetMultiValued(\"genre\", true); config.SetIndexFieldName(\"genre\", \"$genre\"); } /// <summary>Build the example index.</summary> private void Index() { IndexWriterConfig iwc = new IndexWriterConfig(EXAMPLE_VERSION, new WhitespaceAnalyzer(EXAMPLE_VERSION)); using IndexWriter indexWriter = new IndexWriter(indexDir, iwc); // Writes facet ords to a separate directory from the main index using DirectoryTaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir); Document doc = new Document(); // 3 occurrences for tag 'lucene' doc.AddInt32AssociationFacetField(3, \"tags\", \"lucene\"); // 87% confidence level of genre 'computing' doc.AddSingleAssociationFacetField(0.87f, \"genre\", \"computing\"); indexWriter.AddDocument(config.Build(taxoWriter, doc)); doc = new Document(); // 1 occurrence for tag 'lucene' doc.AddInt32AssociationFacetField(1, \"tags\", \"lucene\"); // 2 occurrence for tag 'solr' doc.AddInt32AssociationFacetField(2, \"tags\", \"solr\"); // 75% confidence level of genre 'computing' doc.AddSingleAssociationFacetField(0.75f, \"genre\", \"computing\"); // 34% confidence level of genre 'software' doc.AddSingleAssociationFacetField(0.34f, \"genre\", \"software\"); indexWriter.AddDocument(config.Build(taxoWriter, doc)); } /// <summary>User runs a query and aggregates facets by summing their association values.</summary> private IList<FacetResult> SumAssociations() { using DirectoryReader indexReader = DirectoryReader.Open(indexDir); using TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir); IndexSearcher searcher = new IndexSearcher(indexReader); FacetsCollector fc = new FacetsCollector(); // MatchAllDocsQuery is for \"browsing\" (counts facets // for all non-deleted docs in the index); normally // you'd use a \"normal\" query: FacetsCollector.Search(searcher, new MatchAllDocsQuery(), 10, fc); Facets tags = new TaxonomyFacetSumInt32Associations(\"$tags\", taxoReader, config, fc); Facets genre = new TaxonomyFacetSumSingleAssociations(\"$genre\", taxoReader, config, fc); // Retrieve results IList<FacetResult> results = new List<FacetResult> { tags.GetTopChildren(10, \"tags\"), genre.GetTopChildren(10, \"genre\") }; return results; } /// <summary>User drills down on 'tags/solr'.</summary> private FacetResult DrillDown() { using DirectoryReader indexReader = DirectoryReader.Open(indexDir); using TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir); IndexSearcher searcher = new IndexSearcher(indexReader); // Passing no baseQuery means we drill down on all // documents (\"browse only\"): DrillDownQuery q = new DrillDownQuery(config); // Now user drills down on Publish Date/2010: q.Add(\"tags\", \"solr\"); FacetsCollector fc = new FacetsCollector(); FacetsCollector.Search(searcher, q, 10, fc); // Retrieve results Facets facets = new TaxonomyFacetSumSingleAssociations(\"$genre\", taxoReader, config, fc); FacetResult result = facets.GetTopChildren(10, \"genre\"); return result; } /// <summary>Runs summing association example.</summary> public IList<FacetResult> RunSumAssociations() { Index(); return SumAssociations(); } /// <summary>Runs the drill-down example.</summary> public FacetResult RunDrillDown() { Index(); return DrillDown(); } /// <summary>Runs the sum int/float associations examples and prints the results.</summary> [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Style\", \"IDE0060:Remove unused parameter\", Justification = \"Demo shows use of optional args argument\")] public static void Main(string[] args) { Console.WriteLine(\"Sum associations example:\"); Console.WriteLine(\"-------------------------\"); IList<FacetResult> results = new AssociationsFacetsExample().RunSumAssociations(); Console.WriteLine(\"tags: \" + results[0]); Console.WriteLine(\"genre: \" + results[1]); } } } Constructors | Improve this Doc View Source AssociationsFacetsExample() Empty constructor Declaration public AssociationsFacetsExample() Methods | Improve this Doc View Source Main(String[]) Runs the sum int/float associations examples and prints the results. Declaration public static void Main(string[] args) Parameters Type Name Description System.String [] args | Improve this Doc View Source RunDrillDown() Runs the drill-down example. Declaration public FacetResult RunDrillDown() Returns Type Description Lucene.Net.Facet.FacetResult | Improve this Doc View Source RunSumAssociations() Runs summing association example. Declaration public IList<FacetResult> RunSumAssociations() Returns Type Description System.Collections.Generic.IList < Lucene.Net.Facet.FacetResult >"
  },
  "Lucene.Net.Demo.Facet.DistanceFacetsExample.html": {
    "href": "Lucene.Net.Demo.Facet.DistanceFacetsExample.html",
    "title": "Class DistanceFacetsExample | Apache Lucene.NET 4.8.0-beta00015 Documentation",
    "keywords": "Class DistanceFacetsExample Shows simple usage of dynamic range faceting, using the expressions module to calculate distance. Inheritance System.Object DistanceFacetsExample Implements System.IDisposable Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Lucene.Net.Demo.Facet Assembly : Lucene.Net.Demo.dll Syntax public sealed class DistanceFacetsExample : IDisposable Examples using J2N; using Lucene.Net.Analysis.Core; using Lucene.Net.Documents; using Lucene.Net.Expressions; using Lucene.Net.Expressions.JS; using Lucene.Net.Facet; using Lucene.Net.Facet.Range; using Lucene.Net.Facet.Taxonomy; using Lucene.Net.Index; using Lucene.Net.Queries; using Lucene.Net.Queries.Function; using Lucene.Net.Search; using Lucene.Net.Store; using Lucene.Net.Util; using System; using System.Diagnostics; using System.Globalization; namespace Lucene.Net.Demo.Facet { /// <summary> /// Shows simple usage of dynamic range faceting, using the /// expressions module to calculate distance. /// </summary> public sealed class DistanceFacetsExample : IDisposable { /// <summary> /// Using a constant for all functionality related to a specific index /// is the best strategy. This allows you to upgrade Lucene.Net first /// and plan the upgrade of the index binary format for a later time. /// Once the index is upgraded, you simply need to update the constant /// version and redeploy your application. /// </summary> private const LuceneVersion EXAMPLE_VERSION = LuceneVersion.LUCENE_48; internal static readonly DoubleRange ONE_KM = new DoubleRange(\"< 1 km\", 0.0, true, 1.0, false); internal static readonly DoubleRange TWO_KM = new DoubleRange(\"< 2 km\", 0.0, true, 2.0, false); internal static readonly DoubleRange FIVE_KM = new DoubleRange(\"< 5 km\", 0.0, true, 5.0, false); internal static readonly DoubleRange TEN_KM = new DoubleRange(\"< 10 km\", 0.0, true, 10.0, false); private readonly Directory indexDir = new RAMDirectory(); private IndexSearcher searcher; private readonly FacetsConfig config = new FacetsConfig(); /// <summary>The \"home\" latitude.</summary> public readonly static double ORIGIN_LATITUDE = 40.7143528; /// <summary>The \"home\" longitude.</summary> public readonly static double ORIGIN_LONGITUDE = -74.0059731; /// <summary> /// Radius of the Earth in KM /// <para/> /// NOTE: this is approximate, because the earth is a bit /// wider at the equator than the poles. See /// http://en.wikipedia.org/wiki/Earth_radius /// </summary> public readonly static double EARTH_RADIUS_KM = 6371.01; /// <summary>Build the example index.</summary> public void Index() { using IndexWriter writer = new IndexWriter(indexDir, new IndexWriterConfig(EXAMPLE_VERSION, new WhitespaceAnalyzer(EXAMPLE_VERSION))); // TODO: we could index in radians instead ... saves all the conversions in GetBoundingBoxFilter // Add documents with latitude/longitude location: writer.AddDocument(new Document { new DoubleField(\"latitude\", 40.759011, Field.Store.NO), new DoubleField(\"longitude\", -73.9844722, Field.Store.NO) }); writer.AddDocument(new Document { new DoubleField(\"latitude\", 40.718266, Field.Store.NO), new DoubleField(\"longitude\", -74.007819, Field.Store.NO) }); writer.AddDocument(new Document { new DoubleField(\"latitude\", 40.7051157, Field.Store.NO), new DoubleField(\"longitude\", -74.0088305, Field.Store.NO) }); // Open near-real-time searcher searcher = new IndexSearcher(DirectoryReader.Open(writer, true)); } private static ValueSource GetDistanceValueSource() { Expression distance = JavascriptCompiler.Compile( string.Format(CultureInfo.InvariantCulture, \"haversin({0:R},{1:R},latitude,longitude)\", ORIGIN_LATITUDE, ORIGIN_LONGITUDE)); SimpleBindings bindings = new SimpleBindings(); bindings.Add(new SortField(\"latitude\", SortFieldType.DOUBLE)); bindings.Add(new SortField(\"longitude\", SortFieldType.DOUBLE)); return distance.GetValueSource(bindings); } /// <summary> /// Given a latitude and longitude (in degrees) and the /// maximum great circle (surface of the earth) distance, /// returns a simple Filter bounding box to \"fast match\" /// candidates. /// </summary> public static Filter GetBoundingBoxFilter(double originLat, double originLng, double maxDistanceKM) { // Basic bounding box geo math from // http://JanMatuschek.de/LatitudeLongitudeBoundingCoordinates, // licensed under creative commons 3.0: // http://creativecommons.org/licenses/by/3.0 // TODO: maybe switch to recursive prefix tree instead // (in lucene/spatial)? It should be more efficient // since it's a 2D trie... // Degrees -> Radians: double originLatRadians = originLat.ToRadians(); double originLngRadians = originLng.ToRadians(); double angle = maxDistanceKM / (SloppyMath.EarthDiameter(originLat) / 2.0); double minLat = originLatRadians - angle; double maxLat = originLatRadians + angle; double minLng; double maxLng; if (minLat > -90.ToRadians() && maxLat < 90.ToRadians()) { double delta = Math.Asin(Math.Sin(angle) / Math.Cos(originLatRadians)); minLng = originLngRadians - delta; if (minLng < -180.ToRadians()) { minLng += 2 * Math.PI; } maxLng = originLngRadians + delta; if (maxLng > 180.ToRadians()) { maxLng -= 2 * Math.PI; } } else { // The query includes a pole! minLat = Math.Max(minLat, -90.ToRadians()); maxLat = Math.Min(maxLat, 90.ToRadians()); minLng = -180.ToRadians(); maxLng = 180.ToRadians(); } BooleanFilter f = new BooleanFilter { // Add latitude range filter: { NumericRangeFilter.NewDoubleRange(\"latitude\", minLat.ToDegrees(), maxLat.ToDegrees(), true, true), Occur.MUST } }; // Add longitude range filter: if (minLng > maxLng) { // The bounding box crosses the international date // line: BooleanFilter lonF = new BooleanFilter { { NumericRangeFilter.NewDoubleRange(\"longitude\", minLng.ToDegrees(), null, true, true), Occur.SHOULD }, { NumericRangeFilter.NewDoubleRange(\"longitude\", null, maxLng.ToDegrees(), true, true), Occur.SHOULD } }; f.Add(lonF, Occur.MUST); } else { f.Add(NumericRangeFilter.NewDoubleRange(\"longitude\", minLng.ToDegrees(), maxLng.ToDegrees(), true, true), Occur.MUST); } return f; } /// <summary>User runs a query and counts facets.</summary> public FacetResult Search() { FacetsCollector fc = new FacetsCollector(); searcher.Search(new MatchAllDocsQuery(), fc); Facets facets = new DoubleRangeFacetCounts(\"field\", GetDistanceValueSource(), fc, GetBoundingBoxFilter(ORIGIN_LATITUDE, ORIGIN_LONGITUDE, 10.0), ONE_KM, TWO_KM, FIVE_KM, TEN_KM); return facets.GetTopChildren(10, \"field\"); } /// <summary>User drills down on the specified range.</summary> public TopDocs DrillDown(DoubleRange range) { // Passing no baseQuery means we drill down on all // documents (\"browse only\"): DrillDownQuery q = new DrillDownQuery(null); ValueSource vs = GetDistanceValueSource(); q.Add(\"field\", range.GetFilter(GetBoundingBoxFilter(ORIGIN_LATITUDE, ORIGIN_LONGITUDE, range.Max), vs)); DrillSideways ds = new SearchDrillSideways(searcher, config, vs); return ds.Search(q, 10).Hits; } private class SearchDrillSideways : DrillSideways { private readonly ValueSource vs; public SearchDrillSideways(IndexSearcher indexSearcher, FacetsConfig facetsConfig, ValueSource valueSource) : base(indexSearcher, facetsConfig, (TaxonomyReader)null) { this.vs = valueSource; } protected override Facets BuildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, string[] drillSidewaysDims) { Debug.Assert(drillSideways.Length == 1); return new DoubleRangeFacetCounts(\"field\", vs, drillSideways[0], ONE_KM, TWO_KM, FIVE_KM, TEN_KM); } } public void Dispose() { searcher?.IndexReader?.Dispose(); indexDir?.Dispose(); } /// <summary>Runs the search and drill-down examples and prints the results.</summary> public static void Main(string[] args) { using DistanceFacetsExample example = new DistanceFacetsExample(); example.Index(); Console.WriteLine(\"Distance facet counting example:\"); Console.WriteLine(\"-----------------------\"); Console.WriteLine(example.Search()); Console.WriteLine(\"\\n\"); Console.WriteLine(\"Distance facet drill-down example (field/< 2 km):\"); Console.WriteLine(\"---------------------------------------------\"); TopDocs hits = example.DrillDown(TWO_KM); Console.WriteLine(hits.TotalHits + \" totalHits\"); } } } Fields | Improve this Doc View Source EARTH_RADIUS_KM Radius of the Earth in KM NOTE: this is approximate, because the earth is a bit wider at the equator than the poles. See http://en.wikipedia.org/wiki/Earth_radius Declaration public static readonly double EARTH_RADIUS_KM Field Value Type Description System.Double | Improve this Doc View Source ORIGIN_LATITUDE The \"home\" latitude. Declaration public static readonly double ORIGIN_LATITUDE Field Value Type Description System.Double | Improve this Doc View Source ORIGIN_LONGITUDE The \"home\" longitude. Declaration public static readonly double ORIGIN_LONGITUDE Field Value Type Description System.Double Methods | Improve this Doc View Source Dispose() Declaration public void Dispose() | Improve this Doc View Source DrillDown(DoubleRange) User drills down on the specified range. Declaration public TopDocs DrillDown(DoubleRange range) Parameters Type Name Description Lucene.Net.Facet.Range.DoubleRange range Returns Type Description Lucene.Net.Search.TopDocs | Improve this Doc View Source GetBoundingBoxFilter(Double, Double, Double) Given a latitude and longitude (in degrees) and the maximum great circle (surface of the earth) distance, returns a simple Filter bounding box to \"fast match\" candidates. Declaration public static Filter GetBoundingBoxFilter(double originLat, double originLng, double maxDistanceKM) Parameters Type Name Description System.Double originLat System.Double originLng System.Double maxDistanceKM Returns Type Description Lucene.Net.Search.Filter | Improve this Doc View Source Index() Build the example index. Declaration public void Index() | Improve this Doc View Source Main(String[]) Runs the search and drill-down examples and prints the results. Declaration public static void Main(string[] args) Parameters Type Name Description System.String [] args | Improve this Doc View Source Search() User runs a query and counts facets. Declaration public FacetResult Search() Returns Type Description Lucene.Net.Facet.FacetResult Implements System.IDisposable"
  },
  "Lucene.Net.Demo.Facet.ExpressionAggregationFacetsExample.html": {
    "href": "Lucene.Net.Demo.Facet.ExpressionAggregationFacetsExample.html",
    "title": "Class ExpressionAggregationFacetsExample | Apache Lucene.NET 4.8.0-beta00015 Documentation",
    "keywords": "Class ExpressionAggregationFacetsExample Shows facets aggregation by an expression. Inheritance System.Object ExpressionAggregationFacetsExample Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Lucene.Net.Demo.Facet Assembly : Lucene.Net.Demo.dll Syntax public class ExpressionAggregationFacetsExample Examples using Lucene.Net.Analysis.Core; using Lucene.Net.Documents; using Lucene.Net.Expressions; using Lucene.Net.Expressions.JS; using Lucene.Net.Facet; using Lucene.Net.Facet.Taxonomy; using Lucene.Net.Facet.Taxonomy.Directory; using Lucene.Net.Index; using Lucene.Net.Search; using Lucene.Net.Store; using Lucene.Net.Util; using System; namespace Lucene.Net.Demo.Facet { /// <summary> /// Shows facets aggregation by an expression. /// </summary> public class ExpressionAggregationFacetsExample { /// <summary> /// Using a constant for all functionality related to a specific index /// is the best strategy. This allows you to upgrade Lucene.Net first /// and plan the upgrade of the index binary format for a later time. /// Once the index is upgraded, you simply need to update the constant /// version and redeploy your application. /// </summary> private const LuceneVersion EXAMPLE_VERSION = LuceneVersion.LUCENE_48; private readonly Directory indexDir = new RAMDirectory(); private readonly Directory taxoDir = new RAMDirectory(); private readonly FacetsConfig config = new FacetsConfig(); /// <summary>Build the example index.</summary> private void Index() { using IndexWriter indexWriter = new IndexWriter(indexDir, new IndexWriterConfig(EXAMPLE_VERSION, new WhitespaceAnalyzer(EXAMPLE_VERSION))); // Writes facet ords to a separate directory from the main index using DirectoryTaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir); indexWriter.AddDocument(config.Build(taxoWriter, new Document { new TextField(\"c\", \"foo bar\", Field.Store.NO), new NumericDocValuesField(\"popularity\", 5L), new FacetField(\"A\", \"B\") })); indexWriter.AddDocument(config.Build(taxoWriter, new Document { new TextField(\"c\", \"foo foo bar\", Field.Store.NO), new NumericDocValuesField(\"popularity\", 3L), new FacetField(\"A\", \"C\") })); } /// <summary>User runs a query and aggregates facets.</summary> private FacetResult Search() { using DirectoryReader indexReader = DirectoryReader.Open(indexDir); using TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir); IndexSearcher searcher = new IndexSearcher(indexReader); // Aggregate categories by an expression that combines the document's score // and its popularity field Expression expr = JavascriptCompiler.Compile(\"_score * sqrt(popularity)\"); SimpleBindings bindings = new SimpleBindings(); bindings.Add(new SortField(\"_score\", SortFieldType.SCORE)); // the score of the document bindings.Add(new SortField(\"popularity\", SortFieldType.INT64)); // the value of the 'popularity' field // Aggregates the facet values FacetsCollector fc = new FacetsCollector(true); // MatchAllDocsQuery is for \"browsing\" (counts facets // for all non-deleted docs in the index); normally // you'd use a \"normal\" query: FacetsCollector.Search(searcher, new MatchAllDocsQuery(), 10, fc); // Retrieve results Facets facets = new TaxonomyFacetSumValueSource(taxoReader, config, fc, expr.GetValueSource(bindings)); FacetResult result = facets.GetTopChildren(10, \"A\"); return result; } /// <summary>Runs the search example.</summary> public FacetResult RunSearch() { Index(); return Search(); } /// <summary>Runs the search and drill-down examples and prints the results.</summary> public static void Main(string[] args) { Console.WriteLine(\"Facet counting example:\"); Console.WriteLine(\"-----------------------\"); FacetResult result = new ExpressionAggregationFacetsExample().RunSearch(); Console.WriteLine(result); } } } Methods | Improve this Doc View Source Main(String[]) Runs the search and drill-down examples and prints the results. Declaration public static void Main(string[] args) Parameters Type Name Description System.String [] args | Improve this Doc View Source RunSearch() Runs the search example. Declaration public FacetResult RunSearch() Returns Type Description Lucene.Net.Facet.FacetResult"
  },
  "Lucene.Net.Demo.Facet.html": {
    "href": "Lucene.Net.Demo.Facet.html",
    "title": "Namespace Lucene.Net.Demo.Facet | Apache Lucene.NET 4.8.0-beta00015 Documentation",
    "keywords": "Namespace Lucene.Net.Demo.Facet <!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. --> Facets example code. Classes AssociationsFacetsExample Shows example usage of category associations. DistanceFacetsExample Shows simple usage of dynamic range faceting, using the expressions module to calculate distance. ExpressionAggregationFacetsExample Shows facets aggregation by an expression. MultiCategoryListsFacetsExample Demonstrates indexing categories into different indexed fields. RangeFacetsExample Shows simple usage of dynamic range faceting. SimpleFacetsExample Shows simple usage of faceted indexing and search. SimpleSortedSetFacetsExample Shows simple usage of faceted indexing and search using Lucene.Net.Facet.SortedSet.SortedSetDocValuesFacetField and Lucene.Net.Facet.SortedSet.SortedSetDocValuesFacetCounts ."
  },
  "Lucene.Net.Demo.Facet.MultiCategoryListsFacetsExample.html": {
    "href": "Lucene.Net.Demo.Facet.MultiCategoryListsFacetsExample.html",
    "title": "Class MultiCategoryListsFacetsExample | Apache Lucene.NET 4.8.0-beta00015 Documentation",
    "keywords": "Class MultiCategoryListsFacetsExample Demonstrates indexing categories into different indexed fields. Inheritance System.Object MultiCategoryListsFacetsExample Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Lucene.Net.Demo.Facet Assembly : Lucene.Net.Demo.dll Syntax public class MultiCategoryListsFacetsExample Examples using Lucene.Net.Analysis.Core; using Lucene.Net.Documents; using Lucene.Net.Facet; using Lucene.Net.Facet.Taxonomy; using Lucene.Net.Facet.Taxonomy.Directory; using Lucene.Net.Index; using Lucene.Net.Search; using Lucene.Net.Store; using Lucene.Net.Util; using System; using System.Collections.Generic; namespace Lucene.Net.Demo.Facet { /// <summary> /// Demonstrates indexing categories into different indexed fields. /// </summary> public class MultiCategoryListsFacetsExample { /// <summary> /// Using a constant for all functionality related to a specific index /// is the best strategy. This allows you to upgrade Lucene.Net first /// and plan the upgrade of the index binary format for a later time. /// Once the index is upgraded, you simply need to update the constant /// version and redeploy your application. /// </summary> private const LuceneVersion EXAMPLE_VERSION = LuceneVersion.LUCENE_48; private readonly Directory indexDir = new RAMDirectory(); private readonly Directory taxoDir = new RAMDirectory(); private readonly FacetsConfig config = new FacetsConfig(); /// <summary>Creates a new instance and populates the catetory list params mapping.</summary> public MultiCategoryListsFacetsExample() { config.SetIndexFieldName(\"Author\", \"author\"); config.SetIndexFieldName(\"Publish Date\", \"pubdate\"); config.SetHierarchical(\"Publish Date\", true); } /// <summary>Build the example index.</summary> private void Index() { using IndexWriter indexWriter = new IndexWriter(indexDir, new IndexWriterConfig(EXAMPLE_VERSION, new WhitespaceAnalyzer(EXAMPLE_VERSION))); // Writes facet ords to a separate directory from the main index using DirectoryTaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir); indexWriter.AddDocument(config.Build(taxoWriter, new Document { new FacetField(\"Author\", \"Bob\"), new FacetField(\"Publish Date\", \"2010\", \"10\", \"15\") })); indexWriter.AddDocument(config.Build(taxoWriter, new Document { new FacetField(\"Author\", \"Lisa\"), new FacetField(\"Publish Date\", \"2010\", \"10\", \"20\") })); indexWriter.AddDocument(config.Build(taxoWriter, new Document { new FacetField(\"Author\", \"Lisa\"), new FacetField(\"Publish Date\", \"2012\", \"1\", \"1\") })); indexWriter.AddDocument(config.Build(taxoWriter, new Document { new FacetField(\"Author\", \"Susan\"), new FacetField(\"Publish Date\", \"2012\", \"1\", \"7\") })); indexWriter.AddDocument(config.Build(taxoWriter, new Document { new FacetField(\"Author\", \"Frank\"), new FacetField(\"Publish Date\", \"1999\", \"5\", \"5\") })); } /// <summary>User runs a query and counts facets.</summary> private IList<FacetResult> Search() { IList<FacetResult> results = new List<FacetResult>(); using DirectoryReader indexReader = DirectoryReader.Open(indexDir); using TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir); IndexSearcher searcher = new IndexSearcher(indexReader); FacetsCollector fc = new FacetsCollector(); // MatchAllDocsQuery is for \"browsing\" (counts facets // for all non-deleted docs in the index); normally // you'd use a \"normal\" query: FacetsCollector.Search(searcher, new MatchAllDocsQuery(), 10, fc); // Retrieve results // Count both \"Publish Date\" and \"Author\" dimensions Facets author = new FastTaxonomyFacetCounts(\"author\", taxoReader, config, fc); results.Add(author.GetTopChildren(10, \"Author\")); Facets pubDate = new FastTaxonomyFacetCounts(\"pubdate\", taxoReader, config, fc); results.Add(pubDate.GetTopChildren(10, \"Publish Date\")); return results; } /// <summary>Runs the search example.</summary> public IList<FacetResult> RunSearch() { Index(); return Search(); } /// <summary>Runs the search example and prints the results.</summary> public static void Main(string[] args) { Console.WriteLine(\"Facet counting over multiple category lists example:\"); Console.WriteLine(\"-----------------------\"); IList<FacetResult> results = new MultiCategoryListsFacetsExample().RunSearch(); Console.WriteLine(\"Author: \" + results[0]); Console.WriteLine(\"Publish Date: \" + results[1]); } } } Constructors | Improve this Doc View Source MultiCategoryListsFacetsExample() Creates a new instance and populates the catetory list params mapping. Declaration public MultiCategoryListsFacetsExample() Methods | Improve this Doc View Source Main(String[]) Runs the search example and prints the results. Declaration public static void Main(string[] args) Parameters Type Name Description System.String [] args | Improve this Doc View Source RunSearch() Runs the search example. Declaration public IList<FacetResult> RunSearch() Returns Type Description System.Collections.Generic.IList < Lucene.Net.Facet.FacetResult >"
  },
  "Lucene.Net.Demo.Facet.RangeFacetsExample.html": {
    "href": "Lucene.Net.Demo.Facet.RangeFacetsExample.html",
    "title": "Class RangeFacetsExample | Apache Lucene.NET 4.8.0-beta00015 Documentation",
    "keywords": "Class RangeFacetsExample Shows simple usage of dynamic range faceting. Inheritance System.Object RangeFacetsExample Implements System.IDisposable Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Lucene.Net.Demo.Facet Assembly : Lucene.Net.Demo.dll Syntax public sealed class RangeFacetsExample : IDisposable Examples using Lucene.Net.Analysis.Core; using Lucene.Net.Documents; using Lucene.Net.Facet; using Lucene.Net.Facet.Range; using Lucene.Net.Index; using Lucene.Net.Search; using Lucene.Net.Store; using Lucene.Net.Util; using System; namespace Lucene.Net.Demo.Facet { /// <summary> /// Shows simple usage of dynamic range faceting. /// </summary> public sealed class RangeFacetsExample : IDisposable { /// <summary> /// Using a constant for all functionality related to a specific index /// is the best strategy. This allows you to upgrade Lucene.Net first /// and plan the upgrade of the index binary format for a later time. /// Once the index is upgraded, you simply need to update the constant /// version and redeploy your application. /// </summary> private const LuceneVersion EXAMPLE_VERSION = LuceneVersion.LUCENE_48; private readonly Directory indexDir = new RAMDirectory(); private IndexSearcher searcher; private readonly long nowSec = DateTime.Now.Ticks; internal readonly Int64Range PAST_HOUR; internal readonly Int64Range PAST_SIX_HOURS; internal readonly Int64Range PAST_DAY; /// <summary>Constructor</summary> public RangeFacetsExample() { PAST_HOUR = new Int64Range(\"Past hour\", nowSec - 3600, true, nowSec, true); PAST_SIX_HOURS = new Int64Range(\"Past six hours\", nowSec - 6 * 3600, true, nowSec, true); PAST_DAY = new Int64Range(\"Past day\", nowSec - 24 * 3600, true, nowSec, true); } /// <summary>Build the example index.</summary> public void Index() { using IndexWriter indexWriter = new IndexWriter(indexDir, new IndexWriterConfig(EXAMPLE_VERSION, new WhitespaceAnalyzer(EXAMPLE_VERSION))); // Add documents with a fake timestamp, 1000 sec before // \"now\", 2000 sec before \"now\", ...: for (int i = 0; i < 100; i++) { Document doc = new Document(); long then = nowSec - i * 1000; // Add as doc values field, so we can compute range facets: doc.Add(new NumericDocValuesField(\"timestamp\", then)); // Add as numeric field so we can drill-down: doc.Add(new Int64Field(\"timestamp\", then, Field.Store.NO)); indexWriter.AddDocument(doc); } // Open near-real-time searcher searcher = new IndexSearcher(DirectoryReader.Open(indexWriter, true)); } private static FacetsConfig GetConfig() { return new FacetsConfig(); } /// <summary>User runs a query and counts facets.</summary> public FacetResult Search() { // Aggregates the facet counts FacetsCollector fc = new FacetsCollector(); // MatchAllDocsQuery is for \"browsing\" (counts facets // for all non-deleted docs in the index); normally // you'd use a \"normal\" query: FacetsCollector.Search(searcher, new MatchAllDocsQuery(), 10, fc); Facets facets = new Int64RangeFacetCounts(\"timestamp\", fc, PAST_HOUR, PAST_SIX_HOURS, PAST_DAY); return facets.GetTopChildren(10, \"timestamp\"); } /// <summary>User drills down on the specified range.</summary> public TopDocs DrillDown(Int64Range range) { // Passing no baseQuery means we drill down on all // documents (\"browse only\"): DrillDownQuery q = new DrillDownQuery(GetConfig()); q.Add(\"timestamp\", NumericRangeQuery.NewInt64Range(\"timestamp\", range.Min, range.Max, range.MinInclusive, range.MaxInclusive)); return searcher.Search(q, 10); } public void Dispose() { searcher?.IndexReader?.Dispose(); indexDir?.Dispose(); } /// <summary>Runs the search and drill-down examples and prints the results.</summary> public static void Main(string[] args) { using RangeFacetsExample example = new RangeFacetsExample(); example.Index(); Console.WriteLine(\"Facet counting example:\"); Console.WriteLine(\"-----------------------\"); Console.WriteLine(example.Search()); Console.WriteLine(\"\\n\"); Console.WriteLine(\"Facet drill-down example (timestamp/Past six hours):\"); Console.WriteLine(\"---------------------------------------------\"); TopDocs hits = example.DrillDown(example.PAST_SIX_HOURS); Console.WriteLine(hits.TotalHits + \" TotalHits\"); } } } Constructors | Improve this Doc View Source RangeFacetsExample() Constructor Declaration public RangeFacetsExample() Methods | Improve this Doc View Source Dispose() Declaration public void Dispose() | Improve this Doc View Source DrillDown(Int64Range) User drills down on the specified range. Declaration public TopDocs DrillDown(Int64Range range) Parameters Type Name Description Lucene.Net.Facet.Range.Int64Range range Returns Type Description Lucene.Net.Search.TopDocs | Improve this Doc View Source Index() Build the example index. Declaration public void Index() | Improve this Doc View Source Main(String[]) Runs the search and drill-down examples and prints the results. Declaration public static void Main(string[] args) Parameters Type Name Description System.String [] args | Improve this Doc View Source Search() User runs a query and counts facets. Declaration public FacetResult Search() Returns Type Description Lucene.Net.Facet.FacetResult Implements System.IDisposable"
  },
  "Lucene.Net.Demo.Facet.SimpleFacetsExample.html": {
    "href": "Lucene.Net.Demo.Facet.SimpleFacetsExample.html",
    "title": "Class SimpleFacetsExample | Apache Lucene.NET 4.8.0-beta00015 Documentation",
    "keywords": "Class SimpleFacetsExample Shows simple usage of faceted indexing and search. Inheritance System.Object SimpleFacetsExample Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Lucene.Net.Demo.Facet Assembly : Lucene.Net.Demo.dll Syntax public class SimpleFacetsExample Examples using Lucene.Net.Analysis.Core; using Lucene.Net.Documents; using Lucene.Net.Facet; using Lucene.Net.Facet.Taxonomy; using Lucene.Net.Facet.Taxonomy.Directory; using Lucene.Net.Index; using Lucene.Net.Search; using Lucene.Net.Store; using Lucene.Net.Util; using System; using System.Collections.Generic; namespace Lucene.Net.Demo.Facet { /// <summary> /// Shows simple usage of faceted indexing and search. /// </summary> public class SimpleFacetsExample { /// <summary> /// Using a constant for all functionality related to a specific index /// is the best strategy. This allows you to upgrade Lucene.Net first /// and plan the upgrade of the index binary format for a later time. /// Once the index is upgraded, you simply need to update the constant /// version and redeploy your application. /// </summary> private const LuceneVersion EXAMPLE_VERSION = LuceneVersion.LUCENE_48; private readonly Directory indexDir = new RAMDirectory(); private readonly Directory taxoDir = new RAMDirectory(); private readonly FacetsConfig config = new FacetsConfig(); /// <summary>Constructor</summary> public SimpleFacetsExample() { config.SetHierarchical(\"Publish Date\", true); } /// <summary>Build the example index.</summary> private void Index() { using IndexWriter indexWriter = new IndexWriter(indexDir, new IndexWriterConfig(EXAMPLE_VERSION, new WhitespaceAnalyzer(EXAMPLE_VERSION))); // Writes facet ords to a separate directory from the main index using DirectoryTaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir); indexWriter.AddDocument(config.Build(taxoWriter, new Document { new FacetField(\"Author\", \"Bob\"), new FacetField(\"Publish Date\", \"2010\", \"10\", \"15\") })); indexWriter.AddDocument(config.Build(taxoWriter, new Document { new FacetField(\"Author\", \"Lisa\"), new FacetField(\"Publish Date\", \"2010\", \"10\", \"20\") })); indexWriter.AddDocument(config.Build(taxoWriter, new Document { new FacetField(\"Author\", \"Lisa\"), new FacetField(\"Publish Date\", \"2012\", \"1\", \"1\") })); indexWriter.AddDocument(config.Build(taxoWriter, new Document { new FacetField(\"Author\", \"Susan\"), new FacetField(\"Publish Date\", \"2012\", \"1\", \"7\") })); indexWriter.AddDocument(config.Build(taxoWriter, new Document { new FacetField(\"Author\", \"Frank\"), new FacetField(\"Publish Date\", \"1999\", \"5\", \"5\") })); } /// <summary>User runs a query and counts facets.</summary> private IList<FacetResult> FacetsWithSearch() { using DirectoryReader indexReader = DirectoryReader.Open(indexDir); using TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir); IndexSearcher searcher = new IndexSearcher(indexReader); FacetsCollector fc = new FacetsCollector(); // MatchAllDocsQuery is for \"browsing\" (counts facets // for all non-deleted docs in the index); normally // you'd use a \"normal\" query: FacetsCollector.Search(searcher, new MatchAllDocsQuery(), 10, fc); Facets facets = new FastTaxonomyFacetCounts(taxoReader, config, fc); // Retrieve results IList<FacetResult> results = new List<FacetResult> { // Count both \"Publish Date\" and \"Author\" dimensions facets.GetTopChildren(10, \"Author\"), facets.GetTopChildren(10, \"Publish Date\") }; return results; } /// <summary>User runs a query and counts facets only without collecting the matching documents.</summary> private IList<FacetResult> FacetsOnly() { using DirectoryReader indexReader = DirectoryReader.Open(indexDir); using TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir); IndexSearcher searcher = new IndexSearcher(indexReader); FacetsCollector fc = new FacetsCollector(); // MatchAllDocsQuery is for \"browsing\" (counts facets // for all non-deleted docs in the index); normally // you'd use a \"normal\" query: searcher.Search(new MatchAllDocsQuery(), null /*Filter */, fc); Facets facets = new FastTaxonomyFacetCounts(taxoReader, config, fc); // Retrieve results IList<FacetResult> results = new List<FacetResult> { // Count both \"Publish Date\" and \"Author\" dimensions facets.GetTopChildren(10, \"Author\"), facets.GetTopChildren(10, \"Publish Date\") }; return results; } /// <summary> /// User drills down on 'Publish Date/2010', and we /// return facets for 'Author' /// </summary> private FacetResult DrillDown() { using DirectoryReader indexReader = DirectoryReader.Open(indexDir); using TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir); IndexSearcher searcher = new IndexSearcher(indexReader); // Passing no baseQuery means we drill down on all // documents (\"browse only\"): DrillDownQuery q = new DrillDownQuery(config); // Now user drills down on Publish Date/2010: q.Add(\"Publish Date\", \"2010\"); FacetsCollector fc = new FacetsCollector(); FacetsCollector.Search(searcher, q, 10, fc); // Retrieve results Facets facets = new FastTaxonomyFacetCounts(taxoReader, config, fc); FacetResult result = facets.GetTopChildren(10, \"Author\"); return result; } /// <summary> /// User drills down on 'Publish Date/2010', and we /// return facets for both 'Publish Date' and 'Author', /// using DrillSideways. /// </summary> private IList<FacetResult> DrillSideways() { using DirectoryReader indexReader = DirectoryReader.Open(indexDir); using TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir); IndexSearcher searcher = new IndexSearcher(indexReader); // Passing no baseQuery means we drill down on all // documents (\"browse only\"): DrillDownQuery q = new DrillDownQuery(config); // Now user drills down on Publish Date/2010: q.Add(\"Publish Date\", \"2010\"); DrillSideways ds = new DrillSideways(searcher, config, taxoReader); DrillSidewaysResult result = ds.Search(q, 10); // Retrieve results IList<FacetResult> facets = result.Facets.GetAllDims(10); return facets; } /// <summary>Runs the search example.</summary> public IList<FacetResult> RunFacetOnly() { Index(); return FacetsOnly(); } /// <summary>Runs the search example.</summary> public IList<FacetResult> RunSearch() { Index(); return FacetsWithSearch(); } /// <summary>Runs the drill-down example.</summary> public FacetResult RunDrillDown() { Index(); return DrillDown(); } /// <summary>Runs the drill-sideways example.</summary> public IList<FacetResult> RunDrillSideways() { Index(); return DrillSideways(); } /// <summary>Runs the search and drill-down examples and prints the results.</summary> public static void Main(string[] args) { Console.WriteLine(\"Facet counting example:\"); Console.WriteLine(\"-----------------------\"); SimpleFacetsExample example1 = new SimpleFacetsExample(); IList<FacetResult> results1 = example1.RunFacetOnly(); Console.WriteLine(\"Author: \" + results1[0]); Console.WriteLine(\"Publish Date: \" + results1[1]); Console.WriteLine(\"Facet counting example (combined facets and search):\"); Console.WriteLine(\"-----------------------\"); SimpleFacetsExample example = new SimpleFacetsExample(); IList<FacetResult> results = example.RunSearch(); Console.WriteLine(\"Author: \" + results[0]); Console.WriteLine(\"Publish Date: \" + results[1]); Console.WriteLine(); Console.WriteLine(\"Facet drill-down example (Publish Date/2010):\"); Console.WriteLine(\"---------------------------------------------\"); Console.WriteLine(\"Author: \" + example.RunDrillDown()); Console.WriteLine(); Console.WriteLine(\"Facet drill-sideways example (Publish Date/2010):\"); Console.WriteLine(\"---------------------------------------------\"); foreach (FacetResult result in example.RunDrillSideways()) { Console.WriteLine(result); } } } } Constructors | Improve this Doc View Source SimpleFacetsExample() Constructor Declaration public SimpleFacetsExample() Methods | Improve this Doc View Source Main(String[]) Runs the search and drill-down examples and prints the results. Declaration public static void Main(string[] args) Parameters Type Name Description System.String [] args | Improve this Doc View Source RunDrillDown() Runs the drill-down example. Declaration public FacetResult RunDrillDown() Returns Type Description Lucene.Net.Facet.FacetResult | Improve this Doc View Source RunDrillSideways() Runs the drill-sideways example. Declaration public IList<FacetResult> RunDrillSideways() Returns Type Description System.Collections.Generic.IList < Lucene.Net.Facet.FacetResult > | Improve this Doc View Source RunFacetOnly() Runs the search example. Declaration public IList<FacetResult> RunFacetOnly() Returns Type Description System.Collections.Generic.IList < Lucene.Net.Facet.FacetResult > | Improve this Doc View Source RunSearch() Runs the search example. Declaration public IList<FacetResult> RunSearch() Returns Type Description System.Collections.Generic.IList < Lucene.Net.Facet.FacetResult >"
  },
  "Lucene.Net.Demo.Facet.SimpleSortedSetFacetsExample.html": {
    "href": "Lucene.Net.Demo.Facet.SimpleSortedSetFacetsExample.html",
    "title": "Class SimpleSortedSetFacetsExample | Apache Lucene.NET 4.8.0-beta00015 Documentation",
    "keywords": "Class SimpleSortedSetFacetsExample Shows simple usage of faceted indexing and search using Lucene.Net.Facet.SortedSet.SortedSetDocValuesFacetField and Lucene.Net.Facet.SortedSet.SortedSetDocValuesFacetCounts . Inheritance System.Object SimpleSortedSetFacetsExample Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Lucene.Net.Demo.Facet Assembly : Lucene.Net.Demo.dll Syntax public class SimpleSortedSetFacetsExample Examples using Lucene.Net.Analysis.Core; using Lucene.Net.Documents; using Lucene.Net.Facet; using Lucene.Net.Facet.SortedSet; using Lucene.Net.Index; using Lucene.Net.Search; using Lucene.Net.Store; using Lucene.Net.Util; using System; using System.Collections.Generic; namespace Lucene.Net.Demo.Facet { /// <summary> /// Shows simple usage of faceted indexing and search /// using <see cref=\"SortedSetDocValuesFacetField\"/> and /// <see cref=\"SortedSetDocValuesFacetCounts\"/>. /// </summary> public class SimpleSortedSetFacetsExample { /// <summary> /// Using a constant for all functionality related to a specific index /// is the best strategy. This allows you to upgrade Lucene.Net first /// and plan the upgrade of the index binary format for a later time. /// Once the index is upgraded, you simply need to update the constant /// version and redeploy your application. /// </summary> private const LuceneVersion EXAMPLE_VERSION = LuceneVersion.LUCENE_48; private readonly Directory indexDir = new RAMDirectory(); private readonly FacetsConfig config = new FacetsConfig(); /// <summary>Build the example index.</summary> private void Index() { using IndexWriter indexWriter = new IndexWriter(indexDir, new IndexWriterConfig(EXAMPLE_VERSION, new WhitespaceAnalyzer(EXAMPLE_VERSION))); indexWriter.AddDocument(config.Build(new Document { new SortedSetDocValuesFacetField(\"Author\", \"Bob\"), new SortedSetDocValuesFacetField(\"Publish Year\", \"2010\") })); indexWriter.AddDocument(config.Build(new Document { new SortedSetDocValuesFacetField(\"Author\", \"Lisa\"), new SortedSetDocValuesFacetField(\"Publish Year\", \"2010\") })); indexWriter.AddDocument(config.Build(new Document { new SortedSetDocValuesFacetField(\"Author\", \"Lisa\"), new SortedSetDocValuesFacetField(\"Publish Year\", \"2012\") })); indexWriter.AddDocument(config.Build(new Document { new SortedSetDocValuesFacetField(\"Author\", \"Susan\"), new SortedSetDocValuesFacetField(\"Publish Year\", \"2012\") })); indexWriter.AddDocument(config.Build(new Document { new SortedSetDocValuesFacetField(\"Author\", \"Frank\"), new SortedSetDocValuesFacetField(\"Publish Year\", \"1999\") })); } /// <summary>User runs a query and counts facets.</summary> private IList<FacetResult> Search() { using DirectoryReader indexReader = DirectoryReader.Open(indexDir); IndexSearcher searcher = new IndexSearcher(indexReader); SortedSetDocValuesReaderState state = new DefaultSortedSetDocValuesReaderState(indexReader); // Aggregatses the facet counts FacetsCollector fc = new FacetsCollector(); // MatchAllDocsQuery is for \"browsing\" (counts facets // for all non-deleted docs in the index); normally // you'd use a \"normal\" query: FacetsCollector.Search(searcher, new MatchAllDocsQuery(), 10, fc); // Retrieve results Facets facets = new SortedSetDocValuesFacetCounts(state, fc); IList<FacetResult> results = new List<FacetResult> { facets.GetTopChildren(10, \"Author\"), facets.GetTopChildren(10, \"Publish Year\") }; return results; } /// <summary>User drills down on 'Publish Year/2010'.</summary> private FacetResult DrillDown() { using DirectoryReader indexReader = DirectoryReader.Open(indexDir); IndexSearcher searcher = new IndexSearcher(indexReader); SortedSetDocValuesReaderState state = new DefaultSortedSetDocValuesReaderState(indexReader); // Now user drills down on Publish Year/2010: DrillDownQuery q = new DrillDownQuery(config); q.Add(\"Publish Year\", \"2010\"); FacetsCollector fc = new FacetsCollector(); FacetsCollector.Search(searcher, q, 10, fc); // Retrieve results Facets facets = new SortedSetDocValuesFacetCounts(state, fc); FacetResult result = facets.GetTopChildren(10, \"Author\"); return result; } /// <summary>Runs the search example.</summary> public IList<FacetResult> RunSearch() { Index(); return Search(); } /// <summary>Runs the drill-down example.</summary> public FacetResult RunDrillDown() { Index(); return DrillDown(); } /// <summary>Runs the search and drill-down examples and prints the results.</summary> public static void Main(string[] args) { Console.WriteLine(\"Facet counting example:\"); Console.WriteLine(\"-----------------------\"); SimpleSortedSetFacetsExample example = new SimpleSortedSetFacetsExample(); IList<FacetResult> results = example.RunSearch(); Console.WriteLine(\"Author: \" + results[0]); Console.WriteLine(\"Publish Year: \" + results[0]); Console.WriteLine(); Console.WriteLine(\"Facet drill-down example (Publish Year/2010):\"); Console.WriteLine(\"---------------------------------------------\"); Console.WriteLine(\"Author: \" + example.RunDrillDown()); } } } Methods | Improve this Doc View Source Main(String[]) Runs the search and drill-down examples and prints the results. Declaration public static void Main(string[] args) Parameters Type Name Description System.String [] args | Improve this Doc View Source RunDrillDown() Runs the drill-down example. Declaration public FacetResult RunDrillDown() Returns Type Description Lucene.Net.Facet.FacetResult | Improve this Doc View Source RunSearch() Runs the search example. Declaration public IList<FacetResult> RunSearch() Returns Type Description System.Collections.Generic.IList < Lucene.Net.Facet.FacetResult >"
  },
  "Lucene.Net.Demo.html": {
    "href": "Lucene.Net.Demo.html",
    "title": "Namespace Lucene.Net.Demo | Apache Lucene.NET 4.8.0-beta00015 Documentation",
    "keywords": "Namespace Lucene.Net.Demo <!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. --> The demo module offers simple example code to show the features of Lucene. Apache Lucene - Building and Installing the Basic Demo About this Document About the Demo Indexing Files About the code Location of the source IndexFiles Searching Files About this Document This document is intended as a \"getting started\" guide to using and running the Lucene demos. It walks you through some basic installation and configuration. About the Demo The Lucene command-line demo code consists of an application that demonstrates various functionalities of Lucene and how you can add Lucene to your applications. Indexing Files Once you've gotten this far you're probably itching to go. Let's build an index! Assuming you've set your CLASSPATH correctly, just type: java org.apache.lucene.demo.IndexFiles -docs {path-to-lucene}/src This will produce a subdirectory called index which will contain an index of all of the Lucene source code. To search the index type: java org.apache.lucene.demo.SearchFiles You'll be prompted for a query. Type in a gibberish or made up word (for example: \"supercalifragilisticexpialidocious\"). You'll see that there are no maching results in the lucene source code. Now try entering the word \"string\". That should return a whole bunch of documents. The results will page at every tenth result and ask you whether you want more results. About the code In this section we walk through the sources behind the command-line Lucene demo: where to find them, their parts and their function. This section is intended for Java developers wishing to understand how to use Lucene in their applications. Location of the source The files discussed here are linked into this documentation directly: * IndexFiles : code to create a Lucene index. * SearchFiles : code to search a Lucene index. IndexFiles As we discussed in the previous walk-through, the IndexFiles class creates a Lucene Index. Let's take a look at how it does this. The main() method parses the command-line parameters, then in preparation for instantiating IndexWriter , opens a Directory , and instantiates StandardAnalyzer and IndexWriterConfig . The value of the -index command-line parameter is the name of the filesystem directory where all index information should be stored. If IndexFiles is invoked with a relative path given in the -index command-line parameter, or if the -index command-line parameter is not given, causing the default relative index path \" index \" to be used, the index path will be created as a subdirectory of the current working directory (if it does not already exist). On some platforms, the index path may be created in a different directory (such as the user's home directory). The -docs command-line parameter value is the location of the directory containing files to be indexed. The -update command-line parameter tells IndexFiles not to delete the index if it already exists. When -update is not given, IndexFiles will first wipe the slate clean before indexing any documents. Lucene Directory s are used by the IndexWriter to store information in the index. In addition to the FSDirectory implementation we are using, there are several other Directory subclasses that can write to RAM, to databases, etc. Lucene Analyzer s are processing pipelines that break up text into indexed tokens, a.k.a. terms, and optionally perform other operations on these tokens, e.g. downcasing, synonym insertion, filtering out unwanted tokens, etc. The Analyzer we are using is StandardAnalyzer , which creates tokens using the Word Break rules from the Unicode Text Segmentation algorithm specified in Unicode Standard Annex #29 ; converts tokens to lowercase; and then filters out stopwords. Stopwords are common language words such as articles (a, an, the, etc.) and other tokens that may have less value for searching. It should be noted that there are different rules for every language, and you should use the proper analyzer for each. Lucene currently provides Analyzers for a number of different languages (see the javadocs under lucene/analysis/common/src/java/org/apache/lucene/analysis ). The IndexWriterConfig instance holds all configuration for IndexWriter . For example, we set the OpenMode to use here based on the value of the -update command-line parameter. Looking further down in the file, after IndexWriter is instantiated, you should see the indexDocs() code. This recursive function crawls the directories and creates Document objects. The Document is simply a data object to represent the text content from the file as well as its creation time and location. These instances are added to the IndexWriter . If the -update command-line parameter is given, the IndexWriterConfig OpenMode will be set to OpenMode.CREATE_OR_APPEND , and rather than adding documents to the index, the IndexWriter will update them in the index by attempting to find an already-indexed document with the same identifier (in our case, the file path serves as the identifier); deleting it from the index if it exists; and then adding the new document to the index. Searching Files The SearchFiles class is quite simple. It primarily collaborates with an IndexSearcher , StandardAnalyzer , (which is used in the IndexFiles class as well) and a QueryParser . The query parser is constructed with an analyzer used to interpret your query text in the same way the documents are interpreted: finding word boundaries, downcasing, and removing useless words like 'a', 'an' and 'the'. The <xref:Lucene.Net.Search.Query> object contains the results from the QueryParser which is passed to the searcher. Note that it's also possible to programmatically construct a rich <xref:Lucene.Net.Search.Query> object without using the query parser. The query parser just enables decoding the Lucene query syntax into the corresponding Query object. SearchFiles uses the IndexSearcher.search method that returns TopDocs with max n hits. The results are printed in pages, sorted by score (i.e. relevance). Classes IndexFiles Index all text files under a directory. This is a command-line application demonstrating simple Lucene indexing. Run it with no command-line arguments for usage information. SearchFiles Simple command-line based search demo."
  },
  "Lucene.Net.Demo.IndexFiles.html": {
    "href": "Lucene.Net.Demo.IndexFiles.html",
    "title": "Class IndexFiles | Apache Lucene.NET 4.8.0-beta00015 Documentation",
    "keywords": "Class IndexFiles Index all text files under a directory. This is a command-line application demonstrating simple Lucene indexing. Run it with no command-line arguments for usage information. Inheritance System.Object IndexFiles Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Lucene.Net.Demo Assembly : Lucene.Net.Demo.dll Syntax public static class IndexFiles Methods | Improve this Doc View Source Main(String[]) Index all text files under a directory. Declaration public static void Main(string[] args) Parameters Type Name Description System.String [] args"
  },
  "Lucene.Net.Demo.SearchFiles.html": {
    "href": "Lucene.Net.Demo.SearchFiles.html",
    "title": "Class SearchFiles | Apache Lucene.NET 4.8.0-beta00015 Documentation",
    "keywords": "Class SearchFiles Simple command-line based search demo. Inheritance System.Object SearchFiles Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Lucene.Net.Demo Assembly : Lucene.Net.Demo.dll Syntax public static class SearchFiles Methods | Improve this Doc View Source DoPagingSearch(IndexSearcher, Query, Int32, Boolean, Boolean) This demonstrates a typical paging search scenario, where the search engine presents pages of size n to the user. The user can then go to the next page if interested in the next hits. When the query is executed for the first time, then only enough results are collected to fill 5 result pages. If the user wants to page beyond this limit, then the query is executed another time and all hits are collected. Declaration public static void DoPagingSearch(IndexSearcher searcher, Query query, int hitsPerPage, bool raw, bool interactive) Parameters Type Name Description Lucene.Net.Search.IndexSearcher searcher Lucene.Net.Search.Query query System.Int32 hitsPerPage System.Boolean raw System.Boolean interactive | Improve this Doc View Source Main(String[]) Simple command-line based search demo. Declaration public static void Main(string[] args) Parameters Type Name Description System.String [] args"
  }
}