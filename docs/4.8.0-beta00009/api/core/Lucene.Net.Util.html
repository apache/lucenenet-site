<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Namespace Lucene.Net.Util
   | Apache Lucene.NET 4.8.0-beta00009 Documentation </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Namespace Lucene.Net.Util
   | Apache Lucene.NET 4.8.0-beta00009 Documentation ">
    <meta name="generator" content="docfx 2.56.0.0">
    
    <link rel="shortcut icon" href="https://lucenenet.apache.org/docs/4.8.0-beta00009/logo/favicon.ico">
    <link rel="stylesheet" href="https://lucenenet.apache.org/docs/4.8.0-beta00009/styles/docfx.vendor.css">
    <link rel="stylesheet" href="https://lucenenet.apache.org/docs/4.8.0-beta00009/styles/docfx.css">
    <link rel="stylesheet" href="https://lucenenet.apache.org/docs/4.8.0-beta00009/styles/main.css">
    <meta property="docfx:navrel" content="toc.html">
    <meta property="docfx:tocrel" content="core/toc.html">
    
    <meta property="docfx:rel" content="https://lucenenet.apache.org/docs/4.8.0-beta00009/">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="/">
                <img id="logo" class="svg" src="https://lucenenet.apache.org/docs/4.8.0-beta00009/logo/lucene-net-color.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search">
            <ul class="level0 breadcrumb">
                <li>
                    <a href="https://lucenenet.apache.org/docs/4.8.0-beta00009/">API</a>
                     <span id="breadcrumb">
                        <ul class="breadcrumb">
                          <li></li>
                        </ul>
                    </span>   
                </li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="Lucene.Net.Util">
  
  <h1 id="Lucene_Net_Util" data-uid="Lucene.Net.Util" class="text-break">Namespace Lucene.Net.Util
  </h1>
  <div class="markdown level0 summary"><!--
 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<p>Some utility classes.</p>
</div>
  <div class="markdown level0 conceptual"></div>
  <div class="markdown level0 remarks"></div>
    <h3 id="classes">Classes
  </h3>
      <h4><a class="xref" href="Lucene.Net.Util.AlreadySetException.html">AlreadySetException</a></h4>
      <section><p>Thrown when <a class="xref" href="Lucene.Net.Util.SetOnce-1.html#Lucene_Net_Util_SetOnce_1_Set__0_">Set(T)</a> is called more than once. </p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.ArrayUtil.html">ArrayUtil</a></h4>
      <section><p>Methods for manipulating arrays.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.Attribute.html">Attribute</a></h4>
      <section><p>Base class for Attributes that can be added to a
<a class="xref" href="Lucene.Net.Util.AttributeSource.html">AttributeSource</a>.
<p>
Attributes are used to add data in a dynamic, yet type-safe way to a source
of usually streamed objects, e. g. a <a class="xref" href="Lucene.Net.Analysis.TokenStream.html">TokenStream</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.AttributeSource.html">AttributeSource</a></h4>
      <section><p>An <a class="xref" href="Lucene.Net.Util.AttributeSource.html">AttributeSource</a> contains a list of different <a class="xref" href="Lucene.Net.Util.Attribute.html">Attribute</a>s,
and methods to add and get them. There can only be a single instance
of an attribute in the same <a class="xref" href="Lucene.Net.Util.AttributeSource.html">AttributeSource</a> instance. This is ensured
by passing in the actual type of the <a class="xref" href="Lucene.Net.Util.IAttribute.html">IAttribute</a> to
the <a class="xref" href="Lucene.Net.Util.AttributeSource.html#Lucene_Net_Util_AttributeSource_AddAttribute__1">AddAttribute&lt;T&gt;()</a>, which then checks if an instance of
that type is already present. If yes, it returns the instance, otherwise
it creates a new instance and returns it.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.AttributeSource.AttributeFactory.html">AttributeSource.AttributeFactory</a></h4>
      <section><p>An <a class="xref" href="Lucene.Net.Util.AttributeSource.AttributeFactory.html">AttributeSource.AttributeFactory</a> creates instances of <a class="xref" href="Lucene.Net.Util.Attribute.html">Attribute</a>s.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.AttributeSource.State.html">AttributeSource.State</a></h4>
      <section><p>This class holds the state of an <a class="xref" href="Lucene.Net.Util.AttributeSource.html">AttributeSource</a>. </p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.Bits.html">Bits</a></h4>
      <section></section>
      <h4><a class="xref" href="Lucene.Net.Util.Bits.MatchAllBits.html">Bits.MatchAllBits</a></h4>
      <section><p>Bits impl of the specified length with all bits set.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.Bits.MatchNoBits.html">Bits.MatchNoBits</a></h4>
      <section><p>Bits impl of the specified length with no bits set.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.BitUtil.html">BitUtil</a></h4>
      <section><p>A variety of high efficiency bit twiddling routines.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.BroadWord.html">BroadWord</a></h4>
      <section><p>Methods and constants inspired by the article
&quot;Broadword Implementation of Rank/Select Queries&quot; by Sebastiano Vigna, January 30, 2012:
<ul><li>algorithm 1: <span class="xref">Lucene.Net.Util.BroadWord.BitCount(System.Int64)</span>, count of set bits in a <span class="xref">System.Int64</span></li><li>algorithm 2: <a class="xref" href="Lucene.Net.Util.BroadWord.html#Lucene_Net_Util_BroadWord_Select_System_Int64_System_Int32_">Select(Int64, Int32)</a>, selection of a set bit in a <span class="xref">System.Int64</span>,</li><li>bytewise signed smaller &lt;<sub><small>8</small></sub> operator: <a class="xref" href="Lucene.Net.Util.BroadWord.html#Lucene_Net_Util_BroadWord_SmallerUpTo7_8_System_Int64_System_Int64_">SmallerUpTo7_8(Int64, Int64)</a>.</li><li>shortwise signed smaller &lt;<sub><small>16</small></sub> operator: <a class="xref" href="Lucene.Net.Util.BroadWord.html#Lucene_Net_Util_BroadWord_SmallerUpto15_16_System_Int64_System_Int64_">SmallerUpto15_16(Int64, Int64)</a>.</li><li>some of the Lk and Hk constants that are used by the above:
        L8 <a class="xref" href="Lucene.Net.Util.BroadWord.html#Lucene_Net_Util_BroadWord_L8_L">L8_L</a>, H8 <a class="xref" href="Lucene.Net.Util.BroadWord.html#Lucene_Net_Util_BroadWord_H8_L">H8_L</a>, L9 <a class="xref" href="Lucene.Net.Util.BroadWord.html#Lucene_Net_Util_BroadWord_L9_L">L9_L</a>, L16 <a class="xref" href="Lucene.Net.Util.BroadWord.html#Lucene_Net_Util_BroadWord_L16_L">L16_L</a>and H16 <a class="xref" href="Lucene.Net.Util.BroadWord.html#Lucene_Net_Util_BroadWord_H8_L">H8_L</a>.</li></ul></p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.BundleResourceManagerFactory.html">BundleResourceManagerFactory</a></h4>
      <section><p>This implementation of <a class="xref" href="Lucene.Net.Util.IResourceManagerFactory.html">IResourceManagerFactory</a> uses a convention
to retrieve resources. In Java NLS, the convention is to use the same name for the
resource key propeties and for the resource file names. This presents a problem
for .NET because the resource generator already creates an internal class with the
same name as the <code>.resx</code> file.
<p>
To work around this, we use the convention of appending the suffix &quot;Bundle&quot; to 
the end of the type the resource key propeties are stored in. For example,
if our constants are stored in a class named ErrorMessages, the type
that will be looked up by this factory will be ErrorMessagesBundle (which is the
name of the <code>.resx</code> file that should be added to your project).
<p>
This implementation can be inherited to use a different convention or can be replaced
to get the resources from an external source.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.ByteBlockPool.html">ByteBlockPool</a></h4>
      <section><p>Class that Posting and PostingVector use to write byte
streams into shared fixed-size <span class="xref">byte[]</span> arrays.  The idea
is to allocate slices of increasing lengths. For
example, the first slice is 5 bytes, the next slice is
14, etc.  We start by writing our bytes into the first
5 bytes.  When we hit the end of the slice, we allocate
the next slice and then write the address of the new
slice into the last 4 bytes of the previous slice (the
&quot;forwarding address&quot;).
<p>
Each slice is filled with 0&apos;s initially, and we mark
the end with a non-zero byte.  This way the methods
that are writing into the slice don&apos;t need to record
its length and instead allocate a new slice once they
hit a non-zero byte.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.ByteBlockPool.Allocator.html">ByteBlockPool.Allocator</a></h4>
      <section><p>Abstract class for allocating and freeing byte
blocks.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.ByteBlockPool.DirectAllocator.html">ByteBlockPool.DirectAllocator</a></h4>
      <section><p>A simple <a class="xref" href="Lucene.Net.Util.ByteBlockPool.Allocator.html">ByteBlockPool.Allocator</a> that never recycles. </p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.ByteBlockPool.DirectTrackingAllocator.html">ByteBlockPool.DirectTrackingAllocator</a></h4>
      <section><p>A simple <a class="xref" href="Lucene.Net.Util.ByteBlockPool.Allocator.html">ByteBlockPool.Allocator</a> that never recycles, but
tracks how much total RAM is in use.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.BytesRef.html">BytesRef</a></h4>
      <section><p>Represents <span class="xref">byte[]</span>, as a slice (offset + length) into an
existing <span class="xref">byte[]</span>.  The <a class="xref" href="Lucene.Net.Util.BytesRef.html#Lucene_Net_Util_BytesRef_Bytes">Bytes</a> property should never be <code>null</code>;
use <a class="xref" href="Lucene.Net.Util.BytesRef.html#Lucene_Net_Util_BytesRef_EMPTY_BYTES">EMPTY_BYTES</a> if necessary.</p>
<p><p><strong>Important note:</strong> Unless otherwise noted, Lucene uses this class to
represent terms that are encoded as <strong>UTF8</strong> bytes in the index. To
convert them to a .NET <span class="xref">System.String</span> (which is UTF16), use <a class="xref" href="Lucene.Net.Util.BytesRef.html#Lucene_Net_Util_BytesRef_Utf8ToString">Utf8ToString()</a>.
Using code like <code>new String(bytes, offset, length)</code> to do this
is <strong>wrong</strong>, as it does not respect the correct character set
and may return wrong results (depending on the platform&apos;s defaults)!</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.BytesRefArray.html">BytesRefArray</a></h4>
      <section><p>A simple append only random-access <a class="xref" href="Lucene.Net.Util.BytesRef.html">BytesRef</a> array that stores full
copies of the appended bytes in a <a class="xref" href="Lucene.Net.Util.ByteBlockPool.html">ByteBlockPool</a>.
<p>
<strong>Note: this class is not Thread-Safe!</strong>
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div><div class="lucene-block lucene-experimental">This is a Lucene.NET EXPERIMENTAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.BytesRefHash.html">BytesRefHash</a></h4>
      <section><p><a class="xref" href="Lucene.Net.Util.BytesRefHash.html">BytesRefHash</a> is a special purpose hash-map like data-structure
optimized for <a class="xref" href="Lucene.Net.Util.BytesRef.html">BytesRef</a> instances. <a class="xref" href="Lucene.Net.Util.BytesRefHash.html">BytesRefHash</a> maintains mappings of
byte arrays to ids (Map&lt;BytesRef,int&gt;) storing the hashed bytes
efficiently in continuous storage. The mapping to the id is
encapsulated inside <a class="xref" href="Lucene.Net.Util.BytesRefHash.html">BytesRefHash</a> and is guaranteed to be increased
for each added <a class="xref" href="Lucene.Net.Util.BytesRef.html">BytesRef</a>.</p>
<p>
Note: The maximum capacity <a class="xref" href="Lucene.Net.Util.BytesRef.html">BytesRef</a> instance passed to
<a class="xref" href="Lucene.Net.Util.BytesRefHash.html#Lucene_Net_Util_BytesRefHash_Add_Lucene_Net_Util_BytesRef_">Add(BytesRef)</a> must not be longer than <a class="xref" href="Lucene.Net.Util.ByteBlockPool.html#Lucene_Net_Util_ByteBlockPool_BYTE_BLOCK_SIZE">BYTE_BLOCK_SIZE</a>-2.
The internal storage is limited to 2GB total byte storage.
</p>

<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.BytesRefHash.BytesStartArray.html">BytesRefHash.BytesStartArray</a></h4>
      <section><p>Manages allocation of the per-term addresses. </p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.BytesRefHash.DirectBytesStartArray.html">BytesRefHash.DirectBytesStartArray</a></h4>
      <section><p>A simple <a class="xref" href="Lucene.Net.Util.BytesRefHash.BytesStartArray.html">BytesRefHash.BytesStartArray</a> that tracks
memory allocation using a private <a class="xref" href="Lucene.Net.Util.Counter.html">Counter</a>
instance.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.BytesRefHash.MaxBytesLengthExceededException.html">BytesRefHash.MaxBytesLengthExceededException</a></h4>
      <section><p>Thrown if a <a class="xref" href="Lucene.Net.Util.BytesRef.html">BytesRef</a> exceeds the <a class="xref" href="Lucene.Net.Util.BytesRefHash.html">BytesRefHash</a> limit of
<a class="xref" href="Lucene.Net.Util.ByteBlockPool.html#Lucene_Net_Util_ByteBlockPool_BYTE_BLOCK_SIZE">BYTE_BLOCK_SIZE</a>-2.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.BytesRefIterator.html">BytesRefIterator</a></h4>
      <section><p>LUCENENET specific class to make the syntax of creating an empty
<a class="xref" href="Lucene.Net.Util.IBytesRefIterator.html">IBytesRefIterator</a> the same as it was in Lucene. Example:</p>
<pre><code>var iter = BytesRefIterator.Empty;</code></pre>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.CharsRef.html">CharsRef</a></h4>
      <section><p>Represents <span class="xref">char[]</span>, as a slice (offset + Length) into an existing <span class="xref">char[]</span>.
The <a class="xref" href="Lucene.Net.Util.CharsRef.html#Lucene_Net_Util_CharsRef_Chars">Chars</a> property should never be <code>null</code>; use
<a class="xref" href="Lucene.Net.Util.CharsRef.html#Lucene_Net_Util_CharsRef_EMPTY_CHARS">EMPTY_CHARS</a> if necessary.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.CollectionUtil.html">CollectionUtil</a></h4>
      <section><p>Methods for manipulating (sorting) collections.
Sort methods work directly on the supplied lists and don&apos;t copy to/from arrays
before/after. For medium size collections as used in the Lucene indexer that is
much more efficient.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.CommandLineUtil.html">CommandLineUtil</a></h4>
      <section><p>Class containing some useful methods used by command line tools</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.Constants.html">Constants</a></h4>
      <section><p>Some useful constants.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.Counter.html">Counter</a></h4>
      <section><p>Simple counter class
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div><div class="lucene-block lucene-experimental">This is a Lucene.NET EXPERIMENTAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.DisposableThreadLocal-1.html">DisposableThreadLocal&lt;T&gt;</a></h4>
      <section><p>Java&apos;s builtin ThreadLocal has a serious flaw:
it can take an arbitrarily long amount of time to
dereference the things you had stored in it, even once the
ThreadLocal instance itself is no longer referenced.
This is because there is single, master map stored for
each thread, which all ThreadLocals share, and that
master map only periodically purges &quot;stale&quot; entries.
<p>
While not technically a memory leak, because eventually
the memory will be reclaimed, it can take a long time
and you can easily hit <span class="xref">System.OutOfMemoryException</span> because from the
GC&apos;s standpoint the stale entries are not reclaimable.
<p>
This class works around that, by only enrolling
WeakReference values into the ThreadLocal, and
separately holding a hard reference to each stored
value.  When you call <a class="xref" href="Lucene.Net.Util.DisposableThreadLocal-1.html#Lucene_Net_Util_DisposableThreadLocal_1_Dispose">Dispose()</a>, these hard
references are cleared and then GC is freely able to
reclaim space by objects stored in it.
<p>
You should not call <a class="xref" href="Lucene.Net.Util.DisposableThreadLocal-1.html#Lucene_Net_Util_DisposableThreadLocal_1_Dispose">Dispose()</a> until all
threads are done using the instance.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.DocIdBitSet.html">DocIdBitSet</a></h4>
      <section><p>Simple <a class="xref" href="Lucene.Net.Search.DocIdSet.html">DocIdSet</a> and <a class="xref" href="Lucene.Net.Search.DocIdSetIterator.html">DocIdSetIterator</a> backed by a <span class="xref">System.Collections.BitArray</span> </p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.DoubleBarrelLRUCache.html">DoubleBarrelLRUCache</a></h4>
      <section><p>LUCENENET specific class to nest the <a class="xref" href="Lucene.Net.Util.DoubleBarrelLRUCache.CloneableKey.html">DoubleBarrelLRUCache.CloneableKey</a>
so it can be accessed without referencing the generic closing types
of <a class="xref" href="Lucene.Net.Util.DoubleBarrelLRUCache-2.html">DoubleBarrelLRUCache&lt;TKey, TValue&gt;</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.DoubleBarrelLRUCache.CloneableKey.html">DoubleBarrelLRUCache.CloneableKey</a></h4>
      <section><p>Object providing clone(); the key class must subclass this.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.DoubleBarrelLRUCache-2.html">DoubleBarrelLRUCache&lt;TKey, TValue&gt;</a></h4>
      <section><p>Simple concurrent LRU cache, using a &quot;double barrel&quot;
approach where two ConcurrentHashMaps record entries.</p>
<p>At any given time, one hash is primary and the other
is secondary.  <a class="xref" href="Lucene.Net.Util.DoubleBarrelLRUCache-2.html#Lucene_Net_Util_DoubleBarrelLRUCache_2_Get__0_">Get(TKey)</a> first checks primary, and if
that&apos;s a miss, checks secondary.  If secondary has the
entry, it&apos;s promoted to primary (<strong>NOTE</strong>: the key is
cloned at this point).  Once primary is full, the
secondary is cleared and the two are swapped.</p>

<p>This is not as space efficient as other possible
concurrent approaches (see LUCENE-2075): to achieve
perfect LRU(N) it requires 2*N storage.  But, this
approach is relatively simple and seems in practice to
not grow unbounded in size when under hideously high
load.</p>

<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.ExceptionExtensions.html">ExceptionExtensions</a></h4>
      <section><p>Extensions to the <span class="xref">System.Exception</span> class to allow for
adding and retrieving suppressed exceptions, like you can do in Java.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.ExcludeServiceAttribute.html">ExcludeServiceAttribute</a></h4>
      <section><p>Base class for <a class="xref" href="Lucene.Net.Util.Attribute.html">Attribute</a> types that exclude services from Reflection scanning.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.FieldCacheSanityChecker.html">FieldCacheSanityChecker</a></h4>
      <section><p><p>
Provides methods for sanity checking that entries in the FieldCache
are not wasteful or inconsistent.
</p>
<p>
Lucene 2.9 Introduced numerous enhancements into how the FieldCache
is used by the low levels of Lucene searching (for Sorting and
ValueSourceQueries) to improve both the speed for Sorting, as well
as reopening of IndexReaders.  But these changes have shifted the
usage of FieldCache from &quot;top level&quot; IndexReaders (frequently a
MultiReader or DirectoryReader) down to the leaf level SegmentReaders.
As a result, existing applications that directly access the FieldCache
may find RAM usage increase significantly when upgrading to 2.9 or
Later.  This class provides an API for these applications (or their
Unit tests) to check at run time if the FieldCache contains &quot;insane&quot;
usages of the FieldCache.
</p></p>
<div class="lucene-block lucene-experimental">This is a Lucene.NET EXPERIMENTAL API, use at your own risk</div><p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.FieldCacheSanityChecker.Insanity.html">FieldCacheSanityChecker.Insanity</a></h4>
      <section><p>Simple container for a collection of related <a class="xref" href="Lucene.Net.Search.FieldCache.CacheEntry.html">FieldCache.CacheEntry</a> objects that
in conjunction with each other represent some &quot;insane&quot; usage of the
<a class="xref" href="Lucene.Net.Search.IFieldCache.html">IFieldCache</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.FieldCacheSanityChecker.InsanityType.html">FieldCacheSanityChecker.InsanityType</a></h4>
      <section><p>An Enumeration of the different types of &quot;insane&quot; behavior that
may be detected in a <a class="xref" href="Lucene.Net.Search.IFieldCache.html">IFieldCache</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.FilterIterator-1.html">FilterIterator&lt;T&gt;</a></h4>
      <section><p>An <span class="xref">System.Collections.Generic.IEnumerator&lt;T&gt;</span> implementation that filters elements with a boolean predicate. </p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.FixedBitSet.html">FixedBitSet</a></h4>
      <section><p>BitSet of fixed length (numBits), backed by accessible (<a class="xref" href="Lucene.Net.Util.FixedBitSet.html#Lucene_Net_Util_FixedBitSet_GetBits">GetBits()</a>)
long[], accessed with an int index, implementing <a class="xref" href="Lucene.Net.Util.FixedBitSet.html#Lucene_Net_Util_FixedBitSet_GetBits">GetBits()</a> and
<a class="xref" href="Lucene.Net.Search.DocIdSet.html">DocIdSet</a>. If you need to manage more than 2.1B bits, use
<a class="xref" href="Lucene.Net.Util.Int64BitSet.html">Int64BitSet</a>.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.FixedBitSet.FixedBitSetIterator.html">FixedBitSet.FixedBitSetIterator</a></h4>
      <section><p>A <a class="xref" href="Lucene.Net.Search.DocIdSetIterator.html">DocIdSetIterator</a> which iterates over set bits in a
<a class="xref" href="Lucene.Net.Util.FixedBitSet.html">FixedBitSet</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.GrowableByteArrayDataOutput.html">GrowableByteArrayDataOutput</a></h4>
      <section><p>A <a class="xref" href="Lucene.Net.Store.DataOutput.html">DataOutput</a> that can be used to build a <span class="xref">byte[]</span>.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.IndexableBinaryStringTools.html">IndexableBinaryStringTools</a></h4>
      <section><p>Provides support for converting byte sequences to <span class="xref">System.String</span>s and back again.
The resulting <span class="xref">System.String</span>s preserve the original byte sequences&apos; sort order.
<p>
The <span class="xref">System.String</span>s are constructed using a Base 8000h encoding of the original
binary data - each char of an encoded <span class="xref">System.String</span> represents a 15-bit chunk
from the byte sequence.  Base 8000h was chosen because it allows for all
lower 15 bits of char to be used without restriction; the surrogate range
[U+D8000-U+DFFF] does not represent valid chars, and would require
complicated handling to avoid them and allow use of char&apos;s high bit.
<p>
Although unset bits are used as padding in the final char, the original
byte sequence could contain trailing bytes with no set bits (null bytes):
padding is indistinguishable from valid information.  To overcome this
problem, a char is appended, indicating the number of encoded bytes in the
final content char.
<p>
<div class="lucene-block lucene-experimental">This is a Lucene.NET EXPERIMENTAL API, use at your own risk</div><p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.InfoStream.html">InfoStream</a></h4>
      <section><p>Debugging API for Lucene classes such as <a class="xref" href="Lucene.Net.Index.IndexWriter.html">IndexWriter</a>
and <a class="xref" href="Lucene.Net.Index.SegmentInfos.html">SegmentInfos</a>.
<p>
NOTE: Enabling infostreams may cause performance degradation
in some components.
</p></p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.InPlaceMergeSorter.html">InPlaceMergeSorter</a></h4>
      <section><p><a class="xref" href="Lucene.Net.Util.Sorter.html">Sorter</a> implementation based on the merge-sort algorithm that merges
in place (no extra memory will be allocated). Small arrays are sorted with
insertion sort.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.Int32BlockPool.html">Int32BlockPool</a></h4>
      <section><p>A pool for <span class="xref">System.Int32</span> blocks similar to <a class="xref" href="Lucene.Net.Util.ByteBlockPool.html">ByteBlockPool</a>.
<p>
NOTE: This was IntBlockPool in Lucene
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.Int32BlockPool.Allocator.html">Int32BlockPool.Allocator</a></h4>
      <section><p>Abstract class for allocating and freeing <span class="xref">System.Int32</span>
blocks.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.Int32BlockPool.DirectAllocator.html">Int32BlockPool.DirectAllocator</a></h4>
      <section><p>A simple <a class="xref" href="Lucene.Net.Util.Int32BlockPool.Allocator.html">Int32BlockPool.Allocator</a> that never recycles. </p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.Int32BlockPool.SliceReader.html">Int32BlockPool.SliceReader</a></h4>
      <section><p>A <a class="xref" href="Lucene.Net.Util.Int32BlockPool.SliceReader.html">Int32BlockPool.SliceReader</a> that can read <span class="xref">System.Int32</span> slices written by a <a class="xref" href="Lucene.Net.Util.Int32BlockPool.SliceWriter.html">Int32BlockPool.SliceWriter</a>.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.Int32BlockPool.SliceWriter.html">Int32BlockPool.SliceWriter</a></h4>
      <section><p>A <a class="xref" href="Lucene.Net.Util.Int32BlockPool.SliceWriter.html">Int32BlockPool.SliceWriter</a> that allows to write multiple integer slices into a given <a class="xref" href="Lucene.Net.Util.Int32BlockPool.html">Int32BlockPool</a>.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.Int32sRef.html">Int32sRef</a></h4>
      <section><p>Represents <span class="xref">int[]</span>, as a slice (offset + length) into an
existing <span class="xref">int[]</span>.  The <a class="xref" href="Lucene.Net.Util.Int32sRef.html#Lucene_Net_Util_Int32sRef_Int32s">Int32s</a> member should never be <code>null</code>; use
<a class="xref" href="Lucene.Net.Util.Int32sRef.html#Lucene_Net_Util_Int32sRef_EMPTY_INT32S">EMPTY_INT32S</a> if necessary.
<p>
NOTE: This was IntsRef in Lucene
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.Int64BitSet.html">Int64BitSet</a></h4>
      <section><p>BitSet of fixed length (<span class="xref">Lucene.Net.Util.Int64BitSet.numBits</span>), backed by accessible (<a class="xref" href="Lucene.Net.Util.Int64BitSet.html#Lucene_Net_Util_Int64BitSet_GetBits">GetBits()</a>)
<span class="xref">long[]</span>, accessed with a <span class="xref">System.Int64</span> index. Use it only if you intend to store more
than 2.1B bits, otherwise you should use <a class="xref" href="Lucene.Net.Util.FixedBitSet.html">FixedBitSet</a>.
<p>
NOTE: This was LongBitSet in Lucene
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.Int64sRef.html">Int64sRef</a></h4>
      <section><p>Represents <span class="xref">long[]</span>, as a slice (offset + length) into an
existing <span class="xref">long[]</span>.  The <a class="xref" href="Lucene.Net.Util.Int64sRef.html#Lucene_Net_Util_Int64sRef_Int64s">Int64s</a> member should never be <code>null</code>; use
<a class="xref" href="Lucene.Net.Util.Int64sRef.html#Lucene_Net_Util_Int64sRef_EMPTY_INT64S">EMPTY_INT64S</a> if necessary.
<p>
NOTE: This was LongsRef in Lucene
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.Int64Values.html">Int64Values</a></h4>
      <section><p>Abstraction over an array of <span class="xref">System.Int64</span>s.
This class extends <a class="xref" href="Lucene.Net.Index.NumericDocValues.html">NumericDocValues</a> so that we don&apos;t need to add another
level of abstraction every time we want eg. to use the <a class="xref" href="Lucene.Net.Util.Packed.PackedInt32s.html">PackedInt32s</a>
utility classes to represent a <a class="xref" href="Lucene.Net.Index.NumericDocValues.html">NumericDocValues</a> instance.
<p>
NOTE: This was LongValues in Lucene
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.IntroSorter.html">IntroSorter</a></h4>
      <section><p><a class="xref" href="Lucene.Net.Util.Sorter.html">Sorter</a> implementation based on a variant of the quicksort algorithm
called <a href="http://en.wikipedia.org/wiki/Introsort">introsort</a>: when
the recursion level exceeds the log of the length of the array to sort, it
falls back to heapsort. This prevents quicksort from running into its
worst-case quadratic runtime. Small arrays are sorted with
insertion sort.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.IOUtils.html">IOUtils</a></h4>
      <section><p>This class emulates the new Java 7 &quot;Try-With-Resources&quot; statement.
Remove once Lucene is on Java 7.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.ListExtensions.html">ListExtensions</a></h4>
      <section><p>Extensions to <span class="xref">System.Collections.Generic.IList&lt;T&gt;</span>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.LuceneVersionExtensions.html">LuceneVersionExtensions</a></h4>
      <section><p>Extension methods to the <a class="xref" href="Lucene.Net.Util.LuceneVersion.html">LuceneVersion</a> enumeration to provide
version comparison and parsing functionality.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.MapOfSets-2.html">MapOfSets&lt;TKey, TValue&gt;</a></h4>
      <section><p>Helper class for keeping Lists of Objects associated with keys. <strong>WARNING: this CLASS IS NOT THREAD SAFE</strong>
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.MathUtil.html">MathUtil</a></h4>
      <section><p>Math static utility methods.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.MergedIterator-1.html">MergedIterator&lt;T&gt;</a></h4>
      <section><p>Provides a merged sorted view from several sorted iterators.
<p>
If built with <span class="xref">Lucene.Net.Util.MergedIterator`1.removeDuplicates</span> set to <code>true</code> and an element
appears in multiple iterators then it is deduplicated, that is this iterator
returns the sorted union of elements.
<p>
If built with <span class="xref">Lucene.Net.Util.MergedIterator`1.removeDuplicates</span> set to <code>false</code> then all elements
in all iterators are returned.
<p>
Caveats:
<ul><li>The behavior is undefined if the iterators are not actually sorted.</li><li>Null elements are unsupported.</li><li>If <span class="xref">Lucene.Net.Util.MergedIterator`1.removeDuplicates</span> is set to <code>true</code> and if a single iterator contains
      duplicates then they will not be deduplicated.</li><li>When elements are deduplicated it is not defined which one is returned.</li><li>If <span class="xref">Lucene.Net.Util.MergedIterator`1.removeDuplicates</span> is set to <code>false</code> then the order in which duplicates
      are returned isn&apos;t defined.</li></ul>
<p>
The caller is responsible for disposing the <span class="xref">System.Collections.Generic.IEnumerator&lt;T&gt;</span> instances that are passed
into the constructor, <a class="xref" href="Lucene.Net.Util.MergedIterator-1.html">MergedIterator&lt;T&gt;</a> doesn&apos;t do it automatically.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.NamedServiceFactory-1.html">NamedServiceFactory&lt;TService&gt;</a></h4>
      <section><p>LUCENENET specific abstract class containing common fuctionality for named service factories.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.NumberFormat.html">NumberFormat</a></h4>
      <section><p>A LUCENENET specific class that represents a numeric format. This class
mimicks the design of Java&apos;s NumberFormat class, which unlike the
<span class="xref">System.Globalization.NumberFormatInfo</span> class in .NET, can be subclassed.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.NumericUtils.html">NumericUtils</a></h4>
      <section><p>This is a helper class to generate prefix-encoded representations for numerical values
and supplies converters to represent float/double values as sortable integers/longs.</p>
<p><p>To quickly execute range queries in Apache Lucene, a range is divided recursively
into multiple intervals for searching: The center of the range is searched only with
the lowest possible precision in the trie, while the boundaries are matched
more exactly. this reduces the number of terms dramatically.</p>
<p><p>This class generates terms to achieve this: First the numerical integer values need to
be converted to bytes. For that integer values (32 bit or 64 bit) are made unsigned
and the bits are converted to ASCII chars with each 7 bit. The resulting byte[] is
sortable like the original integer value (even using UTF-8 sort order). Each value is also
prefixed (in the first char) by the <code>shift</code> value (number of bits removed) used
during encoding.</p>
<p><p>To also index floating point numbers, this class supplies two methods to convert them
to integer values by changing their bit layout: <a class="xref" href="Lucene.Net.Util.NumericUtils.html#Lucene_Net_Util_NumericUtils_DoubleToSortableInt64_System_Double_">DoubleToSortableInt64(Double)</a>,
<a class="xref" href="Lucene.Net.Util.NumericUtils.html#Lucene_Net_Util_NumericUtils_SingleToSortableInt32_System_Single_">SingleToSortableInt32(Single)</a>. You will have no precision loss by
converting floating point numbers to integers and back (only that the integer form
is not usable). Other data types like dates can easily converted to <span class="xref">System.Int64</span>s or <span class="xref">System.Int32</span>s (e.g.
date to long: <span class="xref">System.DateTime.Ticks</span>).</p>
<p><p>For easy usage, the trie algorithm is implemented for indexing inside
<a class="xref" href="Lucene.Net.Analysis.NumericTokenStream.html">NumericTokenStream</a> that can index <span class="xref">System.Int32</span>, <span class="xref">System.Int64</span>,
<span class="xref">System.Single</span>, and <span class="xref">System.Double</span>. For querying,
<a class="xref" href="Lucene.Net.Search.NumericRangeQuery.html">NumericRangeQuery</a> and <a class="xref" href="Lucene.Net.Search.NumericRangeFilter.html">NumericRangeFilter</a> implement the query part
for the same data types.</p>
<p><p>This class can also be used, to generate lexicographically sortable (according to
<a class="xref" href="Lucene.Net.Util.BytesRef.html#Lucene_Net_Util_BytesRef_UTF8SortedAsUTF16Comparer">UTF8SortedAsUTF16Comparer</a>) representations of numeric data
types for other usages (e.g. sorting).</p>
<p><p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div><p>@since 2.9, API changed non backwards-compliant in 4.0</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.NumericUtils.Int32RangeBuilder.html">NumericUtils.Int32RangeBuilder</a></h4>
      <section><p>Callback for <a class="xref" href="Lucene.Net.Util.NumericUtils.html#Lucene_Net_Util_NumericUtils_SplitInt32Range_Lucene_Net_Util_NumericUtils_Int32RangeBuilder_System_Int32_System_Int32_System_Int32_">SplitInt32Range(NumericUtils.Int32RangeBuilder, Int32, Int32, Int32)</a>.
You need to override only one of the methods.
<p>
NOTE: This was IntRangeBuilder in Lucene</p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div><p>@since 2.9, API changed non backwards-compliant in 4.0</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.NumericUtils.Int64RangeBuilder.html">NumericUtils.Int64RangeBuilder</a></h4>
      <section><p>Callback for <a class="xref" href="Lucene.Net.Util.NumericUtils.html#Lucene_Net_Util_NumericUtils_SplitInt64Range_Lucene_Net_Util_NumericUtils_Int64RangeBuilder_System_Int32_System_Int64_System_Int64_">SplitInt64Range(NumericUtils.Int64RangeBuilder, Int32, Int64, Int64)</a>.
You need to override only one of the methods.
<p>
NOTE: This was LongRangeBuilder in Lucene
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div><p>@since 2.9, API changed non backwards-compliant in 4.0</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.OfflineSorter.html">OfflineSorter</a></h4>
      <section><p>On-disk sorting of byte arrays. Each byte array (entry) is a composed of the following
fields:
<ul><li>(two bytes) length of the following byte array,</li><li>exactly the above count of bytes for the sequence to be sorted.</li></ul></p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.OfflineSorter.BufferSize.html">OfflineSorter.BufferSize</a></h4>
      <section><p>A bit more descriptive unit for constructors.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.OfflineSorter.ByteSequencesReader.html">OfflineSorter.ByteSequencesReader</a></h4>
      <section><p>Utility class to read length-prefixed <span class="xref">byte[]</span> entries from an input.
Complementary to <a class="xref" href="Lucene.Net.Util.OfflineSorter.ByteSequencesWriter.html">OfflineSorter.ByteSequencesWriter</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.OfflineSorter.ByteSequencesWriter.html">OfflineSorter.ByteSequencesWriter</a></h4>
      <section><p>Utility class to emit length-prefixed <span class="xref">byte[]</span> entries to an output stream for sorting.
Complementary to <a class="xref" href="Lucene.Net.Util.OfflineSorter.ByteSequencesReader.html">OfflineSorter.ByteSequencesReader</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.OfflineSorter.SortInfo.html">OfflineSorter.SortInfo</a></h4>
      <section><p>Sort info (debugging mostly).</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.OpenBitSet.html">OpenBitSet</a></h4>
      <section><p>An &quot;open&quot; BitSet implementation that allows direct access to the array of words
storing the bits.
<p>
NOTE: This can be used in .NET any place where a <code>java.util.BitSet</code> is used in Java.
<p>
Unlike <code>java.util.BitSet</code>, the fact that bits are packed into an array of longs
is part of the interface.  This allows efficient implementation of other algorithms
by someone other than the author.  It also allows one to efficiently implement
alternate serialization or interchange formats.
<p>
<a class="xref" href="Lucene.Net.Util.OpenBitSet.html">OpenBitSet</a> is faster than <code>java.util.BitSet</code> in most operations
and <em>much</em> faster at calculating cardinality of sets and results of set operations.
It can also handle sets of larger cardinality (up to 64 * 2**32-1)
<p>
The goals of <a class="xref" href="Lucene.Net.Util.OpenBitSet.html">OpenBitSet</a> are the fastest implementation possible, and
maximum code reuse.  Extra safety and encapsulation
may always be built on top, but if that&apos;s built in, the cost can never be removed (and
hence people re-implement their own version in order to get better performance).
<p>
<h3>Performance Results</h3></p>
<p>Test system: Pentium 4, Sun Java 1.5_06 -server -Xbatch -Xmx64M
<p>BitSet size = 1,000,000
<p>Results are java.util.BitSet time divided by OpenBitSet time.
<table><thead><tr><th>cardinalityIntersectionCountUnionNextSetBitGetGetIterator</th><th></th></tr></thead><tbody><tr><td>50% full</td><td>3.363.961.441.461.991.58</td></tr><tr><td>1% full</td><td>3.313.90 1.04 0.99</td></tr></tbody></table>
<p>
<p>
Test system: AMD Opteron, 64 bit linux, Sun Java 1.5_06 -server -Xbatch -Xmx64M
<p>BitSet size = 1,000,000
<p>Results are java.util.BitSet time divided by OpenBitSet time.
<table><thead><tr><th>cardinalityIntersectionCountUnionNextSetBitGetGetIterator</th><th></th></tr></thead><tbody><tr><td>50% full</td><td>2.503.501.001.031.121.25</td></tr><tr><td>1% full</td><td>2.513.49 1.00 1.02</td></tr></tbody></table></p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.OpenBitSetDISI.html">OpenBitSetDISI</a></h4>
      <section><p><a class="xref" href="Lucene.Net.Util.OpenBitSet.html">OpenBitSet</a> with added methods to bulk-update the bits
from a <a class="xref" href="Lucene.Net.Search.DocIdSetIterator.html">DocIdSetIterator</a>. (DISI stands for <a class="xref" href="Lucene.Net.Search.DocIdSetIterator.html">DocIdSetIterator</a>).</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.OpenBitSetIterator.html">OpenBitSetIterator</a></h4>
      <section><p>An iterator to iterate over set bits in an <a class="xref" href="Lucene.Net.Util.OpenBitSet.html">OpenBitSet</a>.
this is faster than <a class="xref" href="Lucene.Net.Util.OpenBitSet.html#Lucene_Net_Util_OpenBitSet_NextSetBit_System_Int64_">NextSetBit(Int64)</a> for iterating over the complete set of bits,
especially when the density of the bits set is high.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.PagedBytes.html">PagedBytes</a></h4>
      <section><p>Represents a logical <span class="xref">byte[]</span> as a series of pages.  You
can write-once into the logical <span class="xref">byte[]</span> (append only),
using copy, and then retrieve slices (<a class="xref" href="Lucene.Net.Util.BytesRef.html">BytesRef</a>) into it
using fill.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.PagedBytes.PagedBytesDataInput.html">PagedBytes.PagedBytesDataInput</a></h4>
      <section></section>
      <h4><a class="xref" href="Lucene.Net.Util.PagedBytes.PagedBytesDataOutput.html">PagedBytes.PagedBytesDataOutput</a></h4>
      <section></section>
      <h4><a class="xref" href="Lucene.Net.Util.PagedBytes.Reader.html">PagedBytes.Reader</a></h4>
      <section><p>Provides methods to read <a class="xref" href="Lucene.Net.Util.BytesRef.html">BytesRef</a>s from a frozen
<a class="xref" href="Lucene.Net.Util.PagedBytes.html">PagedBytes</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.PForDeltaDocIdSet.html">PForDeltaDocIdSet</a></h4>
      <section><p><a class="xref" href="Lucene.Net.Search.DocIdSet.html">DocIdSet</a> implementation based on pfor-delta encoding.
<p>This implementation is inspired from LinkedIn&apos;s Kamikaze
(<a href="http://data.linkedin.com/opensource/kamikaze">http://data.linkedin.com/opensource/kamikaze</a>) and Daniel Lemire&apos;s JavaFastPFOR
(<a href="https://github.com/lemire/JavaFastPFOR">https://github.com/lemire/JavaFastPFOR</a>).</p>
<p>On the contrary to the original PFOR paper, exceptions are encoded with
FOR instead of Simple16.</p></p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.PForDeltaDocIdSet.Builder.html">PForDeltaDocIdSet.Builder</a></h4>
      <section><p>A builder for <a class="xref" href="Lucene.Net.Util.PForDeltaDocIdSet.html">PForDeltaDocIdSet</a>. </p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.PrintStreamInfoStream.html">PrintStreamInfoStream</a></h4>
      <section><p>LUCENENET specific stub to assist with migration to <a class="xref" href="Lucene.Net.Util.TextWriterInfoStream.html">TextWriterInfoStream</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.PriorityQueue-1.html">PriorityQueue&lt;T&gt;</a></h4>
      <section><p>A <a class="xref" href="Lucene.Net.Util.PriorityQueue-1.html">PriorityQueue&lt;T&gt;</a> maintains a partial ordering of its elements such that the
element with least priority can always be found in constant time. Put()&apos;s and Pop()&apos;s
require log(size) time.</p>
<p><p><strong>NOTE</strong>: this class will pre-allocate a full array of
length <code>maxSize+1</code> if instantiated via the
<a class="xref" href="Lucene.Net.Util.PriorityQueue-1.html#Lucene_Net_Util_PriorityQueue_1__ctor_System_Int32_System_Boolean_">PriorityQueue(Int32, Boolean)</a> constructor with
<code>prepopulate</code> set to <code>true</code>. That maximum
size can grow as we insert elements over the time.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.QueryBuilder.html">QueryBuilder</a></h4>
      <section><p>Creates queries from the <a class="xref" href="Lucene.Net.Util.QueryBuilder.html#Lucene_Net_Util_QueryBuilder_Analyzer">Analyzer</a> chain.
<p>
Example usage:</p>
<pre><code>    QueryBuilder builder = new QueryBuilder(analyzer);
    Query a = builder.CreateBooleanQuery(&quot;body&quot;, &quot;just a test&quot;);
    Query b = builder.CreatePhraseQuery(&quot;body&quot;, &quot;another test&quot;);
    Query c = builder.CreateMinShouldMatchQuery(&quot;body&quot;, &quot;another test&quot;, 0.5f);</code></pre>
<p><p>
This can also be used as a subclass for query parsers to make it easier
to interact with the analysis chain. Factory methods such as <a class="xref" href="Lucene.Net.Util.QueryBuilder.html#Lucene_Net_Util_QueryBuilder_NewTermQuery_Lucene_Net_Index_Term_">NewTermQuery(Term)</a>
are provided so that the generated queries can be customized.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.RamUsageEstimator.html">RamUsageEstimator</a></h4>
      <section><p>Estimates the size (memory representation) of .NET objects.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.RecyclingByteBlockAllocator.html">RecyclingByteBlockAllocator</a></h4>
      <section><p>A <a class="xref" href="Lucene.Net.Util.ByteBlockPool.Allocator.html">ByteBlockPool.Allocator</a> implementation that recycles unused byte
blocks in a buffer and reuses them in subsequent calls to
<a class="xref" href="Lucene.Net.Util.RecyclingByteBlockAllocator.html#Lucene_Net_Util_RecyclingByteBlockAllocator_GetByteBlock">GetByteBlock()</a>.
<p>
Note: this class is not thread-safe.
</p></p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.RecyclingInt32BlockAllocator.html">RecyclingInt32BlockAllocator</a></h4>
      <section><p>A <a class="xref" href="Lucene.Net.Util.Int32BlockPool.Allocator.html">Int32BlockPool.Allocator</a> implementation that recycles unused <span class="xref">System.Int32</span>
blocks in a buffer and reuses them in subsequent calls to
<a class="xref" href="Lucene.Net.Util.RecyclingInt32BlockAllocator.html#Lucene_Net_Util_RecyclingInt32BlockAllocator_GetInt32Block">GetInt32Block()</a>.
<p>
Note: this class is not thread-safe.
</p>
<p>
NOTE: This was RecyclingIntBlockAllocator in Lucene
</p></p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.RefCount-1.html">RefCount&lt;T&gt;</a></h4>
      <section><p>Manages reference counting for a given object. Extensions can override
<a class="xref" href="Lucene.Net.Util.RefCount-1.html#Lucene_Net_Util_RefCount_1_Release">Release()</a> to do custom logic when reference counting hits 0.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.RollingBuffer.html">RollingBuffer</a></h4>
      <section><p>LUCENENET specific class to allow referencing static members of
<a class="xref" href="Lucene.Net.Util.RollingBuffer-1.html">RollingBuffer&lt;T&gt;</a> without referencing its generic closing type.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.RollingBuffer-1.html">RollingBuffer&lt;T&gt;</a></h4>
      <section><p>Acts like forever growing <span class="xref">T[]</span>, but internally uses a
circular buffer to reuse instances of <typeparam name="T"></typeparam>.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.SentinelInt32Set.html">SentinelInt32Set</a></h4>
      <section><p>A native <span class="xref">System.Int32</span> hash-based set where one value is reserved to mean &quot;EMPTY&quot; internally. The space overhead is fairly low
as there is only one power-of-two sized <span class="xref">int[]</span> to hold the values.  The set is re-hashed when adding a value that
would make it &gt;= 75% full.  Consider extending and over-riding <a class="xref" href="Lucene.Net.Util.SentinelInt32Set.html#Lucene_Net_Util_SentinelInt32Set_Hash_System_Int32_">Hash(Int32)</a> if the values might be poor
hash keys; Lucene docids should be fine.
The internal fields are exposed publicly to enable more efficient use at the expense of better O-O principles.
<p>
To iterate over the integers held in this set, simply use code like this:</p>
<pre><code>SentinelIntSet set = ...
foreach (int v in set.keys) 
{
    if (v == set.EmptyVal)
        continue;
    //use v...
}</code></pre>
<p><p>
NOTE: This was SentinelIntSet in Lucene
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.ServiceNameAttribute.html">ServiceNameAttribute</a></h4>
      <section><p>LUCENENET specific abstract class for <span class="xref">System.Attribute</span>s that can
be used to override the default convention-based names of services. For example,
&quot;Lucene40Codec&quot; will by convention be named &quot;Lucene40&quot;. Using the <a class="xref" href="Lucene.Net.Codecs.CodecNameAttribute.html">CodecNameAttribute</a>,
the name can be overridden with a custom value.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.SetOnce-1.html">SetOnce&lt;T&gt;</a></h4>
      <section><p>A convenient class which offers a semi-immutable object wrapper
implementation which allows one to set the value of an object exactly once,
and retrieve it many times. If <a class="xref" href="Lucene.Net.Util.SetOnce-1.html#Lucene_Net_Util_SetOnce_1_Set__0_">Set(T)</a> is called more than once,
<a class="xref" href="Lucene.Net.Util.AlreadySetException.html">AlreadySetException</a> is thrown and the operation
will fail.
<p>
<div class="lucene-block lucene-experimental">This is a Lucene.NET EXPERIMENTAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.SloppyMath.html">SloppyMath</a></h4>
      <section><p>Math functions that trade off accuracy for speed. </p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.SmallSingle.html">SmallSingle</a></h4>
      <section><p>Floating point numbers smaller than 32 bits.
<p>
NOTE: This was SmallFloat in Lucene
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.Sorter.html">Sorter</a></h4>
      <section><p>Base class for sorting algorithms implementations.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.SPIClassIterator-1.html">SPIClassIterator&lt;S&gt;</a></h4>
      <section><p>Helper class for loading SPI classes from classpath (META-INF files).
This is a light impl of <code>java.util.ServiceLoader</code> but is guaranteed to
be bug-free regarding classpath order and does not instantiate or initialize
the classes found.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.StringHelper.html">StringHelper</a></h4>
      <section><p>Methods for manipulating strings.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.SystemConsole.html">SystemConsole</a></h4>
      <section><p>Mimics <span class="xref">System.Console</span>, but allows for swapping
the <span class="xref">System.IO.TextWriter</span> of 
<a class="xref" href="Lucene.Net.Util.SystemConsole.html#Lucene_Net_Util_SystemConsole_Out">Out</a> and <a class="xref" href="Lucene.Net.Util.SystemConsole.html#Lucene_Net_Util_SystemConsole_Error">Error</a>, or the <span class="xref">System.IO.TextReader</span> of <a class="xref" href="Lucene.Net.Util.SystemConsole.html#Lucene_Net_Util_SystemConsole_In">In</a>
with user-defined implementations.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.TextWriterInfoStream.html">TextWriterInfoStream</a></h4>
      <section><p><a class="xref" href="Lucene.Net.Util.InfoStream.html">InfoStream</a> implementation over a <span class="xref">System.IO.TextWriter</span>
such as <span class="xref">System.Console.Out</span>.
<p>
NOTE: This is analogous to PrintStreamInfoStream in Lucene.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.TimSorter.html">TimSorter</a></h4>
      <section><p><a class="xref" href="Lucene.Net.Util.Sorter.html">Sorter</a> implementation based on the
<a href="http://svn.python.org/projects/python/trunk/Objects/listsort.txt">TimSort</a>
algorithm.
<p>This implementation is especially good at sorting partially-sorted
arrays and sorts small arrays with binary sort.
<p><strong>NOTE</strong>:There are a few differences with the original implementation:
<ul><li><a name="maxTempSlots"></a>The extra amount of memory to perform merges is
        configurable. This allows small merges to be very fast while large merges
        will be performed in-place (slightly slower). You can make sure that the
        fast merge routine will always be used by having <code>maxTempSlots</code>
        equal to half of the length of the slice of data to sort.</li><li>Only the fast merge routine can gallop (the one that doesn&apos;t run
        in-place) and it only gallops on the longest slice.</li></ul>
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.ToStringUtils.html">ToStringUtils</a></h4>
      <section><p>Helper methods to ease implementing <span class="xref">System.Object.ToString()</span>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.UnicodeUtil.html">UnicodeUtil</a></h4>
      <section><p>Class to encode .NET&apos;s UTF16 <span class="xref">char[]</span> into UTF8 <span class="xref">byte[]</span>
without always allocating a new <span class="xref">byte[]</span> as
<span class="xref">System.Text.Encoding.GetBytes(System.String)</span> of <span class="xref">System.Text.Encoding.UTF8</span> does.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.VirtualMethod.html">VirtualMethod</a></h4>
      <section><p>A utility for keeping backwards compatibility on previously abstract methods
(or similar replacements).
<p>Before the replacement method can be made abstract, the old method must kept deprecated.
If somebody still overrides the deprecated method in a non-sealed class,
you must keep track, of this and maybe delegate to the old method in the subclass.
The cost of reflection is minimized by the following usage of this class:</p>
<p>Define <strong>static readonly</strong> fields in the base class (<code>BaseClass</code>),
where the old and new method are declared:</p></p>
<pre><code>internal static readonly VirtualMethod newMethod =
    new VirtualMethod(typeof(BaseClass), &quot;newName&quot;, parameters...);
internal static readonly VirtualMethod oldMethod =
    new VirtualMethod(typeof(BaseClass), &quot;oldName&quot;, parameters...);</code></pre>
<p>this enforces the singleton status of these objects, as the maintenance of the cache would be too costly else.
If you try to create a second instance of for the same method/<code>baseClass</code> combination, an exception is thrown.</p>
<p>To detect if e.g. the old method was overridden by a more far subclass on the inheritance path to the current
instance&apos;s class, use a <strong>non-static</strong> field:</p>
<pre><code> bool isDeprecatedMethodOverridden =
     oldMethod.GetImplementationDistance(this.GetType()) > newMethod.GetImplementationDistance(this.GetType());

<em>// alternatively (more readable):</em>
bool isDeprecatedMethodOverridden =
    VirtualMethod.CompareImplementationDistance(this.GetType(), oldMethod, newMethod) > 0</code></pre>
<p><a class="xref" href="Lucene.Net.Util.VirtualMethod.html#Lucene_Net_Util_VirtualMethod_GetImplementationDistance_System_Type_">GetImplementationDistance(Type)</a> returns the distance of the subclass that overrides this method.
The one with the larger distance should be used preferable.
this way also more complicated method rename scenarios can be handled
(think of 2.9 <a class="xref" href="Lucene.Net.Analysis.TokenStream.html">TokenStream</a> deprecations).</p>

<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.WAH8DocIdSet.html">WAH8DocIdSet</a></h4>
      <section><p><a class="xref" href="Lucene.Net.Search.DocIdSet.html">DocIdSet</a> implementation based on word-aligned hybrid encoding on
words of 8 bits.
<p>This implementation doesn&apos;t support random-access but has a fast
<a class="xref" href="Lucene.Net.Search.DocIdSetIterator.html">DocIdSetIterator</a> which can advance in logarithmic time thanks to
an index.</p>
<p>The compression scheme is simplistic and should work well with sparse and
very dense doc id sets while being only slightly larger than a
<a class="xref" href="Lucene.Net.Util.FixedBitSet.html">FixedBitSet</a> for incompressible sets (overhead&lt;2% in the worst
case) in spite of the index.</p>
<p><strong>Format</strong>: The format is byte-aligned. An 8-bits word is either clean,
meaning composed only of zeros or ones, or dirty, meaning that it contains
between 1 and 7 bits set. The idea is to encode sequences of clean words
using run-length encoding and to leave sequences of dirty words as-is.</p>
<table><thead><tr><th>TokenClean length+Dirty length+Dirty words</th><th></th></tr></thead><tbody><tr><td>1 byte0-n bytes0-n bytes0-n bytes</td><td></td></tr></tbody></table>
<ul><li><strong>Token</strong> encodes whether clean means full of zeros or ones in the
        first bit, the number of clean words minus 2 on the next 3 bits and the
        number of dirty words on the last 4 bits. The higher-order bit is a
        continuation bit, meaning that the number is incomplete and needs additional
        bytes to be read.</li><li><strong>Clean length+</strong>: If clean length has its higher-order bit set,
        you need to read a vint (<a class="xref" href="Lucene.Net.Store.DataInput.html#Lucene_Net_Store_DataInput_ReadVInt32">ReadVInt32()</a>), shift it by 3 bits on
        the left side and add it to the 3 bits which have been read in the token.</li><li><strong>Dirty length+</strong> works the same way as <strong>Clean length+</strong> but
        on 4 bits and for the length of dirty words.</li><li><strong>Dirty words</strong>are the dirty words, there are <strong>Dirty length</strong>
        of them.</li></ul>
<p>This format cannot encode sequences of less than 2 clean words and 0 dirty
word. The reason is that if you find a single clean word, you should rather
encode it as a dirty word. This takes the same space as starting a new
sequence (since you need one byte for the token) but will be lighter to
decode. There is however an exception for the first sequence. Since the first
sequence may start directly with a dirty word, the clean length is encoded
directly, without subtracting 2.</p>
<p>There is an additional restriction on the format: the sequence of dirty
words is not allowed to contain two consecutive clean words. This restriction
exists to make sure no space is wasted and to make sure iterators can read
the next doc ID by reading at most 2 dirty words.</p></p>
<div class="lucene-block lucene-experimental">This is a Lucene.NET EXPERIMENTAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.WAH8DocIdSet.Builder.html">WAH8DocIdSet.Builder</a></h4>
      <section><p>A builder for <a class="xref" href="Lucene.Net.Util.WAH8DocIdSet.html">WAH8DocIdSet</a>s. </p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.WAH8DocIdSet.WordBuilder.html">WAH8DocIdSet.WordBuilder</a></h4>
      <section><p>Word-based builder. </p>
</section>
    <h3 id="interfaces">Interfaces
  </h3>
      <h4><a class="xref" href="Lucene.Net.Util.IAccountable.html">IAccountable</a></h4>
      <section><p>An object whose RAM usage can be computed.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.IAttribute.html">IAttribute</a></h4>
      <section><p>Base interface for attributes.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.IAttributeReflector.html">IAttributeReflector</a></h4>
      <section><p>This interface is used to reflect contents of <a class="xref" href="Lucene.Net.Util.AttributeSource.html">AttributeSource</a> or <a class="xref" href="Lucene.Net.Util.Attribute.html">Attribute</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.IBits.html">IBits</a></h4>
      <section><p>Interface for Bitset-like structures.
<p>
<div class="lucene-block lucene-experimental">This is a Lucene.NET EXPERIMENTAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Util.IBytesRefIterator.html">IBytesRefIterator</a></h4>
      <section><p>A simple iterator interface for <a class="xref" href="Lucene.Net.Util.BytesRef.html">BytesRef</a> iteration.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.IMutableBits.html">IMutableBits</a></h4>
      <section><p>Extension of <a class="xref" href="Lucene.Net.Util.IBits.html">IBits</a> for live documents.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.IResourceManagerFactory.html">IResourceManagerFactory</a></h4>
      <section><p>LUCENENET specific interface used to inject instances of
<span class="xref">System.Resources.ResourceManager</span>. This
extension point can be used to override the default behavior
to, for example, retrieve resources from a persistent data store,
rather than getting them from resource files.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.IServiceListable.html">IServiceListable</a></h4>
      <section><p>LUCENENET specific contract that provides support for <a class="xref" href="Lucene.Net.Codecs.Codec.html#Lucene_Net_Codecs_Codec_AvailableCodecs">AvailableCodecs</a>, 
<a class="xref" href="Lucene.Net.Codecs.DocValuesFormat.html#Lucene_Net_Codecs_DocValuesFormat_AvailableDocValuesFormats">AvailableDocValuesFormats</a>, 
and <a class="xref" href="Lucene.Net.Codecs.PostingsFormat.html#Lucene_Net_Codecs_PostingsFormat_AvailablePostingsFormats">AvailablePostingsFormats</a>. Implement this
interface in addition to <a class="xref" href="Lucene.Net.Codecs.ICodecFactory.html">ICodecFactory</a>, <a class="xref" href="Lucene.Net.Codecs.IDocValuesFormatFactory.html">IDocValuesFormatFactory</a>,
or <a class="xref" href="Lucene.Net.Codecs.IPostingsFormatFactory.html">IPostingsFormatFactory</a> to provide optional support for the above
methods when providing a custom implementation. If this interface is not supported by
the corresponding factory, a <span class="xref">System.NotSupportedException</span> will be thrown from the above methods.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Util.RollingBuffer.IResettable.html">RollingBuffer.IResettable</a></h4>
      <section><p>Implement to reset an instance</p>
</section>
    <h3 id="enums">Enums
  </h3>
      <h4><a class="xref" href="Lucene.Net.Util.LuceneVersion.html">LuceneVersion</a></h4>
      <section><p>Use by certain classes to match version compatibility
across releases of Lucene.</p>
<p><strong>WARNING</strong>: When changing the version parameter
that you supply to components in Lucene, do not simply
change the version at search-time, but instead also adjust
your indexing code to match, and re-index.</p>
</section>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/apache/lucenenet/blob/docs/4.8.0-beta00009/src/Lucene.Net/Util/package.md/#L2" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            Copyright © 2020 Licensed to the Apache Software Foundation (ASF)
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="https://lucenenet.apache.org/docs/4.8.0-beta00009/styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="https://lucenenet.apache.org/docs/4.8.0-beta00009/styles/docfx.js"></script>
    <script type="text/javascript" src="https://lucenenet.apache.org/docs/4.8.0-beta00009/styles/main.js"></script>
  </body>
</html>
