{
  "Lucene.Net.Analysis.Icu.html": {
    "href": "Lucene.Net.Analysis.Icu.html",
    "title": "Namespace Lucene.Net.Analysis.Icu | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Namespace Lucene.Net.Analysis.Icu <!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. --> <!-- :Post-Release-Update-Version.LUCENE_XY: - several mentions in this file --> This module exposes functionality from ICU to Apache Lucene. ICU4J is a Java library that enhances Java's internationalization support by improving performance, keeping current with the Unicode Standard, and providing richer APIs. For an introduction to Lucene's analysis API, see the <xref:Lucene.Net.Analysis> package documentation. This module exposes the following functionality: Text Segmentation : Tokenizes text based on properties and rules defined in Unicode. Collation : Compare strings according to the conventions and standards of a particular language, region or country. Normalization : Converts text to a unique, equivalent form. Case Folding : Removes case distinctions with Unicode's Default Caseless Matching algorithm. Search Term Folding : Removes distinctions (such as accent marks) between similar characters for a loose or fuzzy search. Text Transformation : Transforms Unicode text in a context-sensitive fashion: e.g. mapping Traditional to Simplified Chinese Text Segmentation Text Segmentation (Tokenization) divides document and query text into index terms (typically words). Unicode provides special properties and rules so that this can be done in a manner that works well with most languages. Text Segmentation implements the word segmentation specified in Unicode Text Segmentation . Additionally the algorithm can be tailored based on writing system, for example text in the Thai script is automatically delegated to a dictionary-based segmentation algorithm. Use Cases As a more thorough replacement for StandardTokenizer that works well for most languages. Example Usages Tokenizing multilanguage text /** * This tokenizer will work well in general for most languages. */ Tokenizer tokenizer = new ICUTokenizer(reader); Collation ICUCollationKeyAnalyzer converts each token into its binary CollationKey using the provided Collator , allowing it to be stored as an index term. ICUCollationKeyAnalyzer depends on ICU4J to produce the CollationKey s. Use Cases Efficient sorting of terms in languages that use non-Unicode character orderings. (Lucene Sort using a Locale can be very slow.) Efficient range queries over fields that contain terms in languages that use non-Unicode character orderings. (Range queries using a Locale can be very slow.) Effective Locale-specific normalization (case differences, diacritics, etc.). (<xref:Lucene.Net.Analysis.Core.LowerCaseFilter> and <xref:Lucene.Net.Analysis.Miscellaneous.ASCIIFoldingFilter> provide these services in a generic way that doesn't take into account locale-specific needs.) Example Usages Farsi Range Queries Collator collator = Collator.getInstance(new ULocale(\"ar\")); ICUCollationKeyAnalyzer analyzer = new ICUCollationKeyAnalyzer(Version.LUCENE_48, collator); RAMDirectory ramDir = new RAMDirectory(); IndexWriter writer = new IndexWriter(ramDir, new IndexWriterConfig(Version.LUCENE_48, analyzer)); Document doc = new Document(); doc.add(new Field(\"content\", \"\\u0633\\u0627\\u0628\", Field.Store.YES, Field.Index.ANALYZED)); writer.addDocument(doc); writer.close(); IndexSearcher is = new IndexSearcher(ramDir, true); QueryParser aqp = new QueryParser(Version.LUCENE_48, \"content\", analyzer); aqp.setAnalyzeRangeTerms(true); // Unicode order would include U+0633 in [ U+062F - U+0698 ], but Farsi // orders the U+0698 character before the U+0633 character, so the single // indexed Term above should NOT be returned by a ConstantScoreRangeQuery // with a Farsi Collator (or an Arabic one for the case when Farsi is not // supported). ScoreDoc[] result = is.search(aqp.parse(\"[ \\u062F TO \\u0698 ]\"), null, 1000).scoreDocs; assertEquals(\"The index Term should not be included.\", 0, result.length); Danish Sorting Analyzer analyzer = new ICUCollationKeyAnalyzer(Version.LUCENE_48, Collator.getInstance(new ULocale(\"da\", \"dk\"))); RAMDirectory indexStore = new RAMDirectory(); IndexWriter writer = new IndexWriter(indexStore, new IndexWriterConfig(Version.LUCENE_48, analyzer)); String[] tracer = new String[] { \"A\", \"B\", \"C\", \"D\", \"E\" }; String[] data = new String[] { \"HAT\", \"HUT\", \"H\\u00C5T\", \"H\\u00D8T\", \"HOT\" }; String[] sortedTracerOrder = new String[] { \"A\", \"E\", \"B\", \"D\", \"C\" }; for (int i = 0 ; i < data.length=\"\" ;=\"\" ++i)=\"\" {=\"\" document=\"\" doc=\"new\" document();=\"\" doc.add(new=\"\" field(\"tracer\",=\"\" tracer[i],=\"\" field.store.yes,=\"\" field.index.no));=\"\" doc.add(new=\"\" field(\"contents\",=\"\" data[i],=\"\" field.store.no,=\"\" field.index.analyzed));=\"\" writer.adddocument(doc);=\"\" }=\"\" writer.close();=\"\" indexsearcher=\"\" searcher=\"new\" indexsearcher(indexstore,=\"\" true);=\"\" sort=\"\" sort=\"new\" sort();=\"\" sort.setsort(new=\"\" sortfield(\"contents\",=\"\" sortfield.string));=\"\" query=\"\" query=\"new\" matchalldocsquery();=\"\" scoredoc[]=\"\" result=\"searcher.search(query,\" null,=\"\" 1000,=\"\" sort).scoredocs;=\"\" for=\"\" (int=\"\" i=\"0\" ;=\"\" i=\"\">< result.length=\"\" ;=\"\" ++i)=\"\" {=\"\" document=\"\" doc=\"searcher.doc(result[i].doc);\" assertequals(sortedtracerorder[i],=\"\" doc.getvalues(\"tracer\")[0]);=\"\" }=\"\"> Turkish Case Normalization Collator collator = Collator.getInstance(new ULocale(\"tr\", \"TR\")); collator.setStrength(Collator.PRIMARY); Analyzer analyzer = new ICUCollationKeyAnalyzer(Version.LUCENE_48, collator); RAMDirectory ramDir = new RAMDirectory(); IndexWriter writer = new IndexWriter(ramDir, new IndexWriterConfig(Version.LUCENE_48, analyzer)); Document doc = new Document(); doc.add(new Field(\"contents\", \"DIGY\", Field.Store.NO, Field.Index.ANALYZED)); writer.addDocument(doc); writer.close(); IndexSearcher is = new IndexSearcher(ramDir, true); QueryParser parser = new QueryParser(Version.LUCENE_48, \"contents\", analyzer); Query query = parser.parse(\"d\\u0131gy\"); // U+0131: dotless i ScoreDoc[] result = is.search(query, null, 1000).scoreDocs; assertEquals(\"The index Term should be included.\", 1, result.length); Caveats and Comparisons WARNING: Make sure you use exactly the same Collator at index and query time -- CollationKey s are only comparable when produced by the same Collator . Since {@link java.text.RuleBasedCollator}s are not independently versioned, it is unsafe to search against stored CollationKey s unless the following are exactly the same (best practice is to store this information with the index and check that they remain the same at query time): JVM vendor JVM version, including patch version The language (and country and variant, if specified) of the Locale used when constructing the collator via {@link java.text.Collator#getInstance(java.util.Locale)}. The collation strength used - see {@link java.text.Collator#setStrength(int)} ICUCollationKeyAnalyzer uses ICU4J's Collator , which makes its version available, thus allowing collation to be versioned independently from the JVM. ICUCollationKeyAnalyzer is also significantly faster and generates significantly shorter keys than CollationKeyAnalyzer . See http://site.icu-project.org/charts/collation-icu4j-sun for key generation timing and key length comparisons between ICU4J and java.text.Collator over several languages. CollationKey s generated by java.text.Collator s are not compatible with those those generated by ICU Collators. Specifically, if you use CollationKeyAnalyzer to generate index terms, do not use ICUCollationKeyAnalyzer on the query side, or vice versa. Normalization ICUNormalizer2Filter normalizes term text to a Unicode Normalization Form , so that equivalent forms are standardized to a unique form. Use Cases Removing differences in width for Asian-language text. Standardizing complex text with non-spacing marks so that characters are ordered consistently. Example Usages Normalizing text to NFC /** * Normalizer2 objects are unmodifiable and immutable. */ Normalizer2 normalizer = Normalizer2.getInstance(null, \"nfc\", Normalizer2.Mode.COMPOSE); /** * This filter will normalize to NFC. */ TokenStream tokenstream = new ICUNormalizer2Filter(tokenizer, normalizer); Case Folding Default caseless matching, or case-folding is more than just conversion to lowercase. For example, it handles cases such as the Greek sigma, so that \"Μάϊος\" and \"ΜΆΪΟΣ\" will match correctly. Case-folding is still only an approximation of the language-specific rules governing case. If the specific language is known, consider using ICUCollationKeyFilter and indexing collation keys instead. This implementation performs the \"full\" case-folding specified in the Unicode standard, and this may change the length of the term. For example, the German ß is case-folded to the string 'ss'. Case folding is related to normalization, and as such is coupled with it in this integration. To perform case-folding, you use normalization with the form \"nfkc_cf\" (which is the default). Use Cases As a more thorough replacement for LowerCaseFilter that has good behavior for most languages. Example Usages Lowercasing text /** * This filter will case-fold and normalize to NFKC. */ TokenStream tokenstream = new ICUNormalizer2Filter(tokenizer); Search Term Folding Search term folding removes distinctions (such as accent marks) between similar characters. It is useful for a fuzzy or loose search. Search term folding implements many of the foldings specified in Character Foldings as a special normalization form. This folding applies NFKC, Case Folding, and many character foldings recursively. Use Cases As a more thorough replacement for ASCIIFoldingFilter and LowerCaseFilter that applies the same ideas to many more languages. Example Usages Removing accents /** * This filter will case-fold, remove accents and other distinctions, and * normalize to NFKC. */ TokenStream tokenstream = new ICUFoldingFilter(tokenizer); Text Transformation ICU provides text-transformation functionality via its Transliteration API. This allows you to transform text in a variety of ways, taking context into account. For more information, see the User's Guide and Rule Tutorial . Use Cases Convert Traditional to Simplified Transliterate between different writing systems: e.g. Romanization Example Usages Convert Traditional to Simplified /** * This filter will map Traditional Chinese to Simplified Chinese */ TokenStream tokenstream = new ICUTransformFilter(tokenizer, Transliterator.getInstance(\"Traditional-Simplified\")); Transliterate Serbian Cyrillic to Serbian Latin /** * This filter will map Serbian Cyrillic to Serbian Latin according to BGN rules */ TokenStream tokenstream = new ICUTransformFilter(tokenizer, Transliterator.getInstance(\"Serbian-Latin/BGN\")); Backwards Compatibility This module exists to provide up-to-date Unicode functionality that supports the most recent version of Unicode (currently 6.3). However, some users who wish for stronger backwards compatibility can restrict ICUNormalizer2Filter to operate on only a specific Unicode Version by using a {@link com.ibm.icu.text.FilteredNormalizer2}. Example Usages Restricting normalization to Unicode 5.0 /** * This filter will do NFC normalization, but will ignore any characters that * did not exist as of Unicode 5.0. Because of the normalization stability policy * of Unicode, this is an easy way to force normalization to a specific version. */ Normalizer2 normalizer = Normalizer2.getInstance(null, \"nfc\", Normalizer2.Mode.COMPOSE); UnicodeSet set = new UnicodeSet(\"[:age=5.0:]\"); // see FilteredNormalizer2 docs, the set should be frozen or performance will suffer set.freeze(); FilteredNormalizer2 unicode50 = new FilteredNormalizer2(normalizer, set); TokenStream tokenstream = new ICUNormalizer2Filter(tokenizer, unicode50); Classes ICUFoldingFilter A Lucene.Net.Analysis.TokenFilter that applies search term folding to Unicode text, applying foldings from UTR#30 Character Foldings. ICUFoldingFilterFactory Factory for ICUFoldingFilter . ICUNormalizer2CharFilter Normalize token text with ICU's ICU4N.Text.Normalizer2 . ICUNormalizer2CharFilterFactory Factory for ICUNormalizer2CharFilter . ICUNormalizer2Filter Normalize token text with ICU's ICU4N.Text.Normalizer2 . ICUNormalizer2FilterFactory Factory for ICUNormalizer2Filter . ICUTransformFilter A Lucene.Net.Analysis.TokenFilter that transforms text with ICU. ICUTransformFilterFactory Factory for ICUTransformFilter ."
  },
  "Lucene.Net.Analysis.Icu.ICUFoldingFilter.html": {
    "href": "Lucene.Net.Analysis.Icu.ICUFoldingFilter.html",
    "title": "Class ICUFoldingFilter | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Class ICUFoldingFilter A Lucene.Net.Analysis.TokenFilter that applies search term folding to Unicode text, applying foldings from UTR#30 Character Foldings. Inheritance System.Object Lucene.Net.Util.AttributeSource Lucene.Net.Analysis.TokenStream Lucene.Net.Analysis.TokenFilter ICUNormalizer2Filter ICUFoldingFilter Implements System.IDisposable Inherited Members ICUNormalizer2Filter.IncrementToken() Lucene.Net.Analysis.TokenFilter.m_input Lucene.Net.Analysis.TokenFilter.End() TokenFilter.Dispose(Boolean) Lucene.Net.Analysis.TokenFilter.Reset() Lucene.Net.Analysis.TokenStream.Dispose() Lucene.Net.Util.AttributeSource.GetAttributeFactory() Lucene.Net.Util.AttributeSource.GetAttributeClassesEnumerator() Lucene.Net.Util.AttributeSource.GetAttributeImplsEnumerator() Lucene.Net.Util.AttributeSource.AddAttributeImpl(Lucene.Net.Util.Attribute) Lucene.Net.Util.AttributeSource.AddAttribute<T>() Lucene.Net.Util.AttributeSource.HasAttributes Lucene.Net.Util.AttributeSource.HasAttribute<T>() Lucene.Net.Util.AttributeSource.GetAttribute<T>() Lucene.Net.Util.AttributeSource.ClearAttributes() Lucene.Net.Util.AttributeSource.CaptureState() Lucene.Net.Util.AttributeSource.RestoreState(Lucene.Net.Util.AttributeSource.State) Lucene.Net.Util.AttributeSource.GetHashCode() AttributeSource.Equals(Object) AttributeSource.ReflectAsString(Boolean) Lucene.Net.Util.AttributeSource.ReflectWith(Lucene.Net.Util.IAttributeReflector) Lucene.Net.Util.AttributeSource.CloneAttributes() Lucene.Net.Util.AttributeSource.CopyTo(Lucene.Net.Util.AttributeSource) Lucene.Net.Util.AttributeSource.ToString() System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Lucene.Net.Analysis.Icu Assembly : Lucene.Net.ICU.dll Syntax public sealed class ICUFoldingFilter : ICUNormalizer2Filter, IDisposable Remarks This filter applies the following foldings from the report to unicode text: Accent removal Case folding Canonical duplicates folding Dashes folding Diacritic removal (including stroke, hook, descender) Greek letterforms folding Han Radical folding Hebrew Alternates folding Jamo folding Letterforms folding Math symbol folding Multigraph Expansions: All Native digit folding No-break folding Overline folding Positional forms folding Small forms folding Space folding Spacing Accents folding Subscript folding Superscript folding Suzhou Numeral folding Symbol folding Underline folding Vertical forms folding Width folding Additionally, Default Ignorables are removed, and text is normalized to NFKC. All foldings, case folding, and normalization mappings are applied recursively to ensure a fully folded and normalized result. Constructors | Improve this Doc View Source ICUFoldingFilter(TokenStream) Create a new ICUFoldingFilter on the specified input Declaration public ICUFoldingFilter(TokenStream input) Parameters Type Name Description Lucene.Net.Analysis.TokenStream input Implements System.IDisposable"
  },
  "Lucene.Net.Analysis.Icu.ICUFoldingFilterFactory.html": {
    "href": "Lucene.Net.Analysis.Icu.ICUFoldingFilterFactory.html",
    "title": "Class ICUFoldingFilterFactory | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Class ICUFoldingFilterFactory Factory for ICUFoldingFilter . Inheritance System.Object Lucene.Net.Analysis.Util.AbstractAnalysisFactory Lucene.Net.Analysis.Util.TokenFilterFactory ICUFoldingFilterFactory Implements Lucene.Net.Analysis.Util.IMultiTermAwareComponent Inherited Members Lucene.Net.Analysis.Util.TokenFilterFactory.ForName(System.String, System.Collections.Generic.IDictionary<System.String, System.String>) Lucene.Net.Analysis.Util.TokenFilterFactory.LookupClass(System.String) Lucene.Net.Analysis.Util.TokenFilterFactory.AvailableTokenFilters Lucene.Net.Analysis.Util.TokenFilterFactory.ReloadTokenFilters() Lucene.Net.Analysis.Util.AbstractAnalysisFactory.LUCENE_MATCH_VERSION_PARAM Lucene.Net.Analysis.Util.AbstractAnalysisFactory.m_luceneMatchVersion Lucene.Net.Analysis.Util.AbstractAnalysisFactory.OriginalArgs Lucene.Net.Analysis.Util.AbstractAnalysisFactory.AssureMatchVersion() Lucene.Net.Analysis.Util.AbstractAnalysisFactory.LuceneMatchVersion Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Require(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Require(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Require(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Get(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Get(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Get(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Get(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>, System.String, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.RequireInt32(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetInt32(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Int32) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.RequireBoolean(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetBoolean(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.RequireSingle(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetSingle(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Single) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.RequireChar(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetChar(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Char) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetSet(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetPattern(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetCulture(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Globalization.CultureInfo) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetWordSet(Lucene.Net.Analysis.Util.IResourceLoader, System.String, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetLines(Lucene.Net.Analysis.Util.IResourceLoader, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetSnowballWordSet(Lucene.Net.Analysis.Util.IResourceLoader, System.String, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.SplitFileNames(System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetClassArg() Lucene.Net.Analysis.Util.AbstractAnalysisFactory.IsExplicitLuceneMatchVersion System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Lucene.Net.Analysis.Icu Assembly : Lucene.Net.ICU.dll Syntax public class ICUFoldingFilterFactory : TokenFilterFactory, IMultiTermAwareComponent Remarks <fieldType name=\"text_folded\" class=\"solr.TextField\" positionIncrementGap=\"100\"> <analyzer> <tokenizer class=\"solr.WhitespaceTokenizerFactory\"/> <filter class=\"solr.ICUFoldingFilterFactory\"/> </analyzer> </fieldType> Constructors | Improve this Doc View Source ICUFoldingFilterFactory(IDictionary<String, String>) Creates a new ICUFoldingFilterFactory . Declaration public ICUFoldingFilterFactory(IDictionary<string, string> args) Parameters Type Name Description System.Collections.Generic.IDictionary < System.String , System.String > args Methods | Improve this Doc View Source Create(TokenStream) Declaration public override TokenStream Create(TokenStream input) Parameters Type Name Description Lucene.Net.Analysis.TokenStream input Returns Type Description Lucene.Net.Analysis.TokenStream Overrides Lucene.Net.Analysis.Util.TokenFilterFactory.Create(Lucene.Net.Analysis.TokenStream) | Improve this Doc View Source GetMultiTermComponent() Declaration public virtual AbstractAnalysisFactory GetMultiTermComponent() Returns Type Description Lucene.Net.Analysis.Util.AbstractAnalysisFactory Implements Lucene.Net.Analysis.Util.IMultiTermAwareComponent"
  },
  "Lucene.Net.Analysis.Icu.ICUNormalizer2CharFilter.html": {
    "href": "Lucene.Net.Analysis.Icu.ICUNormalizer2CharFilter.html",
    "title": "Class ICUNormalizer2CharFilter | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Class ICUNormalizer2CharFilter Normalize token text with ICU's ICU4N.Text.Normalizer2 . Inheritance System.Object System.MarshalByRefObject System.IO.TextReader Lucene.Net.Analysis.CharFilter Lucene.Net.Analysis.CharFilters.BaseCharFilter ICUNormalizer2CharFilter Implements System.IDisposable Inherited Members Lucene.Net.Analysis.CharFilters.BaseCharFilter.Correct(System.Int32) Lucene.Net.Analysis.CharFilters.BaseCharFilter.LastCumulativeDiff Lucene.Net.Analysis.CharFilters.BaseCharFilter.AddOffCorrectMap(System.Int32, System.Int32) Lucene.Net.Analysis.CharFilter.m_input CharFilter.Dispose(Boolean) CharFilter.CorrectOffset(Int32) Lucene.Net.Analysis.CharFilter.Read() CharFilter.Skip(Int32) Lucene.Net.Analysis.CharFilter.Reset() Lucene.Net.Analysis.CharFilter.IsReady Lucene.Net.Analysis.CharFilter.IsMarkSupported CharFilter.Mark(Int32) System.IO.TextReader.Null System.IO.TextReader.Close() System.IO.TextReader.Dispose() System.IO.TextReader.Peek() System.IO.TextReader.ReadAsync(System.Char[], System.Int32, System.Int32) System.IO.TextReader.ReadBlock(System.Char[], System.Int32, System.Int32) System.IO.TextReader.ReadBlockAsync(System.Char[], System.Int32, System.Int32) System.IO.TextReader.ReadLine() System.IO.TextReader.ReadLineAsync() System.IO.TextReader.ReadToEnd() System.IO.TextReader.ReadToEndAsync() System.IO.TextReader.Synchronized(System.IO.TextReader) System.MarshalByRefObject.GetLifetimeService() System.MarshalByRefObject.InitializeLifetimeService() System.MarshalByRefObject.MemberwiseClone(System.Boolean) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Lucene.Net.Analysis.Icu Assembly : Lucene.Net.ICU.dll Syntax public sealed class ICUNormalizer2CharFilter : BaseCharFilter, IDisposable Constructors | Improve this Doc View Source ICUNormalizer2CharFilter(TextReader) Create a new ICUNormalizer2CharFilter that combines NFKC normalization, Case Folding, and removes Default Ignorables (NFKC_Casefold). Declaration public ICUNormalizer2CharFilter(TextReader input) Parameters Type Name Description System.IO.TextReader input | Improve this Doc View Source ICUNormalizer2CharFilter(TextReader, Normalizer2) Create a new ICUNormalizer2CharFilter with the specified ICU4N.Text.Normalizer2 . Declaration public ICUNormalizer2CharFilter(TextReader input, Normalizer2 normalizer) Parameters Type Name Description System.IO.TextReader input Input text. ICU4N.Text.Normalizer2 normalizer Normalizer to use. Methods | Improve this Doc View Source Read(Char[], Int32, Int32) Declaration public override int Read(char[] cbuf, int off, int len) Parameters Type Name Description System.Char [] cbuf System.Int32 off System.Int32 len Returns Type Description System.Int32 Overrides CharFilter.Read(Char[], Int32, Int32) Implements System.IDisposable"
  },
  "Lucene.Net.Analysis.Icu.ICUNormalizer2CharFilterFactory.html": {
    "href": "Lucene.Net.Analysis.Icu.ICUNormalizer2CharFilterFactory.html",
    "title": "Class ICUNormalizer2CharFilterFactory | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Class ICUNormalizer2CharFilterFactory Factory for ICUNormalizer2CharFilter . Inheritance System.Object Lucene.Net.Analysis.Util.AbstractAnalysisFactory Lucene.Net.Analysis.Util.CharFilterFactory ICUNormalizer2CharFilterFactory Implements Lucene.Net.Analysis.Util.IMultiTermAwareComponent Inherited Members Lucene.Net.Analysis.Util.CharFilterFactory.ForName(System.String, System.Collections.Generic.IDictionary<System.String, System.String>) Lucene.Net.Analysis.Util.CharFilterFactory.LookupClass(System.String) Lucene.Net.Analysis.Util.CharFilterFactory.AvailableCharFilters Lucene.Net.Analysis.Util.CharFilterFactory.ReloadCharFilters() Lucene.Net.Analysis.Util.AbstractAnalysisFactory.LUCENE_MATCH_VERSION_PARAM Lucene.Net.Analysis.Util.AbstractAnalysisFactory.m_luceneMatchVersion Lucene.Net.Analysis.Util.AbstractAnalysisFactory.OriginalArgs Lucene.Net.Analysis.Util.AbstractAnalysisFactory.AssureMatchVersion() Lucene.Net.Analysis.Util.AbstractAnalysisFactory.LuceneMatchVersion Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Require(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Require(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Require(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Get(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Get(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Get(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Get(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>, System.String, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.RequireInt32(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetInt32(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Int32) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.RequireBoolean(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetBoolean(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.RequireSingle(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetSingle(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Single) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.RequireChar(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetChar(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Char) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetSet(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetPattern(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetCulture(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Globalization.CultureInfo) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetWordSet(Lucene.Net.Analysis.Util.IResourceLoader, System.String, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetLines(Lucene.Net.Analysis.Util.IResourceLoader, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetSnowballWordSet(Lucene.Net.Analysis.Util.IResourceLoader, System.String, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.SplitFileNames(System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetClassArg() Lucene.Net.Analysis.Util.AbstractAnalysisFactory.IsExplicitLuceneMatchVersion System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Lucene.Net.Analysis.Icu Assembly : Lucene.Net.ICU.dll Syntax public class ICUNormalizer2CharFilterFactory : CharFilterFactory, IMultiTermAwareComponent Remarks Supports the following attributes: name A Unicode Normalization Form , one of 'nfc','nfkc', 'nfkc_cf'. Default is nfkc_cf. mode Either 'compose' or 'decompose'. Default is compose. Use \"decompose\" with nfc or nfkc, to get nfd or nfkd, respectively. filter A ICU4N.Text.UnicodeSet pattern. Codepoints outside the set are always left unchanged. Default is [] (the null set, no filtering). Constructors | Improve this Doc View Source ICUNormalizer2CharFilterFactory(IDictionary<String, String>) Creates a new ICUNormalizer2CharFilterFactory . Declaration public ICUNormalizer2CharFilterFactory(IDictionary<string, string> args) Parameters Type Name Description System.Collections.Generic.IDictionary < System.String , System.String > args Methods | Improve this Doc View Source Create(TextReader) Declaration public override TextReader Create(TextReader input) Parameters Type Name Description System.IO.TextReader input Returns Type Description System.IO.TextReader Overrides Lucene.Net.Analysis.Util.CharFilterFactory.Create(System.IO.TextReader) | Improve this Doc View Source GetMultiTermComponent() Declaration public virtual AbstractAnalysisFactory GetMultiTermComponent() Returns Type Description Lucene.Net.Analysis.Util.AbstractAnalysisFactory Implements Lucene.Net.Analysis.Util.IMultiTermAwareComponent See Also ICUNormalizer2CharFilter ICU4N.Text.Normalizer2 ICU4N.Text.FilteredNormalizer2"
  },
  "Lucene.Net.Analysis.Icu.ICUNormalizer2Filter.html": {
    "href": "Lucene.Net.Analysis.Icu.ICUNormalizer2Filter.html",
    "title": "Class ICUNormalizer2Filter | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Class ICUNormalizer2Filter Normalize token text with ICU's ICU4N.Text.Normalizer2 . Inheritance System.Object Lucene.Net.Util.AttributeSource Lucene.Net.Analysis.TokenStream Lucene.Net.Analysis.TokenFilter ICUNormalizer2Filter ICUFoldingFilter Implements System.IDisposable Inherited Members Lucene.Net.Analysis.TokenFilter.m_input Lucene.Net.Analysis.TokenFilter.End() TokenFilter.Dispose(Boolean) Lucene.Net.Analysis.TokenFilter.Reset() Lucene.Net.Analysis.TokenStream.Dispose() Lucene.Net.Util.AttributeSource.GetAttributeFactory() Lucene.Net.Util.AttributeSource.GetAttributeClassesEnumerator() Lucene.Net.Util.AttributeSource.GetAttributeImplsEnumerator() Lucene.Net.Util.AttributeSource.AddAttributeImpl(Lucene.Net.Util.Attribute) Lucene.Net.Util.AttributeSource.AddAttribute<T>() Lucene.Net.Util.AttributeSource.HasAttributes Lucene.Net.Util.AttributeSource.HasAttribute<T>() Lucene.Net.Util.AttributeSource.GetAttribute<T>() Lucene.Net.Util.AttributeSource.ClearAttributes() Lucene.Net.Util.AttributeSource.CaptureState() Lucene.Net.Util.AttributeSource.RestoreState(Lucene.Net.Util.AttributeSource.State) Lucene.Net.Util.AttributeSource.GetHashCode() AttributeSource.Equals(Object) AttributeSource.ReflectAsString(Boolean) Lucene.Net.Util.AttributeSource.ReflectWith(Lucene.Net.Util.IAttributeReflector) Lucene.Net.Util.AttributeSource.CloneAttributes() Lucene.Net.Util.AttributeSource.CopyTo(Lucene.Net.Util.AttributeSource) Lucene.Net.Util.AttributeSource.ToString() System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Lucene.Net.Analysis.Icu Assembly : Lucene.Net.ICU.dll Syntax public class ICUNormalizer2Filter : TokenFilter, IDisposable Remarks With this filter, you can normalize text in the following ways: NFKC Normalization, Case Folding, and removing Ignorables (the default) Using a standard Normalization mode (NFC, NFD, NFKC, NFKD) Based on rules from a custom normalization mapping. If you use the defaults, this filter is a simple way to standardize Unicode text in a language-independent way for search: The case folding that it does can be seen as a replacement for LowerCaseFilter: For example, it handles cases such as the Greek sigma, so that \"Μάϊος\" and \"ΜΆΪΟΣ\" will match correctly. The normalization will standardizes different forms of the same character in Unicode. For example, CJK full-width numbers will be standardized to their ASCII forms. Ignorables such as Zero-Width Joiner and Variation Selectors are removed. These are typically modifier characters that affect display. Constructors | Improve this Doc View Source ICUNormalizer2Filter(TokenStream) Create a new ICUNormalizer2Filter that combines NFKC normalization, Case Folding, and removes Default Ignorables (NFKC_Casefold) Declaration public ICUNormalizer2Filter(TokenStream input) Parameters Type Name Description Lucene.Net.Analysis.TokenStream input | Improve this Doc View Source ICUNormalizer2Filter(TokenStream, Normalizer2) Create a new ICUNormalizer2Filter with the specified ICU4N.Text.Normalizer2 Declaration public ICUNormalizer2Filter(TokenStream input, Normalizer2 normalizer) Parameters Type Name Description Lucene.Net.Analysis.TokenStream input stream ICU4N.Text.Normalizer2 normalizer normalizer to use Methods | Improve this Doc View Source IncrementToken() Declaration public override sealed bool IncrementToken() Returns Type Description System.Boolean Overrides Lucene.Net.Analysis.TokenStream.IncrementToken() Implements System.IDisposable See Also ICU4N.Text.Normalizer2 ICU4N.Text.FilteredNormalizer2"
  },
  "Lucene.Net.Analysis.Icu.ICUNormalizer2FilterFactory.html": {
    "href": "Lucene.Net.Analysis.Icu.ICUNormalizer2FilterFactory.html",
    "title": "Class ICUNormalizer2FilterFactory | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Class ICUNormalizer2FilterFactory Factory for ICUNormalizer2Filter . Inheritance System.Object Lucene.Net.Analysis.Util.AbstractAnalysisFactory Lucene.Net.Analysis.Util.TokenFilterFactory ICUNormalizer2FilterFactory Implements Lucene.Net.Analysis.Util.IMultiTermAwareComponent Inherited Members Lucene.Net.Analysis.Util.TokenFilterFactory.ForName(System.String, System.Collections.Generic.IDictionary<System.String, System.String>) Lucene.Net.Analysis.Util.TokenFilterFactory.LookupClass(System.String) Lucene.Net.Analysis.Util.TokenFilterFactory.AvailableTokenFilters Lucene.Net.Analysis.Util.TokenFilterFactory.ReloadTokenFilters() Lucene.Net.Analysis.Util.AbstractAnalysisFactory.LUCENE_MATCH_VERSION_PARAM Lucene.Net.Analysis.Util.AbstractAnalysisFactory.m_luceneMatchVersion Lucene.Net.Analysis.Util.AbstractAnalysisFactory.OriginalArgs Lucene.Net.Analysis.Util.AbstractAnalysisFactory.AssureMatchVersion() Lucene.Net.Analysis.Util.AbstractAnalysisFactory.LuceneMatchVersion Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Require(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Require(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Require(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Get(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Get(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Get(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Get(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>, System.String, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.RequireInt32(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetInt32(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Int32) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.RequireBoolean(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetBoolean(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.RequireSingle(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetSingle(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Single) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.RequireChar(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetChar(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Char) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetSet(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetPattern(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetCulture(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Globalization.CultureInfo) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetWordSet(Lucene.Net.Analysis.Util.IResourceLoader, System.String, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetLines(Lucene.Net.Analysis.Util.IResourceLoader, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetSnowballWordSet(Lucene.Net.Analysis.Util.IResourceLoader, System.String, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.SplitFileNames(System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetClassArg() Lucene.Net.Analysis.Util.AbstractAnalysisFactory.IsExplicitLuceneMatchVersion System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Lucene.Net.Analysis.Icu Assembly : Lucene.Net.ICU.dll Syntax public class ICUNormalizer2FilterFactory : TokenFilterFactory, IMultiTermAwareComponent Remarks Supports the following attributes: name A Unicode Normalization Form , one of 'nfc','nfkc', 'nfkc_cf'. Default is nfkc_cf. mode Either 'compose' or 'decompose'. Default is compose. Use \"decompose\" with nfc or nfkc, to get nfd or nfkd, respectively. filter A ICU4N.Text.UnicodeSet pattern. Codepoints outside the set are always left unchanged. Default is [] (the null set, no filtering). Constructors | Improve this Doc View Source ICUNormalizer2FilterFactory(IDictionary<String, String>) Creates a new ICUNormalizer2FilterFactory . Declaration public ICUNormalizer2FilterFactory(IDictionary<string, string> args) Parameters Type Name Description System.Collections.Generic.IDictionary < System.String , System.String > args Methods | Improve this Doc View Source Create(TokenStream) Declaration public override TokenStream Create(TokenStream input) Parameters Type Name Description Lucene.Net.Analysis.TokenStream input Returns Type Description Lucene.Net.Analysis.TokenStream Overrides Lucene.Net.Analysis.Util.TokenFilterFactory.Create(Lucene.Net.Analysis.TokenStream) | Improve this Doc View Source GetMultiTermComponent() Declaration public virtual AbstractAnalysisFactory GetMultiTermComponent() Returns Type Description Lucene.Net.Analysis.Util.AbstractAnalysisFactory Implements Lucene.Net.Analysis.Util.IMultiTermAwareComponent See Also ICUNormalizer2Filter ICU4N.Text.Normalizer2 ICU4N.Text.FilteredNormalizer2"
  },
  "Lucene.Net.Analysis.Icu.ICUTransformFilter.html": {
    "href": "Lucene.Net.Analysis.Icu.ICUTransformFilter.html",
    "title": "Class ICUTransformFilter | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Class ICUTransformFilter A Lucene.Net.Analysis.TokenFilter that transforms text with ICU. Inheritance System.Object Lucene.Net.Util.AttributeSource Lucene.Net.Analysis.TokenStream Lucene.Net.Analysis.TokenFilter ICUTransformFilter Implements System.IDisposable Inherited Members Lucene.Net.Analysis.TokenFilter.m_input Lucene.Net.Analysis.TokenFilter.End() TokenFilter.Dispose(Boolean) Lucene.Net.Analysis.TokenFilter.Reset() Lucene.Net.Analysis.TokenStream.Dispose() Lucene.Net.Util.AttributeSource.GetAttributeFactory() Lucene.Net.Util.AttributeSource.GetAttributeClassesEnumerator() Lucene.Net.Util.AttributeSource.GetAttributeImplsEnumerator() Lucene.Net.Util.AttributeSource.AddAttributeImpl(Lucene.Net.Util.Attribute) Lucene.Net.Util.AttributeSource.AddAttribute<T>() Lucene.Net.Util.AttributeSource.HasAttributes Lucene.Net.Util.AttributeSource.HasAttribute<T>() Lucene.Net.Util.AttributeSource.GetAttribute<T>() Lucene.Net.Util.AttributeSource.ClearAttributes() Lucene.Net.Util.AttributeSource.CaptureState() Lucene.Net.Util.AttributeSource.RestoreState(Lucene.Net.Util.AttributeSource.State) Lucene.Net.Util.AttributeSource.GetHashCode() AttributeSource.Equals(Object) AttributeSource.ReflectAsString(Boolean) Lucene.Net.Util.AttributeSource.ReflectWith(Lucene.Net.Util.IAttributeReflector) Lucene.Net.Util.AttributeSource.CloneAttributes() Lucene.Net.Util.AttributeSource.CopyTo(Lucene.Net.Util.AttributeSource) Lucene.Net.Util.AttributeSource.ToString() System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Lucene.Net.Analysis.Icu Assembly : Lucene.Net.ICU.dll Syntax public sealed class ICUTransformFilter : TokenFilter, IDisposable Remarks ICU provides text-transformation functionality via its Transliteration API. Although script conversion is its most common use, a Transliterator can actually perform a more general class of tasks. In fact, Transliterator defines a very general API which specifies only that a segment of the input text is replaced by new text. The particulars of this conversion are determined entirely by subclasses of Transliterator. Some useful transformations for search are built-in: Conversion from Traditional to Simplified Chinese characters Conversion from Hiragana to Katakana Conversion from Fullwidth to Halfwidth forms. Script conversions, for example Serbian Cyrillic to Latin Example usage: stream = new ICUTransformFilter(stream, Transliterator.GetInstance(\"Traditional-Simplified\")); For more details, see the ICU User Guide . Constructors | Improve this Doc View Source ICUTransformFilter(TokenStream, Transliterator) Create a new ICUTransformFilter that transforms text on the given stream. Declaration public ICUTransformFilter(TokenStream input, Transliterator transform) Parameters Type Name Description Lucene.Net.Analysis.TokenStream input Lucene.Net.Analysis.TokenStream to filter. ICU4N.Text.Transliterator transform Transliterator to transform the text. Methods | Improve this Doc View Source IncrementToken() Declaration public override bool IncrementToken() Returns Type Description System.Boolean Overrides Lucene.Net.Analysis.TokenStream.IncrementToken() Implements System.IDisposable"
  },
  "Lucene.Net.Analysis.Icu.ICUTransformFilterFactory.html": {
    "href": "Lucene.Net.Analysis.Icu.ICUTransformFilterFactory.html",
    "title": "Class ICUTransformFilterFactory | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Class ICUTransformFilterFactory Factory for ICUTransformFilter . Inheritance System.Object Lucene.Net.Analysis.Util.AbstractAnalysisFactory Lucene.Net.Analysis.Util.TokenFilterFactory ICUTransformFilterFactory Implements Lucene.Net.Analysis.Util.IMultiTermAwareComponent Inherited Members Lucene.Net.Analysis.Util.TokenFilterFactory.ForName(System.String, System.Collections.Generic.IDictionary<System.String, System.String>) Lucene.Net.Analysis.Util.TokenFilterFactory.LookupClass(System.String) Lucene.Net.Analysis.Util.TokenFilterFactory.AvailableTokenFilters Lucene.Net.Analysis.Util.TokenFilterFactory.ReloadTokenFilters() Lucene.Net.Analysis.Util.AbstractAnalysisFactory.LUCENE_MATCH_VERSION_PARAM Lucene.Net.Analysis.Util.AbstractAnalysisFactory.m_luceneMatchVersion Lucene.Net.Analysis.Util.AbstractAnalysisFactory.OriginalArgs Lucene.Net.Analysis.Util.AbstractAnalysisFactory.AssureMatchVersion() Lucene.Net.Analysis.Util.AbstractAnalysisFactory.LuceneMatchVersion Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Require(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Require(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Require(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Get(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Get(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Get(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Get(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>, System.String, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.RequireInt32(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetInt32(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Int32) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.RequireBoolean(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetBoolean(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.RequireSingle(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetSingle(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Single) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.RequireChar(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetChar(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Char) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetSet(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetPattern(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetCulture(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Globalization.CultureInfo) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetWordSet(Lucene.Net.Analysis.Util.IResourceLoader, System.String, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetLines(Lucene.Net.Analysis.Util.IResourceLoader, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetSnowballWordSet(Lucene.Net.Analysis.Util.IResourceLoader, System.String, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.SplitFileNames(System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetClassArg() Lucene.Net.Analysis.Util.AbstractAnalysisFactory.IsExplicitLuceneMatchVersion System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Lucene.Net.Analysis.Icu Assembly : Lucene.Net.ICU.dll Syntax public class ICUTransformFilterFactory : TokenFilterFactory, IMultiTermAwareComponent Remarks Supports the following attributes: A Transliterator ID, one from ICU4N.Text.Transliterator.GetAvailableIDs Either 'forward' or 'reverse'. Default is forward. Constructors | Improve this Doc View Source ICUTransformFilterFactory(IDictionary<String, String>) Creates a new ICUTransformFilterFactory . Declaration public ICUTransformFilterFactory(IDictionary<string, string> args) Parameters Type Name Description System.Collections.Generic.IDictionary < System.String , System.String > args Methods | Improve this Doc View Source Create(TokenStream) Declaration public override TokenStream Create(TokenStream input) Parameters Type Name Description Lucene.Net.Analysis.TokenStream input Returns Type Description Lucene.Net.Analysis.TokenStream Overrides Lucene.Net.Analysis.Util.TokenFilterFactory.Create(Lucene.Net.Analysis.TokenStream) | Improve this Doc View Source GetMultiTermComponent() Declaration public virtual AbstractAnalysisFactory GetMultiTermComponent() Returns Type Description Lucene.Net.Analysis.Util.AbstractAnalysisFactory Implements Lucene.Net.Analysis.Util.IMultiTermAwareComponent See Also ICU4N.Text.Transliterator"
  },
  "Lucene.Net.Analysis.Icu.Segmentation.DefaultICUTokenizerConfig.html": {
    "href": "Lucene.Net.Analysis.Icu.Segmentation.DefaultICUTokenizerConfig.html",
    "title": "Class DefaultICUTokenizerConfig | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Class DefaultICUTokenizerConfig Default ICUTokenizerConfig that is generally applicable to many languages. Inheritance System.Object ICUTokenizerConfig DefaultICUTokenizerConfig Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Lucene.Net.Analysis.Icu.Segmentation Assembly : Lucene.Net.ICU.dll Syntax public class DefaultICUTokenizerConfig : ICUTokenizerConfig Remarks Generally tokenizes Unicode text according to UAX#29 ( BreakIterator.GetWordInstance(ULocale.ROOT) ), but with the following tailorings: Thai, Lao, Myanmar, Khmer, and CJK text is broken into words with a dictionary. This is a Lucene.NET EXPERIMENTAL API, use at your own risk Constructors | Improve this Doc View Source DefaultICUTokenizerConfig(Boolean, Boolean) Creates a new config. This object is lightweight, but the first time the class is referenced, breakiterators will be initialized. Declaration public DefaultICUTokenizerConfig(bool cjkAsWords, bool myanmarAsWords) Parameters Type Name Description System.Boolean cjkAsWords true if cjk text should undergo dictionary-based segmentation, otherwise text will be segmented according to UAX#29 defaults. System.Boolean myanmarAsWords If this is true, all Han+Hiragana+Katakana words will be tagged as IDEOGRAPHIC. Fields | Improve this Doc View Source WORD_HANGUL Token type for words containing Korean hangul Declaration public static readonly string WORD_HANGUL Field Value Type Description System.String | Improve this Doc View Source WORD_HIRAGANA Token type for words containing Japanese hiragana Declaration public static readonly string WORD_HIRAGANA Field Value Type Description System.String | Improve this Doc View Source WORD_IDEO Token type for words containing ideographic characters Declaration public static readonly string WORD_IDEO Field Value Type Description System.String | Improve this Doc View Source WORD_KATAKANA Token type for words containing Japanese katakana Declaration public static readonly string WORD_KATAKANA Field Value Type Description System.String | Improve this Doc View Source WORD_LETTER Token type for words that contain letters Declaration public static readonly string WORD_LETTER Field Value Type Description System.String | Improve this Doc View Source WORD_NUMBER Token type for words that appear to be numbers Declaration public static readonly string WORD_NUMBER Field Value Type Description System.String Properties | Improve this Doc View Source CombineCJ Declaration public override bool CombineCJ { get; } Property Value Type Description System.Boolean Overrides ICUTokenizerConfig.CombineCJ Methods | Improve this Doc View Source GetBreakIterator(Int32) Declaration public override BreakIterator GetBreakIterator(int script) Parameters Type Name Description System.Int32 script Returns Type Description ICU4N.Text.BreakIterator Overrides ICUTokenizerConfig.GetBreakIterator(Int32) | Improve this Doc View Source GetType(Int32, Int32) Declaration public override string GetType(int script, int ruleStatus) Parameters Type Name Description System.Int32 script System.Int32 ruleStatus Returns Type Description System.String Overrides ICUTokenizerConfig.GetType(Int32, Int32)"
  },
  "Lucene.Net.Analysis.Icu.Segmentation.html": {
    "href": "Lucene.Net.Analysis.Icu.Segmentation.html",
    "title": "Namespace Lucene.Net.Analysis.Icu.Segmentation | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Namespace Lucene.Net.Analysis.Icu.Segmentation <!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. --> Tokenizer that breaks text into words with the Unicode Text Segmentation algorithm. Classes DefaultICUTokenizerConfig Default ICUTokenizerConfig that is generally applicable to many languages. ICUTokenizer Breaks text into words according to UAX #29: Unicode Text Segmentation ( http://www.unicode.org/reports/tr29/ ) Words are broken across script boundaries, then segmented according to the BreakIterator and typing provided by the ICUTokenizerConfig This is a Lucene.NET EXPERIMENTAL API, use at your own risk ICUTokenizerConfig Class that allows for tailored Unicode Text Segmentation on a per-writing system basis. This is a Lucene.NET EXPERIMENTAL API, use at your own risk ICUTokenizerFactory Factory for ICUTokenizer . Words are broken across script boundaries, then segmented according to the ICU4N.Text.BreakIterator and typing provided by the DefaultICUTokenizerConfig ."
  },
  "Lucene.Net.Analysis.Icu.Segmentation.ICUTokenizer.html": {
    "href": "Lucene.Net.Analysis.Icu.Segmentation.ICUTokenizer.html",
    "title": "Class ICUTokenizer | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Class ICUTokenizer Breaks text into words according to UAX #29: Unicode Text Segmentation ( http://www.unicode.org/reports/tr29/ ) Words are broken across script boundaries, then segmented according to the BreakIterator and typing provided by the ICUTokenizerConfig This is a Lucene.NET EXPERIMENTAL API, use at your own risk Inheritance System.Object Lucene.Net.Util.AttributeSource Lucene.Net.Analysis.TokenStream Lucene.Net.Analysis.Tokenizer ICUTokenizer Implements System.IDisposable Inherited Members Lucene.Net.Analysis.Tokenizer.m_input Tokenizer.Dispose(Boolean) Tokenizer.CorrectOffset(Int32) Tokenizer.SetReader(TextReader) Lucene.Net.Analysis.TokenStream.Dispose() Lucene.Net.Util.AttributeSource.GetAttributeFactory() Lucene.Net.Util.AttributeSource.GetAttributeClassesEnumerator() Lucene.Net.Util.AttributeSource.GetAttributeImplsEnumerator() Lucene.Net.Util.AttributeSource.AddAttributeImpl(Lucene.Net.Util.Attribute) Lucene.Net.Util.AttributeSource.AddAttribute<T>() Lucene.Net.Util.AttributeSource.HasAttributes Lucene.Net.Util.AttributeSource.HasAttribute<T>() Lucene.Net.Util.AttributeSource.GetAttribute<T>() Lucene.Net.Util.AttributeSource.ClearAttributes() Lucene.Net.Util.AttributeSource.CaptureState() Lucene.Net.Util.AttributeSource.RestoreState(Lucene.Net.Util.AttributeSource.State) Lucene.Net.Util.AttributeSource.GetHashCode() AttributeSource.Equals(Object) AttributeSource.ReflectAsString(Boolean) Lucene.Net.Util.AttributeSource.ReflectWith(Lucene.Net.Util.IAttributeReflector) Lucene.Net.Util.AttributeSource.CloneAttributes() Lucene.Net.Util.AttributeSource.CopyTo(Lucene.Net.Util.AttributeSource) Lucene.Net.Util.AttributeSource.ToString() System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Lucene.Net.Analysis.Icu.Segmentation Assembly : Lucene.Net.ICU.dll Syntax public sealed class ICUTokenizer : Tokenizer, IDisposable Constructors | Improve this Doc View Source ICUTokenizer(AttributeSource.AttributeFactory, TextReader, ICUTokenizerConfig) Construct a new ICUTokenizer that breaks text into words from the given System.IO.TextReader , using a tailored ICU4N.Text.BreakIterator configuration. Declaration public ICUTokenizer(AttributeSource.AttributeFactory factory, TextReader input, ICUTokenizerConfig config) Parameters Type Name Description Lucene.Net.Util.AttributeSource.AttributeFactory factory Lucene.Net.Util.AttributeSource.AttributeFactory to use. System.IO.TextReader input System.IO.TextReader containing text to tokenize. ICUTokenizerConfig config Tailored ICU4N.Text.BreakIterator configuration. | Improve this Doc View Source ICUTokenizer(TextReader) Construct a new ICUTokenizer that breaks text into words from the given System.IO.TextReader . Declaration public ICUTokenizer(TextReader input) Parameters Type Name Description System.IO.TextReader input System.IO.TextReader containing text to tokenize. Remarks The default script-specific handling is used. The default attribute factory is used. See Also DefaultICUTokenizerConfig | Improve this Doc View Source ICUTokenizer(TextReader, ICUTokenizerConfig) Construct a new ICUTokenizer that breaks text into words from the given System.IO.TextReader , using a tailored ICU4N.Text.BreakIterator configuration. Declaration public ICUTokenizer(TextReader input, ICUTokenizerConfig config) Parameters Type Name Description System.IO.TextReader input System.IO.TextReader containing text to tokenize. ICUTokenizerConfig config Tailored ICU4N.Text.BreakIterator configuration. Remarks The default attribute factory is used. Methods | Improve this Doc View Source End() Declaration public override void End() Overrides Lucene.Net.Analysis.TokenStream.End() | Improve this Doc View Source IncrementToken() Declaration public override bool IncrementToken() Returns Type Description System.Boolean Overrides Lucene.Net.Analysis.TokenStream.IncrementToken() | Improve this Doc View Source Reset() Declaration public override void Reset() Overrides Lucene.Net.Analysis.Tokenizer.Reset() Implements System.IDisposable See Also ICUTokenizerConfig"
  },
  "Lucene.Net.Analysis.Icu.Segmentation.ICUTokenizerConfig.html": {
    "href": "Lucene.Net.Analysis.Icu.Segmentation.ICUTokenizerConfig.html",
    "title": "Class ICUTokenizerConfig | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Class ICUTokenizerConfig Class that allows for tailored Unicode Text Segmentation on a per-writing system basis. This is a Lucene.NET EXPERIMENTAL API, use at your own risk Inheritance System.Object ICUTokenizerConfig DefaultICUTokenizerConfig Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Lucene.Net.Analysis.Icu.Segmentation Assembly : Lucene.Net.ICU.dll Syntax public abstract class ICUTokenizerConfig Constructors | Improve this Doc View Source ICUTokenizerConfig() Sole constructor. (For invocation by subclass constructors, typically implicit.) Declaration public ICUTokenizerConfig() Properties | Improve this Doc View Source CombineCJ true if Han, Hiragana, and Katakana scripts should all be returned as Japanese Declaration public abstract bool CombineCJ { get; } Property Value Type Description System.Boolean Methods | Improve this Doc View Source GetBreakIterator(Int32) Return a breakiterator capable of processing a given script. Declaration public abstract BreakIterator GetBreakIterator(int script) Parameters Type Name Description System.Int32 script Returns Type Description ICU4N.Text.BreakIterator | Improve this Doc View Source GetType(Int32, Int32) Return a token type value for a given script and BreakIterator rule status. Declaration public abstract string GetType(int script, int ruleStatus) Parameters Type Name Description System.Int32 script System.Int32 ruleStatus Returns Type Description System.String"
  },
  "Lucene.Net.Analysis.Icu.Segmentation.ICUTokenizerFactory.html": {
    "href": "Lucene.Net.Analysis.Icu.Segmentation.ICUTokenizerFactory.html",
    "title": "Class ICUTokenizerFactory | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Class ICUTokenizerFactory Factory for ICUTokenizer . Words are broken across script boundaries, then segmented according to the ICU4N.Text.BreakIterator and typing provided by the DefaultICUTokenizerConfig . Inheritance System.Object Lucene.Net.Analysis.Util.AbstractAnalysisFactory Lucene.Net.Analysis.Util.TokenizerFactory ICUTokenizerFactory Implements Lucene.Net.Analysis.Util.IResourceLoaderAware Inherited Members Lucene.Net.Analysis.Util.TokenizerFactory.ForName(System.String, System.Collections.Generic.IDictionary<System.String, System.String>) Lucene.Net.Analysis.Util.TokenizerFactory.LookupClass(System.String) Lucene.Net.Analysis.Util.TokenizerFactory.AvailableTokenizers Lucene.Net.Analysis.Util.TokenizerFactory.ReloadTokenizers() Lucene.Net.Analysis.Util.TokenizerFactory.Create(System.IO.TextReader) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.LUCENE_MATCH_VERSION_PARAM Lucene.Net.Analysis.Util.AbstractAnalysisFactory.m_luceneMatchVersion Lucene.Net.Analysis.Util.AbstractAnalysisFactory.OriginalArgs Lucene.Net.Analysis.Util.AbstractAnalysisFactory.AssureMatchVersion() Lucene.Net.Analysis.Util.AbstractAnalysisFactory.LuceneMatchVersion Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Require(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Require(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Require(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Get(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Get(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Get(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Get(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>, System.String, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.RequireInt32(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetInt32(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Int32) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.RequireBoolean(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetBoolean(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.RequireSingle(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetSingle(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Single) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.RequireChar(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetChar(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Char) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetSet(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetPattern(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetCulture(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Globalization.CultureInfo) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetWordSet(Lucene.Net.Analysis.Util.IResourceLoader, System.String, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetLines(Lucene.Net.Analysis.Util.IResourceLoader, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetSnowballWordSet(Lucene.Net.Analysis.Util.IResourceLoader, System.String, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.SplitFileNames(System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetClassArg() Lucene.Net.Analysis.Util.AbstractAnalysisFactory.IsExplicitLuceneMatchVersion System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Lucene.Net.Analysis.Icu.Segmentation Assembly : Lucene.Net.ICU.dll Syntax public class ICUTokenizerFactory : TokenizerFactory, IResourceLoaderAware Remarks To use the default set of per-script rules: <fieldType name=\"text_icu\" class=\"solr.TextField\" positionIncrementGap=\"100\"> <analyzer> <tokenizer class=\"solr.ICUTokenizerFactory\"/> </analyzer> </fieldType> You can customize this tokenizer's behavior by specifying per-script rule files, which are compiled by the ICU ICU4N.Text.RuleBasedBreakIterator . See the ICU RuleBasedBreakIterator syntax reference . To add per-script rules, add a \"rulefiles\" argument, which should contain a comma-separated list of code:rulefile pairs in the following format: four-letter ISO 15924 script code , followed by a colon, then a resource path. E.g. to specify rules for Latin (script code \"Latn\") and Cyrillic (script code \"Cyrl\"): <fieldType name=\"text_icu_custom\" class=\"solr.TextField\" positionIncrementGap=\"100\"> <analyzer> <tokenizer class=\"solr.ICUTokenizerFactory\" cjkAsWords=\"true\" rulefiles=\"Latn:my.Latin.rules.rbbi,Cyrl:my.Cyrillic.rules.rbbi\"/> </analyzer> </fieldType> Constructors | Improve this Doc View Source ICUTokenizerFactory(IDictionary<String, String>) Creates a new ICUTokenizerFactory . Declaration public ICUTokenizerFactory(IDictionary<string, string> args) Parameters Type Name Description System.Collections.Generic.IDictionary < System.String , System.String > args Methods | Improve this Doc View Source Create(AttributeSource.AttributeFactory, TextReader) Declaration public override Tokenizer Create(AttributeSource.AttributeFactory factory, TextReader input) Parameters Type Name Description Lucene.Net.Util.AttributeSource.AttributeFactory factory System.IO.TextReader input Returns Type Description Lucene.Net.Analysis.Tokenizer Overrides Lucene.Net.Analysis.Util.TokenizerFactory.Create(Lucene.Net.Util.AttributeSource.AttributeFactory, System.IO.TextReader) | Improve this Doc View Source Inform(IResourceLoader) Declaration public virtual void Inform(IResourceLoader loader) Parameters Type Name Description Lucene.Net.Analysis.Util.IResourceLoader loader Implements Lucene.Net.Analysis.Util.IResourceLoaderAware"
  },
  "Lucene.Net.Analysis.Icu.TokenAttributes.html": {
    "href": "Lucene.Net.Analysis.Icu.TokenAttributes.html",
    "title": "Namespace Lucene.Net.Analysis.Icu.TokenAttributes | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Namespace Lucene.Net.Analysis.Icu.TokenAttributes <!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. --> Additional ICU-specific Attributes for text analysis. Classes ScriptAttribute Implementation of IScriptAttribute that stores the script as an integer. This is a Lucene.NET EXPERIMENTAL API, use at your own risk Interfaces IScriptAttribute This attribute stores the UTR #24 script value for a token of text. This is a Lucene.NET EXPERIMENTAL API, use at your own risk"
  },
  "Lucene.Net.Analysis.Icu.TokenAttributes.IScriptAttribute.html": {
    "href": "Lucene.Net.Analysis.Icu.TokenAttributes.IScriptAttribute.html",
    "title": "Interface IScriptAttribute | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Interface IScriptAttribute This attribute stores the UTR #24 script value for a token of text. This is a Lucene.NET EXPERIMENTAL API, use at your own risk Inherited Members Lucene.Net.Util.IAttribute.CopyTo(Lucene.Net.Util.IAttribute) Namespace : Lucene.Net.Analysis.Icu.TokenAttributes Assembly : Lucene.Net.ICU.dll Syntax public interface IScriptAttribute : IAttribute Properties | Improve this Doc View Source Code Gets or Sets the numeric code for this script value. This is the constant value from ICU4N.Globalization.UScript . Declaration int Code { get; set; } Property Value Type Description System.Int32 Methods | Improve this Doc View Source GetName() Get the full name. Declaration string GetName() Returns Type Description System.String UTR #24 full name. | Improve this Doc View Source GetShortName() Get the abbreviated name. Declaration string GetShortName() Returns Type Description System.String UTR #24 abbreviated name."
  },
  "Lucene.Net.Analysis.Icu.TokenAttributes.ScriptAttribute.html": {
    "href": "Lucene.Net.Analysis.Icu.TokenAttributes.ScriptAttribute.html",
    "title": "Class ScriptAttribute | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Class ScriptAttribute Implementation of IScriptAttribute that stores the script as an integer. This is a Lucene.NET EXPERIMENTAL API, use at your own risk Inheritance System.Object Lucene.Net.Util.Attribute ScriptAttribute Implements IScriptAttribute Lucene.Net.Util.IAttribute Inherited Members Attribute.ReflectAsString(Boolean) Lucene.Net.Util.Attribute.ToString() Lucene.Net.Util.Attribute.Clone() System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Lucene.Net.Analysis.Icu.TokenAttributes Assembly : Lucene.Net.ICU.dll Syntax public class ScriptAttribute : Attribute, IScriptAttribute, IAttribute Constructors | Improve this Doc View Source ScriptAttribute() Initializes this attribute with ICU4N.Globalization.UScript.Common . Declaration public ScriptAttribute() Properties | Improve this Doc View Source Code Declaration public virtual int Code { get; set; } Property Value Type Description System.Int32 Methods | Improve this Doc View Source Clear() Declaration public override void Clear() Overrides Lucene.Net.Util.Attribute.Clear() | Improve this Doc View Source CopyTo(IAttribute) Declaration public override void CopyTo(IAttribute target) Parameters Type Name Description Lucene.Net.Util.IAttribute target Overrides Lucene.Net.Util.Attribute.CopyTo(Lucene.Net.Util.IAttribute) | Improve this Doc View Source Equals(Object) Declaration public override bool Equals(object other) Parameters Type Name Description System.Object other Returns Type Description System.Boolean Overrides System.Object.Equals(System.Object) | Improve this Doc View Source GetHashCode() Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.Object.GetHashCode() | Improve this Doc View Source GetName() Declaration public virtual string GetName() Returns Type Description System.String | Improve this Doc View Source GetShortName() Declaration public virtual string GetShortName() Returns Type Description System.String | Improve this Doc View Source ReflectWith(IAttributeReflector) Declaration public override void ReflectWith(IAttributeReflector reflector) Parameters Type Name Description Lucene.Net.Util.IAttributeReflector reflector Overrides Lucene.Net.Util.Attribute.ReflectWith(Lucene.Net.Util.IAttributeReflector) Implements IScriptAttribute Lucene.Net.Util.IAttribute"
  },
  "Lucene.Net.Analysis.Th.html": {
    "href": "Lucene.Net.Analysis.Th.html",
    "title": "Namespace Lucene.Net.Analysis.Th | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Namespace Lucene.Net.Analysis.Th Classes ThaiAnalyzer Lucene.Net.Analysis.Analyzer for Thai language. It uses ICU4N.Text.BreakIterator to break words. You must specify the required Lucene.Net.Util.LuceneVersion compatibility when creating ThaiAnalyzer : As of 3.6, a set of Thai stopwords is used by default ThaiTokenizer Tokenizer that use ICU4N.Text.BreakIterator to tokenize Thai text. ThaiTokenizerFactory Factory for ThaiTokenizer . <fieldType name=\"text_thai\" class=\"solr.TextField\" positionIncrementGap=\"100\"> <analyzer> <tokenizer class=\"solr.ThaiTokenizerFactory\"/> </analyzer> </fieldType> ThaiWordFilter Lucene.Net.Analysis.TokenFilter that use ICU4N.Text.BreakIterator to break each Token that is Thai into separate Token(s) for each Thai word. Please note: Since matchVersion 3.1 on, this filter no longer lowercases non-thai text. ThaiAnalyzer will insert a Lucene.Net.Analysis.Core.LowerCaseFilter before this filter so the behaviour of the Analyzer does not change. With version 3.1, the filter handles position increments correctly. ThaiWordFilterFactory Factory for ThaiWordFilter . <fieldType name=\"text_thai\" class=\"solr.TextField\" positionIncrementGap=\"100\"> <analyzer> <tokenizer class=\"solr.StandardTokenizerFactory\"/> <filter class=\"solr.ThaiWordFilterFactory\"/> </analyzer> </fieldType>"
  },
  "Lucene.Net.Analysis.Th.ThaiAnalyzer.html": {
    "href": "Lucene.Net.Analysis.Th.ThaiAnalyzer.html",
    "title": "Class ThaiAnalyzer | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Class ThaiAnalyzer Lucene.Net.Analysis.Analyzer for Thai language. It uses ICU4N.Text.BreakIterator to break words. You must specify the required Lucene.Net.Util.LuceneVersion compatibility when creating ThaiAnalyzer : As of 3.6, a set of Thai stopwords is used by default Inheritance System.Object Lucene.Net.Analysis.Analyzer Lucene.Net.Analysis.Util.StopwordAnalyzerBase ThaiAnalyzer Implements System.IDisposable Inherited Members Lucene.Net.Analysis.Util.StopwordAnalyzerBase.m_stopwords Lucene.Net.Analysis.Util.StopwordAnalyzerBase.m_matchVersion Lucene.Net.Analysis.Util.StopwordAnalyzerBase.StopwordSet Lucene.Net.Analysis.Util.StopwordAnalyzerBase.LoadStopwordSet(System.Boolean, System.Type, System.String, System.String) Lucene.Net.Analysis.Util.StopwordAnalyzerBase.LoadStopwordSet(System.IO.FileInfo, Lucene.Net.Util.LuceneVersion) Lucene.Net.Analysis.Util.StopwordAnalyzerBase.LoadStopwordSet(System.IO.TextReader, Lucene.Net.Util.LuceneVersion) Analyzer.NewAnonymous(Func<String, TextReader, TokenStreamComponents>) Analyzer.NewAnonymous(Func<String, TextReader, TokenStreamComponents>, ReuseStrategy) Analyzer.NewAnonymous(Func<String, TextReader, TokenStreamComponents>, Func<String, TextReader, TextReader>) Analyzer.NewAnonymous(Func<String, TextReader, TokenStreamComponents>, Func<String, TextReader, TextReader>, ReuseStrategy) Analyzer.GetTokenStream(String, TextReader) Analyzer.GetTokenStream(String, String) Analyzer.InitReader(String, TextReader) Analyzer.GetPositionIncrementGap(String) Analyzer.GetOffsetGap(String) Lucene.Net.Analysis.Analyzer.Strategy Lucene.Net.Analysis.Analyzer.Dispose() Analyzer.Dispose(Boolean) Lucene.Net.Analysis.Analyzer.GLOBAL_REUSE_STRATEGY Lucene.Net.Analysis.Analyzer.PER_FIELD_REUSE_STRATEGY System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Lucene.Net.Analysis.Th Assembly : Lucene.Net.ICU.dll Syntax public sealed class ThaiAnalyzer : StopwordAnalyzerBase, IDisposable Constructors | Improve this Doc View Source ThaiAnalyzer(LuceneVersion) Builds an analyzer with the default stop words. Declaration public ThaiAnalyzer(LuceneVersion matchVersion) Parameters Type Name Description Lucene.Net.Util.LuceneVersion matchVersion lucene compatibility version | Improve this Doc View Source ThaiAnalyzer(LuceneVersion, CharArraySet) Builds an analyzer with the given stop words. Declaration public ThaiAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords) Parameters Type Name Description Lucene.Net.Util.LuceneVersion matchVersion lucene compatibility version Lucene.Net.Analysis.Util.CharArraySet stopwords a stopword set Fields | Improve this Doc View Source DEFAULT_STOPWORD_FILE File containing default Thai stopwords. Declaration public const string DEFAULT_STOPWORD_FILE = \"stopwords.txt\" Field Value Type Description System.String Properties | Improve this Doc View Source DefaultStopSet Returns an unmodifiable instance of the default stop words set. Declaration public static CharArraySet DefaultStopSet { get; } Property Value Type Description Lucene.Net.Analysis.Util.CharArraySet default stop words set. Methods | Improve this Doc View Source CreateComponents(String, TextReader) Creates Lucene.Net.Analysis.TokenStreamComponents used to tokenize all the text in the provided System.IO.TextReader . Declaration protected override TokenStreamComponents CreateComponents(string fieldName, TextReader reader) Parameters Type Name Description System.String fieldName System.IO.TextReader reader Returns Type Description Lucene.Net.Analysis.TokenStreamComponents Lucene.Net.Analysis.TokenStreamComponents built from a Lucene.Net.Analysis.Standard.StandardTokenizer filtered with Lucene.Net.Analysis.Standard.StandardFilter , Lucene.Net.Analysis.Core.LowerCaseFilter , ThaiWordFilter , and Lucene.Net.Analysis.Core.StopFilter Overrides Analyzer.CreateComponents(String, TextReader) Implements System.IDisposable"
  },
  "Lucene.Net.Analysis.Th.ThaiTokenizer.html": {
    "href": "Lucene.Net.Analysis.Th.ThaiTokenizer.html",
    "title": "Class ThaiTokenizer | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Class ThaiTokenizer Tokenizer that use ICU4N.Text.BreakIterator to tokenize Thai text. Inheritance System.Object Lucene.Net.Util.AttributeSource Lucene.Net.Analysis.TokenStream Lucene.Net.Analysis.Tokenizer SegmentingTokenizerBase ThaiTokenizer Implements System.IDisposable Inherited Members SegmentingTokenizerBase.BUFFERMAX SegmentingTokenizerBase.m_buffer SegmentingTokenizerBase.m_offset SegmentingTokenizerBase.IncrementToken() SegmentingTokenizerBase.Reset() SegmentingTokenizerBase.End() SegmentingTokenizerBase.IsSafeEnd(Char) Lucene.Net.Analysis.Tokenizer.m_input Tokenizer.Dispose(Boolean) Tokenizer.CorrectOffset(Int32) Tokenizer.SetReader(TextReader) Lucene.Net.Analysis.TokenStream.Dispose() Lucene.Net.Util.AttributeSource.GetAttributeFactory() Lucene.Net.Util.AttributeSource.GetAttributeClassesEnumerator() Lucene.Net.Util.AttributeSource.GetAttributeImplsEnumerator() Lucene.Net.Util.AttributeSource.AddAttributeImpl(Lucene.Net.Util.Attribute) Lucene.Net.Util.AttributeSource.AddAttribute<T>() Lucene.Net.Util.AttributeSource.HasAttributes Lucene.Net.Util.AttributeSource.HasAttribute<T>() Lucene.Net.Util.AttributeSource.GetAttribute<T>() Lucene.Net.Util.AttributeSource.ClearAttributes() Lucene.Net.Util.AttributeSource.CaptureState() Lucene.Net.Util.AttributeSource.RestoreState(Lucene.Net.Util.AttributeSource.State) Lucene.Net.Util.AttributeSource.GetHashCode() AttributeSource.Equals(Object) AttributeSource.ReflectAsString(Boolean) Lucene.Net.Util.AttributeSource.ReflectWith(Lucene.Net.Util.IAttributeReflector) Lucene.Net.Util.AttributeSource.CloneAttributes() Lucene.Net.Util.AttributeSource.CopyTo(Lucene.Net.Util.AttributeSource) Lucene.Net.Util.AttributeSource.ToString() System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Lucene.Net.Analysis.Th Assembly : Lucene.Net.ICU.dll Syntax public class ThaiTokenizer : SegmentingTokenizerBase, IDisposable Constructors | Improve this Doc View Source ThaiTokenizer(AttributeSource.AttributeFactory, TextReader) Creates a new ThaiTokenizer , supplying the Lucene.Net.Util.AttributeSource.AttributeFactory Declaration public ThaiTokenizer(AttributeSource.AttributeFactory factory, TextReader reader) Parameters Type Name Description Lucene.Net.Util.AttributeSource.AttributeFactory factory System.IO.TextReader reader | Improve this Doc View Source ThaiTokenizer(TextReader) Creates a new ThaiTokenizer Declaration public ThaiTokenizer(TextReader reader) Parameters Type Name Description System.IO.TextReader reader Methods | Improve this Doc View Source IncrementWord() Declaration protected override bool IncrementWord() Returns Type Description System.Boolean Overrides SegmentingTokenizerBase.IncrementWord() | Improve this Doc View Source SetNextSentence(Int32, Int32) Declaration protected override void SetNextSentence(int sentenceStart, int sentenceEnd) Parameters Type Name Description System.Int32 sentenceStart System.Int32 sentenceEnd Overrides SegmentingTokenizerBase.SetNextSentence(Int32, Int32) Implements System.IDisposable"
  },
  "Lucene.Net.Analysis.Th.ThaiTokenizerFactory.html": {
    "href": "Lucene.Net.Analysis.Th.ThaiTokenizerFactory.html",
    "title": "Class ThaiTokenizerFactory | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Class ThaiTokenizerFactory Factory for ThaiTokenizer . <fieldType name=\"text_thai\" class=\"solr.TextField\" positionIncrementGap=\"100\"> <analyzer> <tokenizer class=\"solr.ThaiTokenizerFactory\"/> </analyzer> </fieldType> Inheritance System.Object Lucene.Net.Analysis.Util.AbstractAnalysisFactory Lucene.Net.Analysis.Util.TokenizerFactory ThaiTokenizerFactory Inherited Members Lucene.Net.Analysis.Util.TokenizerFactory.ForName(System.String, System.Collections.Generic.IDictionary<System.String, System.String>) Lucene.Net.Analysis.Util.TokenizerFactory.LookupClass(System.String) Lucene.Net.Analysis.Util.TokenizerFactory.AvailableTokenizers Lucene.Net.Analysis.Util.TokenizerFactory.ReloadTokenizers() Lucene.Net.Analysis.Util.TokenizerFactory.Create(System.IO.TextReader) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.LUCENE_MATCH_VERSION_PARAM Lucene.Net.Analysis.Util.AbstractAnalysisFactory.m_luceneMatchVersion Lucene.Net.Analysis.Util.AbstractAnalysisFactory.OriginalArgs Lucene.Net.Analysis.Util.AbstractAnalysisFactory.AssureMatchVersion() Lucene.Net.Analysis.Util.AbstractAnalysisFactory.LuceneMatchVersion Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Require(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Require(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Require(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Get(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Get(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Get(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Get(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>, System.String, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.RequireInt32(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetInt32(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Int32) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.RequireBoolean(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetBoolean(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.RequireSingle(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetSingle(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Single) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.RequireChar(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetChar(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Char) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetSet(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetPattern(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetCulture(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Globalization.CultureInfo) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetWordSet(Lucene.Net.Analysis.Util.IResourceLoader, System.String, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetLines(Lucene.Net.Analysis.Util.IResourceLoader, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetSnowballWordSet(Lucene.Net.Analysis.Util.IResourceLoader, System.String, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.SplitFileNames(System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetClassArg() Lucene.Net.Analysis.Util.AbstractAnalysisFactory.IsExplicitLuceneMatchVersion System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Lucene.Net.Analysis.Th Assembly : Lucene.Net.ICU.dll Syntax public class ThaiTokenizerFactory : TokenizerFactory Constructors | Improve this Doc View Source ThaiTokenizerFactory(IDictionary<String, String>) Creates a new ThaiTokenizerFactory Declaration public ThaiTokenizerFactory(IDictionary<string, string> args) Parameters Type Name Description System.Collections.Generic.IDictionary < System.String , System.String > args Methods | Improve this Doc View Source Create(AttributeSource.AttributeFactory, TextReader) Declaration public override Tokenizer Create(AttributeSource.AttributeFactory factory, TextReader reader) Parameters Type Name Description Lucene.Net.Util.AttributeSource.AttributeFactory factory System.IO.TextReader reader Returns Type Description Lucene.Net.Analysis.Tokenizer Overrides Lucene.Net.Analysis.Util.TokenizerFactory.Create(Lucene.Net.Util.AttributeSource.AttributeFactory, System.IO.TextReader)"
  },
  "Lucene.Net.Analysis.Th.ThaiWordFilter.html": {
    "href": "Lucene.Net.Analysis.Th.ThaiWordFilter.html",
    "title": "Class ThaiWordFilter | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Class ThaiWordFilter Lucene.Net.Analysis.TokenFilter that use ICU4N.Text.BreakIterator to break each Token that is Thai into separate Token(s) for each Thai word. Please note: Since matchVersion 3.1 on, this filter no longer lowercases non-thai text. ThaiAnalyzer will insert a Lucene.Net.Analysis.Core.LowerCaseFilter before this filter so the behaviour of the Analyzer does not change. With version 3.1, the filter handles position increments correctly. Inheritance System.Object Lucene.Net.Util.AttributeSource Lucene.Net.Analysis.TokenStream Lucene.Net.Analysis.TokenFilter ThaiWordFilter Implements System.IDisposable Inherited Members Lucene.Net.Analysis.TokenFilter.m_input Lucene.Net.Analysis.TokenFilter.End() TokenFilter.Dispose(Boolean) Lucene.Net.Analysis.TokenStream.Dispose() Lucene.Net.Util.AttributeSource.GetAttributeFactory() Lucene.Net.Util.AttributeSource.GetAttributeClassesEnumerator() Lucene.Net.Util.AttributeSource.GetAttributeImplsEnumerator() Lucene.Net.Util.AttributeSource.AddAttributeImpl(Lucene.Net.Util.Attribute) Lucene.Net.Util.AttributeSource.AddAttribute<T>() Lucene.Net.Util.AttributeSource.HasAttributes Lucene.Net.Util.AttributeSource.HasAttribute<T>() Lucene.Net.Util.AttributeSource.GetAttribute<T>() Lucene.Net.Util.AttributeSource.ClearAttributes() Lucene.Net.Util.AttributeSource.CaptureState() Lucene.Net.Util.AttributeSource.RestoreState(Lucene.Net.Util.AttributeSource.State) Lucene.Net.Util.AttributeSource.GetHashCode() AttributeSource.Equals(Object) AttributeSource.ReflectAsString(Boolean) Lucene.Net.Util.AttributeSource.ReflectWith(Lucene.Net.Util.IAttributeReflector) Lucene.Net.Util.AttributeSource.CloneAttributes() Lucene.Net.Util.AttributeSource.CopyTo(Lucene.Net.Util.AttributeSource) Lucene.Net.Util.AttributeSource.ToString() System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Lucene.Net.Analysis.Th Assembly : Lucene.Net.ICU.dll Syntax [Obsolete(\"Use ThaiTokenizer instead.\")] public sealed class ThaiWordFilter : TokenFilter, IDisposable Constructors | Improve this Doc View Source ThaiWordFilter(LuceneVersion, TokenStream) Creates a new ThaiWordFilter with the specified match version. Declaration public ThaiWordFilter(LuceneVersion matchVersion, TokenStream input) Parameters Type Name Description Lucene.Net.Util.LuceneVersion matchVersion Lucene.Net.Analysis.TokenStream input Methods | Improve this Doc View Source IncrementToken() Declaration public override bool IncrementToken() Returns Type Description System.Boolean Overrides Lucene.Net.Analysis.TokenStream.IncrementToken() | Improve this Doc View Source Reset() Declaration public override void Reset() Overrides Lucene.Net.Analysis.TokenFilter.Reset() Implements System.IDisposable"
  },
  "Lucene.Net.Analysis.Th.ThaiWordFilterFactory.html": {
    "href": "Lucene.Net.Analysis.Th.ThaiWordFilterFactory.html",
    "title": "Class ThaiWordFilterFactory | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Class ThaiWordFilterFactory Factory for ThaiWordFilter . <fieldType name=\"text_thai\" class=\"solr.TextField\" positionIncrementGap=\"100\"> <analyzer> <tokenizer class=\"solr.StandardTokenizerFactory\"/> <filter class=\"solr.ThaiWordFilterFactory\"/> </analyzer> </fieldType> Inheritance System.Object Lucene.Net.Analysis.Util.AbstractAnalysisFactory Lucene.Net.Analysis.Util.TokenFilterFactory ThaiWordFilterFactory Inherited Members Lucene.Net.Analysis.Util.TokenFilterFactory.ForName(System.String, System.Collections.Generic.IDictionary<System.String, System.String>) Lucene.Net.Analysis.Util.TokenFilterFactory.LookupClass(System.String) Lucene.Net.Analysis.Util.TokenFilterFactory.AvailableTokenFilters Lucene.Net.Analysis.Util.TokenFilterFactory.ReloadTokenFilters() Lucene.Net.Analysis.Util.AbstractAnalysisFactory.LUCENE_MATCH_VERSION_PARAM Lucene.Net.Analysis.Util.AbstractAnalysisFactory.m_luceneMatchVersion Lucene.Net.Analysis.Util.AbstractAnalysisFactory.OriginalArgs Lucene.Net.Analysis.Util.AbstractAnalysisFactory.AssureMatchVersion() Lucene.Net.Analysis.Util.AbstractAnalysisFactory.LuceneMatchVersion Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Require(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Require(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Require(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Get(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Get(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Get(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Get(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>, System.String, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.RequireInt32(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetInt32(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Int32) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.RequireBoolean(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetBoolean(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.RequireSingle(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetSingle(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Single) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.RequireChar(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetChar(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Char) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetSet(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetPattern(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetCulture(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Globalization.CultureInfo) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetWordSet(Lucene.Net.Analysis.Util.IResourceLoader, System.String, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetLines(Lucene.Net.Analysis.Util.IResourceLoader, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetSnowballWordSet(Lucene.Net.Analysis.Util.IResourceLoader, System.String, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.SplitFileNames(System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetClassArg() Lucene.Net.Analysis.Util.AbstractAnalysisFactory.IsExplicitLuceneMatchVersion System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Lucene.Net.Analysis.Th Assembly : Lucene.Net.ICU.dll Syntax [Obsolete(\"Use ThaiTokenizerFactory instead\")] public class ThaiWordFilterFactory : TokenFilterFactory Constructors | Improve this Doc View Source ThaiWordFilterFactory(IDictionary<String, String>) Creates a new ThaiWordFilterFactory Declaration public ThaiWordFilterFactory(IDictionary<string, string> args) Parameters Type Name Description System.Collections.Generic.IDictionary < System.String , System.String > args Methods | Improve this Doc View Source Create(TokenStream) Declaration public override TokenStream Create(TokenStream input) Parameters Type Name Description Lucene.Net.Analysis.TokenStream input Returns Type Description Lucene.Net.Analysis.TokenStream Overrides Lucene.Net.Analysis.Util.TokenFilterFactory.Create(Lucene.Net.Analysis.TokenStream)"
  },
  "Lucene.Net.Analysis.Util.CharArrayIterator.html": {
    "href": "Lucene.Net.Analysis.Util.CharArrayIterator.html",
    "title": "Class CharArrayIterator | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Class CharArrayIterator A CharacterIterator used internally for use with ICU4N.Text.BreakIterator This is a Lucene.NET INTERNAL API, use at your own risk Inheritance System.Object ICU4N.Support.Text.CharacterIterator CharArrayIterator Inherited Members ICU4N.Support.Text.CharacterIterator.Done System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Lucene.Net.Analysis.Util Assembly : Lucene.Net.ICU.dll Syntax public abstract class CharArrayIterator : CharacterIterator Properties | Improve this Doc View Source BeginIndex Declaration public override int BeginIndex { get; } Property Value Type Description System.Int32 Overrides ICU4N.Support.Text.CharacterIterator.BeginIndex | Improve this Doc View Source Current Declaration public override char Current { get; } Property Value Type Description System.Char Overrides ICU4N.Support.Text.CharacterIterator.Current | Improve this Doc View Source EndIndex Declaration public override int EndIndex { get; } Property Value Type Description System.Int32 Overrides ICU4N.Support.Text.CharacterIterator.EndIndex | Improve this Doc View Source Index Declaration public override int Index { get; } Property Value Type Description System.Int32 Overrides ICU4N.Support.Text.CharacterIterator.Index | Improve this Doc View Source Length Declaration public virtual int Length { get; } Property Value Type Description System.Int32 | Improve this Doc View Source Start Declaration public virtual int Start { get; } Property Value Type Description System.Int32 | Improve this Doc View Source Text Declaration public virtual char[] Text { get; } Property Value Type Description System.Char [] Methods | Improve this Doc View Source Clone() Declaration public override object Clone() Returns Type Description System.Object Overrides ICU4N.Support.Text.CharacterIterator.Clone() | Improve this Doc View Source First() Declaration public override char First() Returns Type Description System.Char Overrides ICU4N.Support.Text.CharacterIterator.First() | Improve this Doc View Source JreBugWorkaround(Char) Declaration protected abstract char JreBugWorkaround(char ch) Parameters Type Name Description System.Char ch Returns Type Description System.Char | Improve this Doc View Source Last() Declaration public override char Last() Returns Type Description System.Char Overrides ICU4N.Support.Text.CharacterIterator.Last() | Improve this Doc View Source NewSentenceInstance() Create a new CharArrayIterator that works around JRE bugs in a manner suitable for ICU4N.Text.BreakIterator.GetSentenceInstance() . Declaration public static CharArrayIterator NewSentenceInstance() Returns Type Description CharArrayIterator | Improve this Doc View Source NewWordInstance() Create a new CharArrayIterator that works around JRE bugs in a manner suitable for ICU4N.Text.BreakIterator.GetWordInstance() . Declaration public static CharArrayIterator NewWordInstance() Returns Type Description CharArrayIterator | Improve this Doc View Source Next() Declaration public override char Next() Returns Type Description System.Char Overrides ICU4N.Support.Text.CharacterIterator.Next() | Improve this Doc View Source Previous() Declaration public override char Previous() Returns Type Description System.Char Overrides ICU4N.Support.Text.CharacterIterator.Previous() | Improve this Doc View Source SetIndex(Int32) Declaration public override char SetIndex(int position) Parameters Type Name Description System.Int32 position Returns Type Description System.Char Overrides ICU4N.Support.Text.CharacterIterator.SetIndex(System.Int32) | Improve this Doc View Source SetText(Char[], Int32, Int32) Set a new region of text to be examined by this iterator Declaration public virtual void SetText(char[] array, int start, int length) Parameters Type Name Description System.Char [] array text buffer to examine System.Int32 start offset into buffer System.Int32 length maximum length to examine"
  },
  "Lucene.Net.Analysis.Util.html": {
    "href": "Lucene.Net.Analysis.Util.html",
    "title": "Namespace Lucene.Net.Analysis.Util | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Namespace Lucene.Net.Analysis.Util Classes CharArrayIterator A CharacterIterator used internally for use with ICU4N.Text.BreakIterator This is a Lucene.NET INTERNAL API, use at your own risk SegmentingTokenizerBase Breaks text into sentences with a ICU4N.Text.BreakIterator and allows subclasses to decompose these sentences into words. This can be used by subclasses that need sentence context for tokenization purposes, such as CJK segmenters. Additionally it can be used by subclasses that want to mark sentence boundaries (with a custom attribute, extra token, position increment, etc) for downstream processing. This is a Lucene.NET EXPERIMENTAL API, use at your own risk"
  },
  "Lucene.Net.Analysis.Util.SegmentingTokenizerBase.html": {
    "href": "Lucene.Net.Analysis.Util.SegmentingTokenizerBase.html",
    "title": "Class SegmentingTokenizerBase | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Class SegmentingTokenizerBase Breaks text into sentences with a ICU4N.Text.BreakIterator and allows subclasses to decompose these sentences into words. This can be used by subclasses that need sentence context for tokenization purposes, such as CJK segmenters. Additionally it can be used by subclasses that want to mark sentence boundaries (with a custom attribute, extra token, position increment, etc) for downstream processing. This is a Lucene.NET EXPERIMENTAL API, use at your own risk Inheritance System.Object Lucene.Net.Util.AttributeSource Lucene.Net.Analysis.TokenStream Lucene.Net.Analysis.Tokenizer SegmentingTokenizerBase ThaiTokenizer Implements System.IDisposable Inherited Members Lucene.Net.Analysis.Tokenizer.m_input Tokenizer.Dispose(Boolean) Tokenizer.CorrectOffset(Int32) Tokenizer.SetReader(TextReader) Lucene.Net.Analysis.TokenStream.Dispose() Lucene.Net.Util.AttributeSource.GetAttributeFactory() Lucene.Net.Util.AttributeSource.GetAttributeClassesEnumerator() Lucene.Net.Util.AttributeSource.GetAttributeImplsEnumerator() Lucene.Net.Util.AttributeSource.AddAttributeImpl(Lucene.Net.Util.Attribute) Lucene.Net.Util.AttributeSource.AddAttribute<T>() Lucene.Net.Util.AttributeSource.HasAttributes Lucene.Net.Util.AttributeSource.HasAttribute<T>() Lucene.Net.Util.AttributeSource.GetAttribute<T>() Lucene.Net.Util.AttributeSource.ClearAttributes() Lucene.Net.Util.AttributeSource.CaptureState() Lucene.Net.Util.AttributeSource.RestoreState(Lucene.Net.Util.AttributeSource.State) Lucene.Net.Util.AttributeSource.GetHashCode() AttributeSource.Equals(Object) AttributeSource.ReflectAsString(Boolean) Lucene.Net.Util.AttributeSource.ReflectWith(Lucene.Net.Util.IAttributeReflector) Lucene.Net.Util.AttributeSource.CloneAttributes() Lucene.Net.Util.AttributeSource.CopyTo(Lucene.Net.Util.AttributeSource) Lucene.Net.Util.AttributeSource.ToString() System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Lucene.Net.Analysis.Util Assembly : Lucene.Net.ICU.dll Syntax public abstract class SegmentingTokenizerBase : Tokenizer, IDisposable Constructors | Improve this Doc View Source SegmentingTokenizerBase(AttributeSource.AttributeFactory, TextReader, BreakIterator) Construct a new SegmenterBase, also supplying the Lucene.Net.Util.AttributeSource.AttributeFactory Declaration public SegmentingTokenizerBase(AttributeSource.AttributeFactory factory, TextReader reader, BreakIterator iterator) Parameters Type Name Description Lucene.Net.Util.AttributeSource.AttributeFactory factory System.IO.TextReader reader ICU4N.Text.BreakIterator iterator | Improve this Doc View Source SegmentingTokenizerBase(TextReader, BreakIterator) Construct a new SegmenterBase, using the provided ICU4N.Text.BreakIterator for sentence segmentation. Note that you should never share ICU4N.Text.BreakIterator s across different Lucene.Net.Analysis.TokenStream s, instead a newly created or cloned one should always be provided to this constructor. Declaration public SegmentingTokenizerBase(TextReader reader, BreakIterator iterator) Parameters Type Name Description System.IO.TextReader reader ICU4N.Text.BreakIterator iterator Fields | Improve this Doc View Source BUFFERMAX Declaration protected const int BUFFERMAX = 1024 Field Value Type Description System.Int32 | Improve this Doc View Source m_buffer Declaration protected readonly char[] m_buffer Field Value Type Description System.Char [] | Improve this Doc View Source m_offset accumulated offset of previous buffers for this reader, for offsetAtt Declaration protected int m_offset Field Value Type Description System.Int32 Methods | Improve this Doc View Source End() Declaration public override sealed void End() Overrides Lucene.Net.Analysis.TokenStream.End() | Improve this Doc View Source IncrementToken() Declaration public override sealed bool IncrementToken() Returns Type Description System.Boolean Overrides Lucene.Net.Analysis.TokenStream.IncrementToken() | Improve this Doc View Source IncrementWord() Returns true if another word is available Declaration protected abstract bool IncrementWord() Returns Type Description System.Boolean | Improve this Doc View Source IsSafeEnd(Char) For sentence tokenization, these are the unambiguous break positions. Declaration protected virtual bool IsSafeEnd(char ch) Parameters Type Name Description System.Char ch Returns Type Description System.Boolean | Improve this Doc View Source Reset() Declaration public override void Reset() Overrides Lucene.Net.Analysis.Tokenizer.Reset() | Improve this Doc View Source SetNextSentence(Int32, Int32) Provides the next input sentence for analysis Declaration protected abstract void SetNextSentence(int sentenceStart, int sentenceEnd) Parameters Type Name Description System.Int32 sentenceStart System.Int32 sentenceEnd Implements System.IDisposable"
  },
  "Lucene.Net.Collation.html": {
    "href": "Lucene.Net.Collation.html",
    "title": "Namespace Lucene.Net.Collation | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Namespace Lucene.Net.Collation <!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. --> Unicode Collation support. Classes ICUCollationAttributeFactory Converts each token into its ICU4N.Text.CollationKey , and then encodes bytes as an index term. ICUCollationDocValuesField Indexes sort keys as a single-valued SortedDocValuesField . ICUCollationKeyAnalyzer Configures Lucene.Net.Analysis.Core.KeywordTokenizer with ICUCollationAttributeFactory . ICUCollationKeyFilter Converts each token into its ICU4N.Text.CollationKey , and then encodes the ICU4N.Text.CollationKey with IndexableBinaryStringTools , to allow it to be stored as an index term. ICUCollationKeyFilterFactory Factory for ICUCollationKeyFilter ."
  },
  "Lucene.Net.Collation.ICUCollationAttributeFactory.html": {
    "href": "Lucene.Net.Collation.ICUCollationAttributeFactory.html",
    "title": "Class ICUCollationAttributeFactory | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Class ICUCollationAttributeFactory Converts each token into its ICU4N.Text.CollationKey , and then encodes bytes as an index term. Inheritance System.Object Lucene.Net.Util.AttributeSource.AttributeFactory ICUCollationAttributeFactory Inherited Members Lucene.Net.Util.AttributeSource.AttributeFactory.DEFAULT_ATTRIBUTE_FACTORY System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Lucene.Net.Collation Assembly : Lucene.Net.ICU.dll Syntax public class ICUCollationAttributeFactory : AttributeSource.AttributeFactory Remarks WARNING: Make sure you use exactly the same ICU4N.Text.Collator at index and query time -- ICU4N.Text.CollationKey s are only comparable when produced by the same ICU4N.Text.Collator . ICU4N.Text.RuleBasedCollator s are independently versioned, so it is safe to search against stored ICU4N.Text.CollationKey s if the following are exactly the same (best practice is to store this information with the index and check that they remain the same at query time): Collator version - see ICU4N.Text.Collator Version The collation strength used - see ICU4N.Text.Collator.Strength ICU4N.Text.CollationKey s generated by ICU Collators are not compatible with those generated by java.text.Collators. Specifically, if you use ICUCollationAttributeFactory to generate index terms, do not use CollationAttributeFactory on the query side, or vice versa. ICUCollationAttributeFactory is significantly faster and generates significantly shorter keys than CollationAttributeFactory. See http://site.icu-project.org/charts/collation-icu4j-sun for key generation timing and key length comparisons between ICU4J and java.text.Collator over several languages. Constructors | Improve this Doc View Source ICUCollationAttributeFactory(Collator) Create an ICUCollationAttributeFactory , using Lucene.Net.Util.AttributeSource.AttributeFactory.DEFAULT_ATTRIBUTE_FACTORY as the factory for all other attributes. Declaration public ICUCollationAttributeFactory(Collator collator) Parameters Type Name Description ICU4N.Text.Collator collator ICU4N.Text.CollationKey generator | Improve this Doc View Source ICUCollationAttributeFactory(AttributeSource.AttributeFactory, Collator) Create an ICUCollationAttributeFactory , using the supplied Attribute Factory as the factory for all other attributes. Declaration public ICUCollationAttributeFactory(AttributeSource.AttributeFactory delegate, Collator collator) Parameters Type Name Description Lucene.Net.Util.AttributeSource.AttributeFactory delegate Attribute Factory ICU4N.Text.Collator collator ICU4N.Text.CollationKey generator Methods | Improve this Doc View Source CreateAttributeInstance<T>() Declaration public override Attribute CreateAttributeInstance<T>() where T : IAttribute Returns Type Description Lucene.Net.Util.Attribute Type Parameters Name Description T Overrides Lucene.Net.Util.AttributeSource.AttributeFactory.CreateAttributeInstance<T>()"
  },
  "Lucene.Net.Collation.ICUCollationDocValuesField.html": {
    "href": "Lucene.Net.Collation.ICUCollationDocValuesField.html",
    "title": "Class ICUCollationDocValuesField | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Class ICUCollationDocValuesField Indexes sort keys as a single-valued SortedDocValuesField . Inheritance System.Object Lucene.Net.Documents.Field ICUCollationDocValuesField Implements Lucene.Net.Index.IIndexableField Inherited Members Lucene.Net.Documents.Field.m_type Lucene.Net.Documents.Field.m_name Lucene.Net.Documents.Field.FieldsData Lucene.Net.Documents.Field.m_tokenStream Lucene.Net.Documents.Field.m_boost Lucene.Net.Documents.Field.GetStringValue() Field.GetStringValue(IFormatProvider) Field.GetStringValue(String) Field.GetStringValue(String, IFormatProvider) Lucene.Net.Documents.Field.GetReaderValue() Lucene.Net.Documents.Field.GetTokenStreamValue() Field.SetReaderValue(TextReader) Lucene.Net.Documents.Field.SetBytesValue(Lucene.Net.Util.BytesRef) Field.SetBytesValue(Byte[]) Field.SetByteValue(Byte) Field.SetInt16Value(Int16) Field.SetInt32Value(Int32) Field.SetInt64Value(Int64) Field.SetSingleValue(Single) Field.SetDoubleValue(Double) Lucene.Net.Documents.Field.SetTokenStream(Lucene.Net.Analysis.TokenStream) Lucene.Net.Documents.Field.Boost Lucene.Net.Documents.Field.GetNumericValue() Lucene.Net.Documents.Field.NumericType Lucene.Net.Documents.Field.GetByteValue() Lucene.Net.Documents.Field.GetInt16Value() Lucene.Net.Documents.Field.GetInt32Value() Lucene.Net.Documents.Field.GetInt64Value() Lucene.Net.Documents.Field.GetSingleValue() Lucene.Net.Documents.Field.GetDoubleValue() Lucene.Net.Documents.Field.GetBinaryValue() Lucene.Net.Documents.Field.ToString() Lucene.Net.Documents.Field.FieldType Lucene.Net.Documents.Field.IndexableFieldType Lucene.Net.Documents.Field.GetTokenStream(Lucene.Net.Analysis.Analyzer) Lucene.Net.Documents.Field.TranslateFieldType(Lucene.Net.Documents.Field.Store, Lucene.Net.Documents.Field.Index, Lucene.Net.Documents.Field.TermVector) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Lucene.Net.Collation Assembly : Lucene.Net.ICU.dll Syntax public sealed class ICUCollationDocValuesField : Field, IIndexableField Remarks This is more efficient that ICUCollationKeyAnalyzer if the field only has one value: no uninversion is necessary to sort on the field, locale-sensitive range queries can still work via FieldCacheRangeFilter , and the underlying data structures built at index-time are likely more efficient and use less memory than FieldCache. Constructors | Improve this Doc View Source ICUCollationDocValuesField(String, Collator) Create a new ICUCollationDocValuesField . NOTE: you should not create a new one for each document, instead just make one and reuse it during your indexing process, setting the value via SetStringValue(String) . Declaration public ICUCollationDocValuesField(string name, Collator collator) Parameters Type Name Description System.String name Field name. ICU4N.Text.Collator collator Collator for generating collation keys. Properties | Improve this Doc View Source Name Declaration public override string Name { get; } Property Value Type Description System.String Overrides Lucene.Net.Documents.Field.Name Methods | Improve this Doc View Source SetStringValue(String) Declaration public override void SetStringValue(string value) Parameters Type Name Description System.String value Overrides Field.SetStringValue(String) Implements Lucene.Net.Index.IIndexableField"
  },
  "Lucene.Net.Collation.ICUCollationKeyAnalyzer.html": {
    "href": "Lucene.Net.Collation.ICUCollationKeyAnalyzer.html",
    "title": "Class ICUCollationKeyAnalyzer | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Class ICUCollationKeyAnalyzer Configures Lucene.Net.Analysis.Core.KeywordTokenizer with ICUCollationAttributeFactory . Inheritance System.Object Lucene.Net.Analysis.Analyzer ICUCollationKeyAnalyzer Implements System.IDisposable Inherited Members Analyzer.NewAnonymous(Func<String, TextReader, TokenStreamComponents>) Analyzer.NewAnonymous(Func<String, TextReader, TokenStreamComponents>, ReuseStrategy) Analyzer.NewAnonymous(Func<String, TextReader, TokenStreamComponents>, Func<String, TextReader, TextReader>) Analyzer.NewAnonymous(Func<String, TextReader, TokenStreamComponents>, Func<String, TextReader, TextReader>, ReuseStrategy) Analyzer.GetTokenStream(String, TextReader) Analyzer.GetTokenStream(String, String) Analyzer.InitReader(String, TextReader) Analyzer.GetPositionIncrementGap(String) Analyzer.GetOffsetGap(String) Lucene.Net.Analysis.Analyzer.Strategy Lucene.Net.Analysis.Analyzer.Dispose() Analyzer.Dispose(Boolean) Lucene.Net.Analysis.Analyzer.GLOBAL_REUSE_STRATEGY Lucene.Net.Analysis.Analyzer.PER_FIELD_REUSE_STRATEGY System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Lucene.Net.Collation Assembly : Lucene.Net.ICU.dll Syntax public sealed class ICUCollationKeyAnalyzer : Analyzer, IDisposable Remarks Converts the token into its ICU4N.Text.CollationKey , and then encodes the ICU4N.Text.CollationKey either directly or with IndexableBinaryStringTools (see below ), to allow it to be stored as an index term. WARNING: Make sure you use exactly the same ICU4N.Text.Collator at index and query time -- CollationKeys are only comparable when produced by the same ICU4N.Text.Collator . ICU4N.Text.RuleBasedCollator s are independently versioned, so it is safe to search against stored ICU4N.Text.CollationKey s if the following are exactly the same (best practice is to store this information with the index and check that they remain the same at query time): Collator version - see ICU4N.Text.Collator Version The collation strength used - see ICU4N.Text.Collator.Strength ICU4N.Text.CollationKey s generated by ICU Collators are not compatible with those generated by java.text.Collators. Specifically, if you use ICUCollationKeyAnalyzer to generate index terms, do not use CollationKeyAnalyzer on the query side, or vice versa. ICUCollationKeyAnalyzer is significantly faster and generates significantly shorter keys than CollationKeyAnalyzer. See http://site.icu-project.org/charts/collation-icu4j-sun for key generation timing and key length comparisons between ICU4J and java.text.Collator over several languages. You must specify the required Lucene.Net.Util.LuceneVersion compatibility when creating ICUCollationKeyAnalyzer : As of 4.0, ICU4N.Text.CollationKey s are directly encoded as bytes. Previous versions will encode the bytes with IndexableBinaryStringTools . Constructors | Improve this Doc View Source ICUCollationKeyAnalyzer(Collator) Declaration [Obsolete(\"Use ICUCollationKeyAnalyzer.ICUCollationKeyAnalyzer(LuceneVersion, Collator) and specify a version instead. This ctor will be removed in Lucene 5.0\")] public ICUCollationKeyAnalyzer(Collator collator) Parameters Type Name Description ICU4N.Text.Collator collator | Improve this Doc View Source ICUCollationKeyAnalyzer(LuceneVersion, Collator) Create a new ICUCollationKeyAnalyzer , using the specified collator . Declaration public ICUCollationKeyAnalyzer(LuceneVersion matchVersion, Collator collator) Parameters Type Name Description Lucene.Net.Util.LuceneVersion matchVersion See ICUCollationKeyAnalyzer . ICU4N.Text.Collator collator ICU4N.Text.CollationKey generator. Methods | Improve this Doc View Source CreateComponents(String, TextReader) Declaration protected override TokenStreamComponents CreateComponents(string fieldName, TextReader reader) Parameters Type Name Description System.String fieldName System.IO.TextReader reader Returns Type Description Lucene.Net.Analysis.TokenStreamComponents Overrides Analyzer.CreateComponents(String, TextReader) Implements System.IDisposable"
  },
  "Lucene.Net.Collation.ICUCollationKeyFilter.html": {
    "href": "Lucene.Net.Collation.ICUCollationKeyFilter.html",
    "title": "Class ICUCollationKeyFilter | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Class ICUCollationKeyFilter Converts each token into its ICU4N.Text.CollationKey , and then encodes the ICU4N.Text.CollationKey with IndexableBinaryStringTools , to allow it to be stored as an index term. Inheritance System.Object Lucene.Net.Util.AttributeSource Lucene.Net.Analysis.TokenStream Lucene.Net.Analysis.TokenFilter ICUCollationKeyFilter Implements System.IDisposable Inherited Members Lucene.Net.Analysis.TokenFilter.m_input Lucene.Net.Analysis.TokenFilter.End() TokenFilter.Dispose(Boolean) Lucene.Net.Analysis.TokenFilter.Reset() Lucene.Net.Analysis.TokenStream.Dispose() Lucene.Net.Util.AttributeSource.GetAttributeFactory() Lucene.Net.Util.AttributeSource.GetAttributeClassesEnumerator() Lucene.Net.Util.AttributeSource.GetAttributeImplsEnumerator() Lucene.Net.Util.AttributeSource.AddAttributeImpl(Lucene.Net.Util.Attribute) Lucene.Net.Util.AttributeSource.AddAttribute<T>() Lucene.Net.Util.AttributeSource.HasAttributes Lucene.Net.Util.AttributeSource.HasAttribute<T>() Lucene.Net.Util.AttributeSource.GetAttribute<T>() Lucene.Net.Util.AttributeSource.ClearAttributes() Lucene.Net.Util.AttributeSource.CaptureState() Lucene.Net.Util.AttributeSource.RestoreState(Lucene.Net.Util.AttributeSource.State) Lucene.Net.Util.AttributeSource.GetHashCode() AttributeSource.Equals(Object) AttributeSource.ReflectAsString(Boolean) Lucene.Net.Util.AttributeSource.ReflectWith(Lucene.Net.Util.IAttributeReflector) Lucene.Net.Util.AttributeSource.CloneAttributes() Lucene.Net.Util.AttributeSource.CopyTo(Lucene.Net.Util.AttributeSource) Lucene.Net.Util.AttributeSource.ToString() System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Lucene.Net.Collation Assembly : Lucene.Net.ICU.dll Syntax [Obsolete(\"Use ICUCollationAttributeFactory instead, which encodes terms directly as bytes. This filter will be removed in Lucene 5.0\")] public sealed class ICUCollationKeyFilter : TokenFilter, IDisposable Remarks WARNING: Make sure you use exactly the same ICU4N.Text.Collator at index and query time -- CollationKeys are only comparable when produced by the same ICU4N.Text.Collator . ICU4N.Text.RuleBasedCollator s are independently versioned, so it is safe to search against stored ICU4N.Text.CollationKey s if the following are exactly the same (best practice is to store this information with the index and check that they remain the same at query time): Collator version - see ICU4N.Text.Collator Version The collation strength used - see ICU4N.Text.Collator.Strength ICU4N.Text.CollationKey s generated by ICU Collators are not compatible with those generated by java.text.Collators. Specifically, if you use ICUCollationKeyAnalyzer to generate index terms, do not use CollationKeyAnalyzer on the query side, or vice versa. ICUCollationKeyAnalyzer is significantly faster and generates significantly shorter keys than CollationKeyAnalyzer. See http://site.icu-project.org/charts/collation-icu4j-sun for key generation timing and key length comparisons between ICU4J and java.text.Collator over several languages. Constructors | Improve this Doc View Source ICUCollationKeyFilter(TokenStream, Collator) Creates a new ICUCollationKeyFilter . Declaration public ICUCollationKeyFilter(TokenStream input, Collator collator) Parameters Type Name Description Lucene.Net.Analysis.TokenStream input Source token stream. ICU4N.Text.Collator collator ICU4N.Text.CollationKey generator. Methods | Improve this Doc View Source IncrementToken() Declaration public override bool IncrementToken() Returns Type Description System.Boolean Overrides Lucene.Net.Analysis.TokenStream.IncrementToken() Implements System.IDisposable"
  },
  "Lucene.Net.Collation.ICUCollationKeyFilterFactory.html": {
    "href": "Lucene.Net.Collation.ICUCollationKeyFilterFactory.html",
    "title": "Class ICUCollationKeyFilterFactory | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Class ICUCollationKeyFilterFactory Factory for ICUCollationKeyFilter . Inheritance System.Object Lucene.Net.Analysis.Util.AbstractAnalysisFactory Lucene.Net.Analysis.Util.TokenFilterFactory ICUCollationKeyFilterFactory Implements Lucene.Net.Analysis.Util.IMultiTermAwareComponent Lucene.Net.Analysis.Util.IResourceLoaderAware Inherited Members Lucene.Net.Analysis.Util.TokenFilterFactory.ForName(System.String, System.Collections.Generic.IDictionary<System.String, System.String>) Lucene.Net.Analysis.Util.TokenFilterFactory.LookupClass(System.String) Lucene.Net.Analysis.Util.TokenFilterFactory.AvailableTokenFilters Lucene.Net.Analysis.Util.TokenFilterFactory.ReloadTokenFilters() Lucene.Net.Analysis.Util.AbstractAnalysisFactory.LUCENE_MATCH_VERSION_PARAM Lucene.Net.Analysis.Util.AbstractAnalysisFactory.m_luceneMatchVersion Lucene.Net.Analysis.Util.AbstractAnalysisFactory.OriginalArgs Lucene.Net.Analysis.Util.AbstractAnalysisFactory.AssureMatchVersion() Lucene.Net.Analysis.Util.AbstractAnalysisFactory.LuceneMatchVersion Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Require(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Require(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Require(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Get(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Get(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Get(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.Get(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Collections.Generic.ICollection<System.String>, System.String, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.RequireInt32(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetInt32(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Int32) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.RequireBoolean(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetBoolean(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.RequireSingle(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetSingle(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Single) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.RequireChar(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetChar(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Char) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetSet(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetPattern(System.Collections.Generic.IDictionary<System.String, System.String>, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetCulture(System.Collections.Generic.IDictionary<System.String, System.String>, System.String, System.Globalization.CultureInfo) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetWordSet(Lucene.Net.Analysis.Util.IResourceLoader, System.String, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetLines(Lucene.Net.Analysis.Util.IResourceLoader, System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetSnowballWordSet(Lucene.Net.Analysis.Util.IResourceLoader, System.String, System.Boolean) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.SplitFileNames(System.String) Lucene.Net.Analysis.Util.AbstractAnalysisFactory.GetClassArg() Lucene.Net.Analysis.Util.AbstractAnalysisFactory.IsExplicitLuceneMatchVersion System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Lucene.Net.Collation Assembly : Lucene.Net.ICU.dll Syntax [Obsolete(\"Use ICUCollationKeyAnalyzer instead.\")] public class ICUCollationKeyFilterFactory : TokenFilterFactory, IMultiTermAwareComponent, IResourceLoaderAware Remarks This factory can be created in two ways: Based upon a system collator associated with a Locale. Based upon a tailored ruleset. Using a System collator: locale: RFC 3066 locale ID (mandatory) strength: 'primary','secondary','tertiary', 'quaternary', or 'identical' (optional) decomposition: 'no', or 'canonical' (optional) Using a Tailored ruleset: custom: UTF-8 text file containing rules supported by RuleBasedCollator (mandatory) strength: 'primary','secondary','tertiary', 'quaternary', or 'identical' (optional) decomposition: 'no' or 'canonical' (optional) Expert options: alternate: 'shifted' or 'non-ignorable'. Can be used to ignore punctuation/whitespace. caseLevel: 'true' or 'false'. Useful with strength=primary to ignore accents but not case. caseFirst: 'lower' or 'upper'. Useful to control which is sorted first when case is not ignored. numeric: 'true' or 'false'. Digits are sorted according to numeric value, e.g. foobar-9 sorts before foobar-10 Constructors | Improve this Doc View Source ICUCollationKeyFilterFactory(IDictionary<String, String>) Declaration public ICUCollationKeyFilterFactory(IDictionary<string, string> args) Parameters Type Name Description System.Collections.Generic.IDictionary < System.String , System.String > args Methods | Improve this Doc View Source Create(TokenStream) Declaration public override TokenStream Create(TokenStream input) Parameters Type Name Description Lucene.Net.Analysis.TokenStream input Returns Type Description Lucene.Net.Analysis.TokenStream Overrides Lucene.Net.Analysis.Util.TokenFilterFactory.Create(Lucene.Net.Analysis.TokenStream) | Improve this Doc View Source GetMultiTermComponent() Declaration public virtual AbstractAnalysisFactory GetMultiTermComponent() Returns Type Description Lucene.Net.Analysis.Util.AbstractAnalysisFactory | Improve this Doc View Source Inform(IResourceLoader) Declaration public virtual void Inform(IResourceLoader loader) Parameters Type Name Description Lucene.Net.Analysis.Util.IResourceLoader loader Implements Lucene.Net.Analysis.Util.IMultiTermAwareComponent Lucene.Net.Analysis.Util.IResourceLoaderAware See Also ICU4N.Text.Collator ICU4N.Text.RuleBasedCollator"
  },
  "Lucene.Net.Collation.TokenAttributes.html": {
    "href": "Lucene.Net.Collation.TokenAttributes.html",
    "title": "Namespace Lucene.Net.Collation.TokenAttributes | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Namespace Lucene.Net.Collation.TokenAttributes <!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. --> Custom <xref:Lucene.Net.Util.AttributeImpl> for indexing collation keys as index terms. Classes ICUCollatedTermAttribute Extension of Lucene.Net.Analysis.TokenAttributes.CharTermAttribute that encodes the term text as a binary Unicode collation key instead of as UTF-8 bytes."
  },
  "Lucene.Net.Collation.TokenAttributes.ICUCollatedTermAttribute.html": {
    "href": "Lucene.Net.Collation.TokenAttributes.ICUCollatedTermAttribute.html",
    "title": "Class ICUCollatedTermAttribute | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Class ICUCollatedTermAttribute Extension of Lucene.Net.Analysis.TokenAttributes.CharTermAttribute that encodes the term text as a binary Unicode collation key instead of as UTF-8 bytes. Inheritance System.Object Lucene.Net.Util.Attribute Lucene.Net.Analysis.TokenAttributes.CharTermAttribute ICUCollatedTermAttribute Implements Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute J2N.Text.ICharSequence Lucene.Net.Analysis.TokenAttributes.ITermToBytesRefAttribute Lucene.Net.Util.IAttribute J2N.Text.IAppendable Inherited Members Lucene.Net.Analysis.TokenAttributes.CharTermAttribute.J2N.Text.ICharSequence.HasValue CharTermAttribute.CopyBuffer(Char[], Int32, Int32) Lucene.Net.Analysis.TokenAttributes.CharTermAttribute.Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Buffer Lucene.Net.Analysis.TokenAttributes.CharTermAttribute.Buffer CharTermAttribute.ResizeBuffer(Int32) Lucene.Net.Analysis.TokenAttributes.CharTermAttribute.Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Length Lucene.Net.Analysis.TokenAttributes.CharTermAttribute.J2N.Text.ICharSequence.Length Lucene.Net.Analysis.TokenAttributes.CharTermAttribute.Length CharTermAttribute.SetLength(Int32) Lucene.Net.Analysis.TokenAttributes.CharTermAttribute.SetEmpty() Lucene.Net.Analysis.TokenAttributes.CharTermAttribute.BytesRef CharTermAttribute.ICharSequence.Item[Int32] CharTermAttribute.ICharTermAttribute.Item[Int32] CharTermAttribute.Item[Int32] CharTermAttribute.Subsequence(Int32, Int32) CharTermAttribute.Append(String, Int32, Int32) CharTermAttribute.Append(Char) CharTermAttribute.Append(Char[]) CharTermAttribute.Append(Char[], Int32, Int32) CharTermAttribute.Append(String) CharTermAttribute.Append(StringBuilder) CharTermAttribute.Append(StringBuilder, Int32, Int32) Lucene.Net.Analysis.TokenAttributes.CharTermAttribute.Append(Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute) CharTermAttribute.Append(ICharSequence) CharTermAttribute.Append(ICharSequence, Int32, Int32) Lucene.Net.Analysis.TokenAttributes.CharTermAttribute.GetHashCode() Lucene.Net.Analysis.TokenAttributes.CharTermAttribute.Clear() Lucene.Net.Analysis.TokenAttributes.CharTermAttribute.Clone() CharTermAttribute.Equals(Object) Lucene.Net.Analysis.TokenAttributes.CharTermAttribute.ToString() Lucene.Net.Analysis.TokenAttributes.CharTermAttribute.ReflectWith(Lucene.Net.Util.IAttributeReflector) Lucene.Net.Analysis.TokenAttributes.CharTermAttribute.CopyTo(Lucene.Net.Util.IAttribute) CharTermAttribute.ICharTermAttribute.CopyBuffer(Char[], Int32, Int32) CharTermAttribute.ICharTermAttribute.ResizeBuffer(Int32) CharTermAttribute.ICharTermAttribute.SetLength(Int32) Lucene.Net.Analysis.TokenAttributes.CharTermAttribute.Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.SetEmpty() CharTermAttribute.ICharTermAttribute.Append(ICharSequence) CharTermAttribute.ICharTermAttribute.Append(ICharSequence, Int32, Int32) CharTermAttribute.ICharTermAttribute.Append(Char) CharTermAttribute.ICharTermAttribute.Append(Char[]) CharTermAttribute.ICharTermAttribute.Append(Char[], Int32, Int32) CharTermAttribute.ICharTermAttribute.Append(String) CharTermAttribute.ICharTermAttribute.Append(String, Int32, Int32) CharTermAttribute.ICharTermAttribute.Append(StringBuilder) CharTermAttribute.ICharTermAttribute.Append(StringBuilder, Int32, Int32) Lucene.Net.Analysis.TokenAttributes.CharTermAttribute.Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Append(Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute) CharTermAttribute.IAppendable.Append(Char) CharTermAttribute.IAppendable.Append(String) CharTermAttribute.IAppendable.Append(String, Int32, Int32) CharTermAttribute.IAppendable.Append(StringBuilder) CharTermAttribute.IAppendable.Append(StringBuilder, Int32, Int32) CharTermAttribute.IAppendable.Append(Char[]) CharTermAttribute.IAppendable.Append(Char[], Int32, Int32) CharTermAttribute.IAppendable.Append(ICharSequence) CharTermAttribute.IAppendable.Append(ICharSequence, Int32, Int32) Attribute.ReflectAsString(Boolean) System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Lucene.Net.Collation.TokenAttributes Assembly : Lucene.Net.ICU.dll Syntax public class ICUCollatedTermAttribute : CharTermAttribute, ICharTermAttribute, ICharSequence, ITermToBytesRefAttribute, IAttribute, IAppendable Constructors | Improve this Doc View Source ICUCollatedTermAttribute(Collator) Create a new ICUCollatedTermAttribute Declaration public ICUCollatedTermAttribute(Collator collator) Parameters Type Name Description ICU4N.Text.Collator collator Collation key generator. Methods | Improve this Doc View Source FillBytesRef() Declaration public override void FillBytesRef() Overrides Lucene.Net.Analysis.TokenAttributes.CharTermAttribute.FillBytesRef() Implements Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute J2N.Text.ICharSequence Lucene.Net.Analysis.TokenAttributes.ITermToBytesRefAttribute Lucene.Net.Util.IAttribute J2N.Text.IAppendable"
  },
  "Lucene.Net.Documents.DocumentExtensions.html": {
    "href": "Lucene.Net.Documents.DocumentExtensions.html",
    "title": "Class DocumentExtensions | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Class DocumentExtensions LUCENENET specific extensions to the Lucene.Net.Documents.Document class. Inheritance System.Object DocumentExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Lucene.Net.Documents Assembly : Lucene.Net.ICU.dll Syntax public static class DocumentExtensions Methods | Improve this Doc View Source AddICUCollationDocValuesField(Document, String, Collator) Adds a new ICUCollationDocValuesField . NOTE: you should not create a new one for each document, instead just make one and reuse it during your indexing process, setting the value via SetStringValue(String) . Declaration public static ICUCollationDocValuesField AddICUCollationDocValuesField(this Document document, string name, Collator collator) Parameters Type Name Description Lucene.Net.Documents.Document document This Lucene.Net.Documents.Document . System.String name Field name. ICU4N.Text.Collator collator Collator for generating collation keys. Returns Type Description ICUCollationDocValuesField The field that was added to this Lucene.Net.Documents.Document ."
  },
  "Lucene.Net.Documents.html": {
    "href": "Lucene.Net.Documents.html",
    "title": "Namespace Lucene.Net.Documents | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Namespace Lucene.Net.Documents Classes DocumentExtensions LUCENENET specific extensions to the Lucene.Net.Documents.Document class."
  },
  "Lucene.Net.Search.PostingsHighlight.DefaultPassageFormatter.html": {
    "href": "Lucene.Net.Search.PostingsHighlight.DefaultPassageFormatter.html",
    "title": "Class DefaultPassageFormatter | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Class DefaultPassageFormatter Creates a formatted snippet from the top passages. The default implementation marks the query terms as bold, and places ellipses between unconnected passages. Inheritance System.Object PassageFormatter DefaultPassageFormatter Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Lucene.Net.Search.PostingsHighlight Assembly : Lucene.Net.ICU.dll Syntax public class DefaultPassageFormatter : PassageFormatter Constructors | Improve this Doc View Source DefaultPassageFormatter() Creates a new DefaultPassageFormatter with the default tags. Declaration public DefaultPassageFormatter() | Improve this Doc View Source DefaultPassageFormatter(String, String, String, Boolean) Creates a new DefaultPassageFormatter with custom tags. Declaration public DefaultPassageFormatter(string preTag, string postTag, string ellipsis, bool escape) Parameters Type Name Description System.String preTag text which should appear before a highlighted term. System.String postTag text which should appear after a highlighted term. System.String ellipsis text which should be used to connect two unconnected passages. System.Boolean escape true if text should be html-escaped Fields | Improve this Doc View Source m_ellipsis text that will appear between two unconnected passages Declaration protected readonly string m_ellipsis Field Value Type Description System.String | Improve this Doc View Source m_escape true if we should escape for html Declaration protected readonly bool m_escape Field Value Type Description System.Boolean | Improve this Doc View Source m_postTag text that will appear after highlighted terms Declaration protected readonly string m_postTag Field Value Type Description System.String | Improve this Doc View Source m_preTag text that will appear before highlighted terms Declaration protected readonly string m_preTag Field Value Type Description System.String Methods | Improve this Doc View Source Append(StringBuilder, String, Int32, Int32) Appends original text to the response. Declaration protected virtual void Append(StringBuilder dest, string content, int start, int end) Parameters Type Name Description System.Text.StringBuilder dest resulting text, possibly transformed or encoded System.String content original text content System.Int32 start index of the first character in content System.Int32 end index of the character following the last character in content | Improve this Doc View Source Format(Passage[], String) Declaration public override object Format(Passage[] passages, string content) Parameters Type Name Description Passage [] passages System.String content Returns Type Description System.Object Overrides PassageFormatter.Format(Passage[], String)"
  },
  "Lucene.Net.Search.PostingsHighlight.html": {
    "href": "Lucene.Net.Search.PostingsHighlight.html",
    "title": "Namespace Lucene.Net.Search.PostingsHighlight | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Namespace Lucene.Net.Search.PostingsHighlight Classes DefaultPassageFormatter Creates a formatted snippet from the top passages. The default implementation marks the query terms as bold, and places ellipses between unconnected passages. ICUPostingsHighlighter Simple highlighter that does not analyze fields nor use term vectors. Instead it requires DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS . Passage Represents a passage (typically a sentence of the document). A passage contains NumMatches highlights from the query, and the offsets and query terms that correspond with each match. This is a Lucene.NET EXPERIMENTAL API, use at your own risk PassageFormatter Creates a formatted snippet from the top passages. This is a Lucene.NET EXPERIMENTAL API, use at your own risk PassageScorer Ranks passages found by ICUPostingsHighlighter . Each passage is scored as a miniature document within the document. The final score is computed as norm * ∑ ( weight * tf ). The default implementation is norm * BM25. This is a Lucene.NET EXPERIMENTAL API, use at your own risk WholeBreakIterator Just produces one single fragment for the entire text"
  },
  "Lucene.Net.Search.PostingsHighlight.ICUPostingsHighlighter.html": {
    "href": "Lucene.Net.Search.PostingsHighlight.ICUPostingsHighlighter.html",
    "title": "Class ICUPostingsHighlighter | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Class ICUPostingsHighlighter Simple highlighter that does not analyze fields nor use term vectors. Instead it requires DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS . Inheritance System.Object ICUPostingsHighlighter Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Lucene.Net.Search.PostingsHighlight Assembly : Lucene.Net.ICU.dll Syntax public class ICUPostingsHighlighter Remarks PostingsHighlighter treats the single original document as the whole corpus, and then scores individual passages as if they were documents in this corpus. It uses a ICU4N.Text.BreakIterator to find passages in the text; by default it breaks using ICU4N.Text.BreakIterator.GetSentenceInstance(System.Globalization.CultureInfo) (for sentence breaking). It then iterates in parallel (merge sorting by offset) through the positions of all terms from the query, coalescing those hits that occur in a single passage into a Passage , and then scores each Passage using a separate PassageScorer . Passages are finally formatted into highlighted snippets with a PassageFormatter . You can customize the behavior by subclassing this highlighter, some important hooks: GetBreakIterator(String) : Customize how the text is divided into passages. GetScorer(String) : Customize how passages are ranked. GetFormatter(String) : Customize how snippets are formatted. GetIndexAnalyzer(String) : Enable highlighting of MultiTermQuerys such as WildcardQuery . WARNING : The code is very new and probably still has some exciting bugs! Example usage: // configure field with offsets at index time IndexableFieldType offsetsType = new IndexableFieldType(TextField.TYPE_STORED); offsetsType.IndexOptions = IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS; Field body = new Field(\"body\", \"foobar\", offsetsType); // retrieve highlights at query time ICUPostingsHighlighter highlighter = new ICUPostingsHighlighter(); Query query = new TermQuery(new Term(\"body\", \"highlighting\")); TopDocs topDocs = searcher.Search(query, n); string highlights[] = highlighter.Highlight(\"body\", query, searcher, topDocs); This is thread-safe, and can be used across different readers. Note that the .NET implementation differs from the PostingsHighlighter in Lucene in that it is backed by an ICU ICU4N.Text.RuleBasedBreakIterator , which differs slightly in default behavior than the one in the JDK. However, the ICU ICU4N.Text.RuleBasedBreakIterator behavior can be customized to meet a lot of scenarios that the one in the JDK cannot. See the ICU documentation at http://userguide.icu-project.org/boundaryanalysis/break-rules for more information how to pass custom rules to an ICU ICU4N.Text.RuleBasedBreakIterator . This is a Lucene.NET EXPERIMENTAL API, use at your own risk Constructors | Improve this Doc View Source ICUPostingsHighlighter() Creates a new highlighter with DEFAULT_MAX_LENGTH . Declaration public ICUPostingsHighlighter() | Improve this Doc View Source ICUPostingsHighlighter(Int32) Creates a new highlighter, specifying maximum content length. Declaration public ICUPostingsHighlighter(int maxLength) Parameters Type Name Description System.Int32 maxLength maximum content size to process. Exceptions Type Condition System.ArgumentException if maxLength is negative or int.MaxValue Fields | Improve this Doc View Source DEFAULT_MAX_LENGTH Default maximum content size to process. Typically snippets closer to the beginning of the document better summarize its content Declaration public static readonly int DEFAULT_MAX_LENGTH Field Value Type Description System.Int32 Methods | Improve this Doc View Source GetBreakIterator(String) Returns the ICU4N.Text.BreakIterator to use for dividing text into passages. This instantiates an ICU4N.Text.BreakIterator.GetSentenceInstance(System.Globalization.CultureInfo) by default; subclasses can override to customize. Declaration protected virtual BreakIterator GetBreakIterator(string field) Parameters Type Name Description System.String field Returns Type Description ICU4N.Text.BreakIterator | Improve this Doc View Source GetEmptyHighlight(String, BreakIterator, Int32) Called to summarize a document when no hits were found. By default this just returns the first maxPassages sentences; subclasses can override to customize. Declaration protected virtual Passage[] GetEmptyHighlight(string fieldName, BreakIterator bi, int maxPassages) Parameters Type Name Description System.String fieldName ICU4N.Text.BreakIterator bi System.Int32 maxPassages Returns Type Description Passage [] | Improve this Doc View Source GetFormatter(String) Returns the PassageFormatter to use for formatting passages into highlighted snippets. This returns a new PassageFormatter by default; subclasses can override to customize. Declaration protected virtual PassageFormatter GetFormatter(string field) Parameters Type Name Description System.String field Returns Type Description PassageFormatter | Improve this Doc View Source GetIndexAnalyzer(String) Returns the analyzer originally used to index the content for field . This is used to highlight some MultiTermQuery s. Declaration protected virtual Analyzer GetIndexAnalyzer(string field) Parameters Type Name Description System.String field Returns Type Description Lucene.Net.Analysis.Analyzer Lucene.Net.Analysis.Analyzer or null (the default, meaning no special multi-term processing) | Improve this Doc View Source GetMultiValuedSeparator(String) Returns the logical separator between values for multi-valued fields. The default value is a space character, which means passages can span across values, but a subclass can override, for example with U+2029 PARAGRAPH SEPARATOR (PS) if each value holds a discrete passage for highlighting. Declaration protected virtual char GetMultiValuedSeparator(string field) Parameters Type Name Description System.String field Returns Type Description System.Char | Improve this Doc View Source GetScorer(String) Returns the PassageScorer to use for ranking passages. This returns a new PassageScorer by default; subclasses can override to customize. Declaration protected virtual PassageScorer GetScorer(string field) Parameters Type Name Description System.String field Returns Type Description PassageScorer | Improve this Doc View Source Highlight(String, Query, IndexSearcher, TopDocs) Highlights the top passages from a single field. Declaration public virtual string[] Highlight(string field, Query query, IndexSearcher searcher, TopDocs topDocs) Parameters Type Name Description System.String field field name to highlight. Must have a stored string value and also be indexed with offsets. Lucene.Net.Search.Query query query to highlight. Lucene.Net.Search.IndexSearcher searcher searcher that was previously used to execute the query. Lucene.Net.Search.TopDocs topDocs TopDocs containing the summary result documents to highlight. Returns Type Description System.String [] Array of formatted snippets corresponding to the documents in topDocs . If no highlights were found for a document, the first sentence for the field will be returned. Exceptions Type Condition System.IO.IOException if an I/O error occurred during processing System.ArgumentException if field was indexed without DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS | Improve this Doc View Source Highlight(String, Query, IndexSearcher, TopDocs, Int32) Highlights the top-N passages from a single field. Declaration public virtual string[] Highlight(string field, Query query, IndexSearcher searcher, TopDocs topDocs, int maxPassages) Parameters Type Name Description System.String field field name to highlight. Must have a stored string value and also be indexed with offsets. Lucene.Net.Search.Query query query to highlight. Lucene.Net.Search.IndexSearcher searcher searcher that was previously used to execute the query. Lucene.Net.Search.TopDocs topDocs TopDocs containing the summary result documents to highlight. System.Int32 maxPassages The maximum number of top-N ranked passages used to form the highlighted snippets. Returns Type Description System.String [] Array of formatted snippets corresponding to the documents in topDocs . If no highlights were found for a document, the first maxPassages sentences from the field will be returned. Exceptions Type Condition System.IO.IOException if an I/O error occurred during processing System.ArgumentException Illegal if field was indexed without DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS | Improve this Doc View Source HighlightFields(String[], Query, IndexSearcher, TopDocs) Highlights the top passages from multiple fields. Conceptually, this behaves as a more efficient form of: IDictionary<string, string[]> m = new Dictionary<string, string[]>(); foreach (string field in fields) { m[field] = Highlight(field, query, searcher, topDocs); } return m; Declaration public virtual IDictionary<string, string[]> HighlightFields(string[] fields, Query query, IndexSearcher searcher, TopDocs topDocs) Parameters Type Name Description System.String [] fields field names to highlight. Must have a stored string value and also be indexed with offsets. Lucene.Net.Search.Query query query to highlight. Lucene.Net.Search.IndexSearcher searcher searcher that was previously used to execute the query. Lucene.Net.Search.TopDocs topDocs TopDocs containing the summary result documents to highlight. Returns Type Description System.Collections.Generic.IDictionary < System.String , System.String []> keyed on field name, containing the array of formatted snippets corresponding to the documents in topDocs . If no highlights were found for a document, the first sentence from the field will be returned. Exceptions Type Condition System.IO.IOException if an I/O error occurred during processing System.ArgumentException if field was indexed without DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS | Improve this Doc View Source HighlightFields(String[], Query, IndexSearcher, TopDocs, Int32[]) Highlights the top-N passages from multiple fields. Conceptually, this behaves as a more efficient form of: IDictionary<string, string[]> m = new Dictionary<string, string[]>(); foreach (string field in fields) { m[field] = Highlight(field, query, searcher, topDocs, maxPassages); } return m; Declaration public virtual IDictionary<string, string[]> HighlightFields(string[] fields, Query query, IndexSearcher searcher, TopDocs topDocs, int[] maxPassages) Parameters Type Name Description System.String [] fields field names to highlight. Must have a stored string value and also be indexed with offsets. Lucene.Net.Search.Query query query to highlight. Lucene.Net.Search.IndexSearcher searcher searcher that was previously used to execute the query. Lucene.Net.Search.TopDocs topDocs TopDocs containing the summary result documents to highlight. System.Int32 [] maxPassages The maximum number of top-N ranked passages per-field used to form the highlighted snippets. Returns Type Description System.Collections.Generic.IDictionary < System.String , System.String []> keyed on field name, containing the array of formatted snippets corresponding to the documents in topDocs . If no highlights were found for a document, the first maxPassages sentences from the field will be returned. Exceptions Type Condition System.IO.IOException if an I/O error occurred during processing System.ArgumentException if field was indexed without DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS | Improve this Doc View Source HighlightFields(String[], Query, IndexSearcher, Int32[], Int32[]) Highlights the top-N passages from multiple fields, for the provided int[] docids. Declaration public virtual IDictionary<string, string[]> HighlightFields(string[] fieldsIn, Query query, IndexSearcher searcher, int[] docidsIn, int[] maxPassagesIn) Parameters Type Name Description System.String [] fieldsIn field names to highlight. Must have a stored string value and also be indexed with offsets. Lucene.Net.Search.Query query query to highlight. Lucene.Net.Search.IndexSearcher searcher searcher that was previously used to execute the query. System.Int32 [] docidsIn containing the document IDs to highlight. System.Int32 [] maxPassagesIn The maximum number of top-N ranked passages per-field used to form the highlighted snippets. Returns Type Description System.Collections.Generic.IDictionary < System.String , System.String []> keyed on field name, containing the array of formatted snippets corresponding to the documents in docidsIn . If no highlights were found for a document, the first maxPassages from the field will be returned. Exceptions Type Condition System.IO.IOException if an I/O error occurred during processing System.ArgumentException if field was indexed without DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS | Improve this Doc View Source HighlightFieldsAsObjects(String[], Query, IndexSearcher, Int32[], Int32[]) Expert: highlights the top-N passages from multiple fields, for the provided int[] docids, to custom object as returned by the PassageFormatter . Use this API to render to something other than System.String . Declaration protected virtual IDictionary<string, object[]> HighlightFieldsAsObjects(string[] fieldsIn, Query query, IndexSearcher searcher, int[] docidsIn, int[] maxPassagesIn) Parameters Type Name Description System.String [] fieldsIn field names to highlight. Must have a stored string value and also be indexed with offsets. Lucene.Net.Search.Query query query to highlight. Lucene.Net.Search.IndexSearcher searcher searcher that was previously used to execute the query. System.Int32 [] docidsIn containing the document IDs to highlight. System.Int32 [] maxPassagesIn The maximum number of top-N ranked passages per-field used to form the highlighted snippets. Returns Type Description System.Collections.Generic.IDictionary < System.String , System.Object []> keyed on field name, containing the array of formatted snippets corresponding to the documents in docidsIn . If no highlights were found for a document, the first maxPassagesIn from the field will be returned. Exceptions Type Condition System.IO.IOException if an I/O error occurred during processing System.ArgumentException if field was indexed without DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS | Improve this Doc View Source LoadFieldValues(IndexSearcher, String[], Int32[], Int32) Loads the string values for each field X docID to be highlighted. By default this loads from stored fields, but a subclass can change the source. This method should allocate the string[fields.length][docids.length] and fill all values. The returned strings must be identical to what was indexed. Declaration protected virtual IList<string[]> LoadFieldValues(IndexSearcher searcher, string[] fields, int[] docids, int maxLength) Parameters Type Name Description Lucene.Net.Search.IndexSearcher searcher System.String [] fields System.Int32 [] docids System.Int32 maxLength Returns Type Description System.Collections.Generic.IList < System.String []>"
  },
  "Lucene.Net.Search.PostingsHighlight.Passage.html": {
    "href": "Lucene.Net.Search.PostingsHighlight.Passage.html",
    "title": "Class Passage | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Class Passage Represents a passage (typically a sentence of the document). A passage contains NumMatches highlights from the query, and the offsets and query terms that correspond with each match. This is a Lucene.NET EXPERIMENTAL API, use at your own risk Inheritance System.Object Passage Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Lucene.Net.Search.PostingsHighlight Assembly : Lucene.Net.ICU.dll Syntax public sealed class Passage Properties | Improve this Doc View Source EndOffset Gets the end index (exclusive) of the passage in the original content: always >= StartOffset Declaration public int EndOffset { get; } Property Value Type Description System.Int32 | Improve this Doc View Source MatchEnds End offsets of the term matches, corresponding with MatchStarts . Only NumMatches are valid. Note that its possible that an end offset could exceed beyond the bounds of the passage EndOffset , if the Lucene.Net.Analysis.Analyzer produced a term which spans a passage boundary. Declaration public IReadOnlyList<int> MatchEnds { get; } Property Value Type Description System.Collections.Generic.IReadOnlyList < System.Int32 > | Improve this Doc View Source MatchStarts Start offsets of the term matches, in increasing order. Only NumMatches are valid. Note that these offsets are absolute (not relative to StartOffset ). Declaration public IReadOnlyList<int> MatchStarts { get; } Property Value Type Description System.Collections.Generic.IReadOnlyList < System.Int32 > | Improve this Doc View Source MatchTerms BytesRef (term text) of the matches, corresponding with MatchStarts . Only NumMatches are valid. Declaration public IReadOnlyList<BytesRef> MatchTerms { get; } Property Value Type Description System.Collections.Generic.IReadOnlyList < BytesRef > | Improve this Doc View Source NumMatches Number of term matches available in MatchStarts , MatchEnds , MatchTerms Declaration public int NumMatches { get; } Property Value Type Description System.Int32 | Improve this Doc View Source Score Passage's score. Declaration public float Score { get; } Property Value Type Description System.Single | Improve this Doc View Source StartOffset Gets the start index (inclusive) of the passage in the original content: always >= 0. Declaration public int StartOffset { get; } Property Value Type Description System.Int32"
  },
  "Lucene.Net.Search.PostingsHighlight.PassageFormatter.html": {
    "href": "Lucene.Net.Search.PostingsHighlight.PassageFormatter.html",
    "title": "Class PassageFormatter | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Class PassageFormatter Creates a formatted snippet from the top passages. This is a Lucene.NET EXPERIMENTAL API, use at your own risk Inheritance System.Object PassageFormatter DefaultPassageFormatter Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Lucene.Net.Search.PostingsHighlight Assembly : Lucene.Net.ICU.dll Syntax public abstract class PassageFormatter Methods | Improve this Doc View Source Format(Passage[], String) Formats the top passages from content into a human-readable text snippet. Declaration public abstract object Format(Passage[] passages, string content) Parameters Type Name Description Passage [] passages top-N passages for the field. Note these are sorted in the order that they appear in the document for convenience. System.String content content for the field. Returns Type Description System.Object formatted highlight. Note that for the non-expert APIs in ICUPostingsHighlighter that return System.String , the System.Object.ToString() method on the System.Object returned by this method is used to compute the string."
  },
  "Lucene.Net.Search.PostingsHighlight.PassageScorer.html": {
    "href": "Lucene.Net.Search.PostingsHighlight.PassageScorer.html",
    "title": "Class PassageScorer | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Class PassageScorer Ranks passages found by ICUPostingsHighlighter . Each passage is scored as a miniature document within the document. The final score is computed as norm * ∑ ( weight * tf ). The default implementation is norm * BM25. This is a Lucene.NET EXPERIMENTAL API, use at your own risk Inheritance System.Object PassageScorer Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Lucene.Net.Search.PostingsHighlight Assembly : Lucene.Net.ICU.dll Syntax public class PassageScorer Constructors | Improve this Doc View Source PassageScorer() Creates PassageScorer with these default values: k1 = 1.2 b = 0.75 pivot = 87 Declaration public PassageScorer() | Improve this Doc View Source PassageScorer(Single, Single, Single) Creates PassageScorer with specified scoring parameters Declaration public PassageScorer(float k1, float b, float pivot) Parameters Type Name Description System.Single k1 Controls non-linear term frequency normalization (saturation). System.Single b Controls to what degree passage length normalizes tf values. System.Single pivot Pivot value for length normalization (some rough idea of average sentence length in characters). Methods | Improve this Doc View Source Norm(Int32) Normalize a passage according to its position in the document. Typically passages towards the beginning of the document are more useful for summarizing the contents. The default implementation is 1 + 1/log(pivot + passageStart) Declaration public virtual float Norm(int passageStart) Parameters Type Name Description System.Int32 passageStart start offset of the passage Returns Type Description System.Single a boost value multiplied into the passage's core. | Improve this Doc View Source Tf(Int32, Int32) Computes term weight, given the frequency within the passage and the passage's length. Declaration public virtual float Tf(int freq, int passageLen) Parameters Type Name Description System.Int32 freq number of occurrences of within this passage System.Int32 passageLen length of the passage in characters. Returns Type Description System.Single term weight | Improve this Doc View Source Weight(Int32, Int32) Computes term importance, given its in-document statistics. Declaration public virtual float Weight(int contentLength, int totalTermFreq) Parameters Type Name Description System.Int32 contentLength length of document in characters System.Int32 totalTermFreq number of time term occurs in document Returns Type Description System.Single term importance"
  },
  "Lucene.Net.Search.PostingsHighlight.WholeBreakIterator.html": {
    "href": "Lucene.Net.Search.PostingsHighlight.WholeBreakIterator.html",
    "title": "Class WholeBreakIterator | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Class WholeBreakIterator Just produces one single fragment for the entire text Inheritance System.Object ICU4N.Text.BreakIterator WholeBreakIterator Inherited Members ICU4N.Text.BreakIterator.Done ICU4N.Text.BreakIterator.WordNone ICU4N.Text.BreakIterator.WordNoneLimit ICU4N.Text.BreakIterator.WordNumber ICU4N.Text.BreakIterator.WordNumberLimit ICU4N.Text.BreakIterator.WordLetter ICU4N.Text.BreakIterator.WordLetterLimit ICU4N.Text.BreakIterator.WordKana ICU4N.Text.BreakIterator.WordKanaLimit ICU4N.Text.BreakIterator.WordIdeo ICU4N.Text.BreakIterator.WordIdeoLimit ICU4N.Text.BreakIterator.Clone() ICU4N.Text.BreakIterator.GetRuleStatusVec(System.Int32[]) ICU4N.Text.BreakIterator.SetText(System.String) ICU4N.Text.BreakIterator.SetText(System.Text.StringBuilder) ICU4N.Text.BreakIterator.SetText(System.Char[]) ICU4N.Text.BreakIterator.SetText(J2N.Text.ICharSequence) ICU4N.Text.BreakIterator.GetWordInstance() ICU4N.Text.BreakIterator.GetWordInstance(System.Globalization.CultureInfo) ICU4N.Text.BreakIterator.GetWordInstance(ICU4N.Globalization.UCultureInfo) ICU4N.Text.BreakIterator.GetLineInstance() ICU4N.Text.BreakIterator.GetLineInstance(System.Globalization.CultureInfo) ICU4N.Text.BreakIterator.GetLineInstance(ICU4N.Globalization.UCultureInfo) ICU4N.Text.BreakIterator.GetCharacterInstance() ICU4N.Text.BreakIterator.GetCharacterInstance(System.Globalization.CultureInfo) ICU4N.Text.BreakIterator.GetCharacterInstance(ICU4N.Globalization.UCultureInfo) ICU4N.Text.BreakIterator.GetSentenceInstance() ICU4N.Text.BreakIterator.GetSentenceInstance(System.Globalization.CultureInfo) ICU4N.Text.BreakIterator.GetSentenceInstance(ICU4N.Globalization.UCultureInfo) ICU4N.Text.BreakIterator.GetTitleInstance() ICU4N.Text.BreakIterator.GetTitleInstance(System.Globalization.CultureInfo) ICU4N.Text.BreakIterator.GetTitleInstance(ICU4N.Globalization.UCultureInfo) ICU4N.Text.BreakIterator.RegisterInstance(ICU4N.Text.BreakIterator, System.Globalization.CultureInfo, System.Int32) ICU4N.Text.BreakIterator.RegisterInstance(ICU4N.Text.BreakIterator, ICU4N.Globalization.UCultureInfo, System.Int32) ICU4N.Text.BreakIterator.Unregister(System.Object) ICU4N.Text.BreakIterator.GetCultures(ICU4N.Globalization.UCultureTypes) ICU4N.Text.BreakIterator.GetUCultures(ICU4N.Globalization.UCultureTypes) ICU4N.Text.BreakIterator.RuleStatus ICU4N.Text.BreakIterator.ActualCulture ICU4N.Text.BreakIterator.ValidCulture System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Lucene.Net.Search.PostingsHighlight Assembly : Lucene.Net.ICU.dll Syntax public sealed class WholeBreakIterator : BreakIterator Properties | Improve this Doc View Source Current Declaration public override int Current { get; } Property Value Type Description System.Int32 Overrides ICU4N.Text.BreakIterator.Current | Improve this Doc View Source Text Declaration public override CharacterIterator Text { get; } Property Value Type Description ICU4N.Support.Text.CharacterIterator Overrides ICU4N.Text.BreakIterator.Text Methods | Improve this Doc View Source First() Declaration public override int First() Returns Type Description System.Int32 Overrides ICU4N.Text.BreakIterator.First() | Improve this Doc View Source Following(Int32) Declaration public override int Following(int pos) Parameters Type Name Description System.Int32 pos Returns Type Description System.Int32 Overrides ICU4N.Text.BreakIterator.Following(System.Int32) | Improve this Doc View Source IsBoundary(Int32) Declaration public override bool IsBoundary(int offset) Parameters Type Name Description System.Int32 offset Returns Type Description System.Boolean Overrides ICU4N.Text.BreakIterator.IsBoundary(System.Int32) | Improve this Doc View Source Last() Declaration public override int Last() Returns Type Description System.Int32 Overrides ICU4N.Text.BreakIterator.Last() | Improve this Doc View Source Next() Declaration public override int Next() Returns Type Description System.Int32 Overrides ICU4N.Text.BreakIterator.Next() | Improve this Doc View Source Next(Int32) Declaration public override int Next(int n) Parameters Type Name Description System.Int32 n Returns Type Description System.Int32 Overrides ICU4N.Text.BreakIterator.Next(System.Int32) | Improve this Doc View Source Preceding(Int32) Declaration public override int Preceding(int pos) Parameters Type Name Description System.Int32 pos Returns Type Description System.Int32 Overrides ICU4N.Text.BreakIterator.Preceding(System.Int32) | Improve this Doc View Source Previous() Declaration public override int Previous() Returns Type Description System.Int32 Overrides ICU4N.Text.BreakIterator.Previous() | Improve this Doc View Source SetText(CharacterIterator) Declaration public override void SetText(CharacterIterator newText) Parameters Type Name Description ICU4N.Support.Text.CharacterIterator newText Overrides ICU4N.Text.BreakIterator.SetText(ICU4N.Support.Text.CharacterIterator)"
  },
  "Lucene.Net.Search.VectorHighlight.BreakIteratorBoundaryScanner.html": {
    "href": "Lucene.Net.Search.VectorHighlight.BreakIteratorBoundaryScanner.html",
    "title": "Class BreakIteratorBoundaryScanner | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Class BreakIteratorBoundaryScanner A Lucene.Net.Search.VectorHighlight.IBoundaryScanner implementation that uses ICU4N.Text.BreakIterator to find boundaries in the text. Inheritance System.Object BreakIteratorBoundaryScanner Implements Lucene.Net.Search.VectorHighlight.IBoundaryScanner Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Lucene.Net.Search.VectorHighlight Assembly : Lucene.Net.ICU.dll Syntax public class BreakIteratorBoundaryScanner : IBoundaryScanner Constructors | Improve this Doc View Source BreakIteratorBoundaryScanner(BreakIterator) Declaration public BreakIteratorBoundaryScanner(BreakIterator bi) Parameters Type Name Description ICU4N.Text.BreakIterator bi Methods | Improve this Doc View Source FindEndOffset(StringBuilder, Int32) Declaration public virtual int FindEndOffset(StringBuilder buffer, int start) Parameters Type Name Description System.Text.StringBuilder buffer System.Int32 start Returns Type Description System.Int32 | Improve this Doc View Source FindStartOffset(StringBuilder, Int32) Declaration public virtual int FindStartOffset(StringBuilder buffer, int start) Parameters Type Name Description System.Text.StringBuilder buffer System.Int32 start Returns Type Description System.Int32 Implements Lucene.Net.Search.VectorHighlight.IBoundaryScanner See Also ICU4N.Text.BreakIterator"
  },
  "Lucene.Net.Search.VectorHighlight.html": {
    "href": "Lucene.Net.Search.VectorHighlight.html",
    "title": "Namespace Lucene.Net.Search.VectorHighlight | Apache Lucene.NET 4.8.0-beta00010 Documentation",
    "keywords": "Namespace Lucene.Net.Search.VectorHighlight Classes BreakIteratorBoundaryScanner A Lucene.Net.Search.VectorHighlight.IBoundaryScanner implementation that uses ICU4N.Text.BreakIterator to find boundaries in the text."
  }
}