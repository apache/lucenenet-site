<html xmlns:MSHelp="http://msdn.microsoft.com/mshelp" xmlns:mshelp="http://msdn.microsoft.com/mshelp" xmlns:ddue="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:msxsl="urn:schemas-microsoft-com:xslt"><head><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8" /><META NAME="save" CONTENT="history" /><title>IndexWriter Class</title><meta name="Language" content="en-us" /><meta name="System.Keywords" content="IndexWriter class" /><meta name="System.Keywords" content="Lucene.Net.Index.IndexWriter class" /><meta name="System.Keywords" content="IndexWriter class, about IndexWriter class" /><meta name="Microsoft.Help.F1" content="Lucene.Net.Index.IndexWriter" /><meta name="Microsoft.Help.Id" content="T:Lucene.Net.Index.IndexWriter" /><meta name="Description" content="An @@_SHFB_1 creates and maintains an index. The @@_SHFB_2 argument to the {@link #IndexWriter(Directory, Analyzer, boolean) constructor} determines whether a new index is created, or whether an existing index is opened." /><meta name="Microsoft.Help.ContentType" content="Reference" /><link rel="stylesheet" type="text/css" href="../styles/Presentation.css" /><link rel="stylesheet" type="text/css" href="ms-help://Hx/HxRuntime/HxLink.css" /><script type="text/javascript" src="../scripts/EventUtilities.js"> </script><script type="text/javascript" src="../scripts/SplitScreen.js"> </script><script type="text/javascript" src="../scripts/Dropdown.js"> </script><script type="text/javascript" src="../scripts/script_manifold.js"> </script><script type="text/javascript" src="../scripts/script_feedBack.js"> </script><script type="text/javascript" src="../scripts/CheckboxMenu.js"> </script><script type="text/javascript" src="../scripts/CommonUtilities.js"> </script><meta name="container" content="Lucene.Net.Index" /><meta name="file" content="cfb56f63-f6d1-efdf-e1eb-54ef6f901cd1" /><meta name="guid" content="cfb56f63-f6d1-efdf-e1eb-54ef6f901cd1" /><xml><MSHelp:Attr Name="AssetID" Value="T:Lucene.Net.Index.IndexWriter" /><MSHelp:TOCTitle Title="IndexWriter Class" /><MSHelp:RLTitle Title="IndexWriter Class (Lucene.Net.Index)" /><MSHelp:Keyword Index="A" Term="T:Lucene.Net.Index.IndexWriter" /><MSHelp:Keyword Index="A" Term="frlrfLuceneNetIndexIndexWriterClassTopic" /><MSHelp:Keyword Index="K" Term="IndexWriter class" /><MSHelp:Keyword Index="K" Term="Lucene.Net.Index.IndexWriter class" /><MSHelp:Keyword Index="K" Term="IndexWriter class, about IndexWriter class" /><MSHelp:Keyword Index="F" Term="Lucene.Net.Index.IndexWriter" /><MSHelp:Attr Name="HelpPriority" Value="2" /><MSHelp:Attr Name="APIType" Value="Managed" /><MSHelp:Attr Name="APILocation" Value="Lucene.Net.dll" /><MSHelp:Attr Name="APIName" Value="Lucene.Net.Index.IndexWriter" /><MSHelp:Attr Name="DevLang" Value="CSharp" /><MSHelp:Attr Name="DevLang" Value="VB" /><MSHelp:Attr Name="Locale" Value="en-us" /><MSHelp:Attr Name="TopicType" Value="kbSyntax" /><MSHelp:Attr Name="TopicType" Value="apiref" /><MSHelp:Attr Name="Abstract" Value="An @@_SHFB_1 creates and maintains an index. The @@_SHFB_2 argument to the {@link #IndexWriter(Directory, Analyzer, boolean) constructor} determines whether a new index is created, or whether an existing index ..." /><MSHelp:Attr Name="AssemblyVersion" Value="2.9.4.1" /></xml><link type="text/css" rel="stylesheet" href="../styles/highlight.css" /><script type="text/javascript" src="../scripts/highlight.js"> </script></head><body><input type="hidden" id="userDataCache" class="userDataStyle" /><input type="hidden" id="hiddenScrollOffset" /><img id="collapseImage" style="display:none; height:0; width:0;" src="../icons/collapse_all.gif" alt="Collapse image" title="Collapse image" /><img id="expandImage" style="display:none; height:0; width:0;" src="../icons/expand_all.gif" alt="Expand Image" title="Expand Image" /><img id="collapseAllImage" style="display:none; height:0; width:0;" src="../icons/collapse_all.gif" /><img id="expandAllImage" style="display:none; height:0; width:0;" src="../icons/expand_all.gif" /><img id="dropDownImage" style="display:none; height:0; width:0;" src="../icons/dropdown.gif" /><img id="dropDownHoverImage" style="display:none; height:0; width:0;" src="../icons/dropdownHover.gif" /><img id="copyImage" style="display:none; height:0; width:0;" src="../icons/copycode.gif" alt="Copy image" title="Copy image" /><img id="copyHoverImage" style="display:none; height:0; width:0;" src="../icons/copycodeHighlight.gif" alt="CopyHover image" title="CopyHover image" /><div id="header"><table id="topTable" cellspacing="0" cellpadding="0"><tr><td><span onclick="ExpandCollapseAll(toggleAllImage)" style="cursor:default;" onkeypress="ExpandCollapseAll_CheckKey(toggleAllImage, event)" tabindex="0"><img ID="toggleAllImage" class="toggleAll" src="../icons/collapse_all.gif" /> <label id="collapseAllLabel" for="toggleAllImage" style="display: none;">Collapse All</label><label id="expandAllLabel" for="toggleAllImage" style="display: none;">Expand All</label> </span><span>    </span><span id="devlangsDropdown" class="filter" tabindex="0"><img id="devlangsDropdownImage" src="../icons/dropdown.gif" /> <label id="devlangsMenuAllLabel" for="devlangsDropdownImage" style="display: none;"><nobr>Code: All </nobr></label><label id="devlangsMenuMultipleLabel" for="devlangsDropdownImage" style="display: none;"><nobr>Code: Multiple </nobr></label><label id="devlangsMenuCSharpLabel" for="devlangsDropdownImage" style="display: none;"><nobr>Code: C# </nobr></label><label id="devlangsMenuVisualBasicLabel" for="devlangsDropdownImage" style="display: none;"><nobr>Code: Visual Basic </nobr></label><label id="devlangsMenuManagedCPlusPlusLabel" for="devlangsDropdownImage" style="display: none;"><nobr>Code: Visual C++ </nobr></label></span></td></tr></table><div id="devlangsMenu"><input id="CSharpCheckbox" type="checkbox" data="CSharp,cs,'persist'" value="on" onClick="SetLanguage(this)" /><label class="checkboxLabel" for="CSharpCheckbox">C#</label><br /><input id="VisualBasicCheckbox" type="checkbox" data="VisualBasic,vb,'persist'" value="on" onClick="SetLanguage(this)" /><label class="checkboxLabel" for="VisualBasicCheckbox">Visual Basic</label><br /><input id="ManagedCPlusPlusCheckbox" type="checkbox" data="ManagedCPlusPlus,cpp,'persist'" value="on" onClick="SetLanguage(this)" /><label class="checkboxLabel" for="ManagedCPlusPlusCheckbox">Visual C++</label><br /></div><table id="bottomTable" cellpadding="0" cellspacing="0"><tr id="headerTableRow1"><td align="left"><span id="runningHeaderText">Lucene.Net Class Libraries</span></td></tr><tr id="headerTableRow2"><td align="left"><span id="nsrTitle">IndexWriter Class</span></td></tr><tr id="headerTableRow3"><td align="left"><a href="cb89eecb-5237-f34b-779c-5bedfb8104fb.htm">Members</a> <a href="#seeAlsoToggle" onclick="OpenSection(seeAlsoToggle)">See Also</a> <span id="headfeedbackarea" class="feedbackhead"><a href="javascript:SubmitFeedback('','Lucene.Net Class Libraries','','','','%0\dYour%20feedback%20is%20used%20to%20improve%20the%20documentation%20and%20the%20product.%20Your%20e-mail%20address%20will%20not%20be%20used%20for%20any%20other%20purpose%20and%20is%20disposed%20of%20after%20the%20issue%20you%20report%20is%20resolved.%20%20While%20working%20to%20resolve%20the%20issue%20that%20you%20report,%20you%20may%20be%20contacted%20via%20e-mail%20to%20get%20further%20details%20or%20clarification%20on%20the%20feedback%20you%20sent.%20After%20the%20issue%20you%20report%20has%20been%20addressed,%20you%20may%20receive%20an%20e-mail%20to%20let%20you%20know%20that%20your%20feedback%20has%20been%20addressed.%0\A%0\d','Customer%20Feedback');">Send Feedback</a></span></td></tr></table><table id="gradientTable"><tr><td class="nsrBottom" background="../icons/gradient.gif" /></tr></table></div><div id="mainSection"><div id="mainBody"><div id="allHistory" class="saveHistory" onsave="saveAll()" onload="loadAll()" /><span style="color: DarkGray"></span><div class="summary">An <span id="cbc_1" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">IndexWriter</pre></div></span> creates and maintains an index.
            <p />The <span id="cbc_2" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">create</pre></div></span> argument to the {@link
            #IndexWriter(Directory, Analyzer, boolean) constructor} determines 
            whether a new index is created, or whether an existing index is
            opened.  Note that you can open an index with <span id="cbc_3" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">create=<span class="highlight-keyword">true</span></pre></div></span>
            even while readers are using the index.  The old readers will 
            continue to search the "point in time" snapshot they had opened, 
            and won't see the newly created index until they re-open.  There are
            also {@link #IndexWriter(Directory, Analyzer) constructors}
            with no <span id="cbc_4" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">create</pre></div></span> argument which will create a new index
            if there is not already an index at the provided path and otherwise 
            open the existing index.<p /><p />In either case, documents are added with {@link #AddDocument(Document)
            addDocument} and removed with {@link #DeleteDocuments(Term)} or {@link
            #DeleteDocuments(Query)}. A document can be updated with {@link
            #UpdateDocument(Term, Document) updateDocument} (which just deletes
            and then adds the entire document). When finished adding, deleting 
            and updating documents, {@link #Close() close} should be called.<p /><a name="flush" /><p />These changes are buffered in memory and periodically
            flushed to the {@link Directory} (during the above method
            calls).  A flush is triggered when there are enough
            buffered deletes (see {@link #setMaxBufferedDeleteTerms})
            or enough added documents since the last flush, whichever
            is sooner.  For the added documents, flushing is triggered
            either by RAM usage of the documents (see {@link
            #setRAMBufferSizeMB}) or the number of added documents.
            The default is to flush when RAM usage hits 16 MB.  For
            best indexing speed you should flush by RAM usage with a
            large RAM buffer.  Note that flushing just moves the
            internal buffered state in IndexWriter into the index, but
            these changes are not visible to IndexReader until either
            {@link #Commit()} or {@link #close} is called.  A flush may
            also trigger one or more segment merges which by default
            run with a background thread so as not to block the
            addDocument calls (see <a href="#mergePolicy">below</a>
            for changing the {@link MergeScheduler}).<p /><a name="autoCommit" /><p />The optional <span id="cbc_5" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">autoCommit</pre></div></span> argument to the {@link
            #IndexWriter(Directory, boolean, Analyzer) constructors}
            controls visibility of the changes to {@link IndexReader}
            instances reading the same index.  When this is
            <span id="cbc_6" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve"><span class="highlight-keyword">false</span></pre></div></span>, changes are not visible until {@link
            #Close()} or {@link #Commit()} is called.  Note that changes will still be
            flushed to the {@link Directory} as new files, but are 
            not committed (no new <span id="cbc_7" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">segments_N</pre></div></span> file is written 
            referencing the new files, nor are the files sync'd to stable storage)
            until {@link #Close()} or {@link #Commit()} is called.  If something
            goes terribly wrong (for example the JVM crashes), then
            the index will reflect none of the changes made since the
            last commit, or the starting state if commit was not called.
            You can also call {@link #Rollback()}, which closes the writer
            without committing any changes, and removes any index
            files that had been flushed but are now unreferenced.
            This mode is useful for preventing readers from refreshing
            at a bad time (for example after you've done all your
            deletes but before you've done your adds).  It can also be
            used to implement simple single-writer transactional
            semantics ("all or none").  You can do a two-phase commit
            by calling {@link #PrepareCommit()}
            followed by {@link #Commit()}. This is necessary when
            Lucene is working with an external resource (for example,
            a database) and both must either commit or rollback the
            transaction.<p /><p />When <span id="cbc_8" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">autoCommit</pre></div></span> is <span id="cbc_9" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve"><span class="highlight-keyword">true</span></pre></div></span> then
            the writer will periodically commit on its own.  [<b>Deprecated</b>: Note that in 3.0, IndexWriter will
            no longer accept autoCommit=true (it will be hardwired to
            false).  You can always call {@link #Commit()} yourself
            when needed]. There is
            no guarantee when exactly an auto commit will occur (it
            used to be after every flush, but it is now after every
            completed merge, as of 2.4).  If you want to force a
            commit, call {@link #Commit()}, or, close the writer.  Once
            a commit has finished, newly opened {@link IndexReader} instances will
            see the changes to the index as of that commit.  When
            running in this mode, be careful not to refresh your
            readers while optimize or segment merges are taking place
            as this can tie up substantial disk space.<p /></div><div class="summary"><p />Regardless of <span id="cbc_10" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">autoCommit</pre></div></span>, an {@link
            IndexReader} or {@link Lucene.Net.Search.IndexSearcher} will only see the
            index as of the "point in time" that it was opened.  Any
            changes committed to the index after the reader was opened
            are not visible until the reader is re-opened.<p /><p />If an index will not have more documents added for a while and optimal search
            performance is desired, then either the full {@link #Optimize() optimize}
            method or partial {@link #Optimize(int)} method should be
            called before the index is closed.<p /><p />Opening an <span id="cbc_11" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">IndexWriter</pre></div></span> creates a lock file for the directory in use. Trying to open
            another <span id="cbc_12" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">IndexWriter</pre></div></span> on the same directory will lead to a
            {@link LockObtainFailedException}. The {@link LockObtainFailedException}
            is also thrown if an IndexReader on the same directory is used to delete documents
            from the index.<p /></div><div class="summary"><a name="deletionPolicy" /><p />Expert: <span id="cbc_13" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">IndexWriter</pre></div></span> allows an optional
            {@link IndexDeletionPolicy} implementation to be
            specified.  You can use this to control when prior commits
            are deleted from the index.  The default policy is {@link
            KeepOnlyLastCommitDeletionPolicy} which removes all prior
            commits as soon as a new commit is done (this matches
            behavior before 2.2).  Creating your own policy can allow
            you to explicitly keep previous "point in time" commits
            alive in the index for some time, to allow readers to
            refresh to the new commit without having the old commit
            deleted out from under them.  This is necessary on
            filesystems like NFS that do not support "delete on last
            close" semantics, which Lucene's "point in time" search
            normally relies on. <p /><a name="mergePolicy" /><p />Expert:
            <span id="cbc_14" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">IndexWriter</pre></div></span> allows you to separately change
            the {@link MergePolicy} and the {@link MergeScheduler}.
            The {@link MergePolicy} is invoked whenever there are
            changes to the segments in the index.  Its role is to
            select which merges to do, if any, and return a {@link
            MergePolicy.MergeSpecification} describing the merges.  It
            also selects merges to do for optimize().  (The default is
            {@link LogByteSizeMergePolicy}.  Then, the {@link
            MergeScheduler} is invoked with the requested merges and
            it decides when and how to run the merges.  The default is
            {@link ConcurrentMergeScheduler}. <p /><a name="OOME" /><p /><b>NOTE</b>: if you hit an
            OutOfMemoryError then IndexWriter will quietly record this
            fact and block all future segment commits.  This is a
            defensive measure in case any internal state (buffered
            documents and deletions) were corrupted.  Any subsequent
            calls to {@link #Commit()} will throw an
            IllegalStateException.  The only course of action is to
            call {@link #Close()}, which internally will call {@link
            #Rollback()}, to undo any changes to the index since the
            last commit.  If you opened the writer with autoCommit
            false you can also just call {@link #Rollback()}
            directly.<p /><a name="thread-safety" /><p /><b>NOTE</b>: {@link
            <span id="cbc_15" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">IndexWriter</pre></div></span>} instances are completely thread
            safe, meaning multiple threads can call any of its
            methods, concurrently.  If your application requires
            external synchronization, you should <b>not</b>
            synchronize on the <span id="cbc_16" x-lang="CSharp" codeLanguage="CSharp"><div class="highlight-title"><span class="highlight-copycode" onkeypress="javascript:CopyColorizedCodeCheckKey(this.parentNode, event);" tabindex="0" onmouseover="CopyCodeChangeIcon(this)" onmouseout="CopyCodeChangeIcon(this)" onclick="javascript:CopyColorizedCode(this.parentNode);"><img style="margin-right: 5px;" src="../icons/CopyCode.gif" />Copy</span>C#</div><div class="code"><pre xml:space="preserve">IndexWriter</pre></div></span> instance as
            this may cause deadlock; use your own (non-Lucene) objects
            instead. <p /></div><p /><b>Namespace:</b> <a href="4d52bcdb-050f-b66e-6d74-d7169ebc88b0.htm">Lucene.Net.Index</a><br /><b>Assembly:</b> <span sdata="assembly">Lucene.Net</span> (in Lucene.Net.dll) Version: 2.9.4.1<h1 class="heading"><span onclick="ExpandCollapse(syntaxToggle)" style="cursor:default;" onkeypress="ExpandCollapse_CheckKey(syntaxToggle, event)" tabindex="0"><img id="syntaxToggle" class="toggle" name="toggleSwitch" src="../icons/collapse_all.gif" />Syntax</span></h1><div id="syntaxSection" class="section" name="collapseableSection" style=""><div id="syntaxCodeBlocks" class="code"><span codeLanguage="CSharp"><table><tr><th>C#</th></tr><tr><td><pre xml:space="preserve"><span class="keyword">public</span> <span class="keyword">class</span> <span class="identifier">IndexWriter</span> : <a href="http://msdn2.microsoft.com/en-us/library/aax125c9" target="_blank">IDisposable</a></pre></td></tr></table></span><span codeLanguage="VisualBasicDeclaration"><table><tr><th>Visual Basic</th></tr><tr><td><pre xml:space="preserve"><span class="keyword">Public</span> <span class="keyword">Class</span> <span class="identifier">IndexWriter</span> _
	<span class="keyword">Implements</span> <a href="http://msdn2.microsoft.com/en-us/library/aax125c9" target="_blank">IDisposable</a></pre></td></tr></table></span><span codeLanguage="ManagedCPlusPlus"><table><tr><th>Visual C++</th></tr><tr><td><pre xml:space="preserve"><span class="keyword">public</span> <span class="keyword">ref class</span> <span class="identifier">IndexWriter</span> : <a href="http://msdn2.microsoft.com/en-us/library/aax125c9" target="_blank">IDisposable</a></pre></td></tr></table></span></div></div><h1 class="heading"><span onclick="ExpandCollapse(familyToggle)" style="cursor:default;" onkeypress="ExpandCollapse_CheckKey(familyToggle, event)" tabindex="0"><img id="familyToggle" class="toggle" name="toggleSwitch" src="../icons/collapse_all.gif" />Inheritance Hierarchy</span></h1><div id="familySection" class="section" name="collapseableSection" style=""><a href="http://msdn2.microsoft.com/en-us/library/e5kfa45b" target="_blank">System<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>Object</a><br />  <span class="selflink">Lucene.Net.Index<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>IndexWriter</span><br /></div><h1 class="heading"><span onclick="ExpandCollapse(seeAlsoToggle)" style="cursor:default;" onkeypress="ExpandCollapse_CheckKey(seeAlsoToggle, event)" tabindex="0"><img id="seeAlsoToggle" class="toggle" name="toggleSwitch" src="../icons/collapse_all.gif" />See Also</span></h1><div id="seeAlsoSection" class="section" name="collapseableSection" style=""><div class="seeAlsoStyle"><a href="cb89eecb-5237-f34b-779c-5bedfb8104fb.htm">IndexWriter Members</a></div><div class="seeAlsoStyle"><a href="4d52bcdb-050f-b66e-6d74-d7169ebc88b0.htm">Lucene.Net.Index Namespace</a></div></div></div><div id="footer"><div class="footerLine"><img width="100%" height="3px" src="../icons/footer.gif" alt="Footer image" title="Footer image" /></div><A NAME="feedback"></A><span id="fb" class="feedbackcss"></span></div></div></body></html>