<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Namespace Lucene.Net.Store
   | Apache Lucene.NET 4.8.0-beta00008 Documentation </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Namespace Lucene.Net.Store
   | Apache Lucene.NET 4.8.0-beta00008 Documentation ">
    <meta name="generator" content="docfx 2.50.0.0">
    
    <link rel="shortcut icon" href="../../logo/favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    <meta property="docfx:rel" content="../../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../logo/lucene-net-color.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="Lucene.Net.Store">
  
  <h1 id="Lucene_Net_Store" data-uid="Lucene.Net.Store" class="text-break">Namespace Lucene.Net.Store
  </h1>
  <div class="markdown level0 summary"><!--
 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<p>Binary i/o API, used for all index data.</p>
</div>
  <div class="markdown level0 conceptual"></div>
  <div class="markdown level0 remarks"></div>
    <h3 id="classes">Classes
  </h3>
      <h4><a class="xref" href="Lucene.Net.Store.BaseDirectory.html">BaseDirectory</a></h4>
      <section><p>Base implementation for a concrete <a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a>.
<p>
<div class="lucene-block lucene-experimental">This is a Lucene.NET EXPERIMENTAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Store.BufferedChecksumIndexInput.html">BufferedChecksumIndexInput</a></h4>
      <section><p>Simple implementation of <a class="xref" href="Lucene.Net.Store.ChecksumIndexInput.html">ChecksumIndexInput</a> that wraps
another input and delegates calls.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.BufferedIndexInput.html">BufferedIndexInput</a></h4>
      <section><p>Base implementation class for buffered <a class="xref" href="Lucene.Net.Store.IndexInput.html">IndexInput</a>. </p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.BufferedIndexOutput.html">BufferedIndexOutput</a></h4>
      <section><p>Base implementation class for buffered <a class="xref" href="Lucene.Net.Store.IndexOutput.html">IndexOutput</a>. </p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.ByteArrayDataInput.html">ByteArrayDataInput</a></h4>
      <section><p>DataInput backed by a byte array.
<strong>WARNING:</strong> this class omits all low-level checks.
<p>
<div class="lucene-block lucene-experimental">This is a Lucene.NET EXPERIMENTAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Store.ByteArrayDataOutput.html">ByteArrayDataOutput</a></h4>
      <section><p>DataOutput backed by a byte array.
<strong>WARNING:</strong> this class omits most low-level checks,
so be sure to test heavily with assertions enabled.
<p>
<div class="lucene-block lucene-experimental">This is a Lucene.NET EXPERIMENTAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Store.ByteBufferIndexInput.html">ByteBufferIndexInput</a></h4>
      <section><p>Base <a class="xref" href="Lucene.Net.Store.IndexInput.html">IndexInput</a> implementation that uses an array
of <span class="xref">J2N.IO.ByteBuffer</span>s to represent a file.
<p>
Because Java&apos;s <span class="xref">J2N.IO.ByteBuffer</span> uses an <span class="xref">System.Int32</span> to address the
values, it&apos;s necessary to access a file greater
<span class="xref">System.Int32.MaxValue</span> in size using multiple byte buffers.
<p>
For efficiency, this class requires that the buffers
are a power-of-two (<code>chunkSizePower</code>).</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.ChecksumIndexInput.html">ChecksumIndexInput</a></h4>
      <section><p>Extension of <a class="xref" href="Lucene.Net.Store.IndexInput.html">IndexInput</a>, computing checksum as it goes.
Callers can retrieve the checksum via <a class="xref" href="Lucene.Net.Store.ChecksumIndexInput.html#Lucene_Net_Store_ChecksumIndexInput_Checksum">Checksum</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.CompoundFileDirectory.html">CompoundFileDirectory</a></h4>
      <section><p>Class for accessing a compound stream.
This class implements a directory, but is limited to only read operations.
Directory methods that would normally modify data throw an exception.
<p>
All files belonging to a segment have the same name with varying extensions.
The extensions correspond to the different file formats used by the <a class="xref" href="Lucene.Net.Codecs.Codec.html">Codec</a>.
When using the Compound File format these files are collapsed into a
single <code>.cfs</code> file (except for the <a class="xref" href="Lucene.Net.Codecs.LiveDocsFormat.html">LiveDocsFormat</a>, with a
corresponding <code>.cfe</code> file indexing its sub-files.
<p>
Files:
<ul><li><code>.cfs</code>: An optional &quot;virtual&quot; file consisting of all the other
        index files for systems that frequently run out of file handles.</li><li><code>.cfe</code>: The &quot;virtual&quot; compound file&apos;s entry table holding all
        entries in the corresponding .cfs file.</li></ul>
<p>Description:</p>
<ul><li>Compound (.cfs) --&gt; Header, FileData <sup>FileCount</sup></li><li>Compound Entry Table (.cfe) --&gt; Header, FileCount, &lt;FileName,
        DataOffset, DataLength&gt; <sup>FileCount</sup>, Footer</li><li>Header --&gt; <a class="xref" href="Lucene.Net.Codecs.CodecUtil.html#Lucene_Net_Codecs_CodecUtil_WriteHeader_Lucene_Net_Store_DataOutput_System_String_System_Int32_">WriteHeader(DataOutput, String, Int32)</a></li><li>FileCount --&gt; <a class="xref" href="Lucene.Net.Store.DataOutput.html#Lucene_Net_Store_DataOutput_WriteVInt32_System_Int32_">WriteVInt32(Int32)</a></li><li>DataOffset,DataLength --&gt; <a class="xref" href="Lucene.Net.Store.DataOutput.html#Lucene_Net_Store_DataOutput_WriteInt64_System_Int64_">WriteInt64(Int64)</a></li><li>FileName --&gt; <a class="xref" href="Lucene.Net.Store.DataOutput.html#Lucene_Net_Store_DataOutput_WriteString_System_String_">WriteString(String)</a></li><li>FileData --&gt; raw file data</li><li>Footer --&gt; <a class="xref" href="Lucene.Net.Codecs.CodecUtil.html#Lucene_Net_Codecs_CodecUtil_WriteFooter_Lucene_Net_Store_IndexOutput_">WriteFooter(IndexOutput)</a></li></ul>
<p>Notes:</p>
<ul><li>FileCount indicates how many files are contained in this compound file.
        The entry table that follows has that many entries.</li><li>Each directory entry contains a long pointer to the start of this file&apos;s data
        section, the files length, and a <span class="xref">System.String</span> with that file&apos;s name.</li></ul>
<p>
<div class="lucene-block lucene-experimental">This is a Lucene.NET EXPERIMENTAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Store.CompoundFileDirectory.FileEntry.html">CompoundFileDirectory.FileEntry</a></h4>
      <section><p>Offset/Length for a slice inside of a compound file </p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.DataInput.html">DataInput</a></h4>
      <section><p>Abstract base class for performing read operations of Lucene&apos;s low-level
data types.</p>
<p><p><a class="xref" href="Lucene.Net.Store.DataInput.html">DataInput</a> may only be used from one thread, because it is not
thread safe (it keeps internal state like file position). To allow
multithreaded use, every <a class="xref" href="Lucene.Net.Store.DataInput.html">DataInput</a> instance must be cloned before
used in another thread. Subclasses must therefore implement <a class="xref" href="Lucene.Net.Store.DataInput.html#Lucene_Net_Store_DataInput_Clone">Clone()</a>,
returning a new <a class="xref" href="Lucene.Net.Store.DataInput.html">DataInput</a> which operates on the same underlying
resource, but positioned independently.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.DataOutput.html">DataOutput</a></h4>
      <section><p>Abstract base class for performing write operations of Lucene&apos;s low-level
data types.</p>
<p><p><a class="xref" href="Lucene.Net.Store.DataOutput.html">DataOutput</a> may only be used from one thread, because it is not
thread safe (it keeps internal state like file position).</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a></h4>
      <section><p>A <a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a> is a flat list of files.  Files may be written once, when they
are created.  Once a file is created it may only be opened for read, or
deleted.  Random access is permitted both when reading and writing.
<p>
.NET&apos;s i/o APIs not used directly, but rather all i/o is
through this API.  This permits things such as: 
<ul><li> implementation of RAM-based indices;</li><li> implementation indices stored in a database;</li><li> implementation of an index as a single file;</li></ul>
<p>
Directory locking is implemented by an instance of
<a class="xref" href="Lucene.Net.Store.LockFactory.html">LockFactory</a>, and can be changed for each <a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a>
instance using <a class="xref" href="Lucene.Net.Store.Directory.html#Lucene_Net_Store_Directory_SetLockFactory_Lucene_Net_Store_LockFactory_">SetLockFactory(LockFactory)</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.Directory.IndexInputSlicer.html">Directory.IndexInputSlicer</a></h4>
      <section><p>Allows to create one or more sliced <a class="xref" href="Lucene.Net.Store.IndexInput.html">IndexInput</a> instances from a single
file handle. Some <a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a> implementations may be able to efficiently map slices of a file
into memory when only certain parts of a file are required.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div><div class="lucene-block lucene-experimental">This is a Lucene.NET EXPERIMENTAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Store.FileSwitchDirectory.html">FileSwitchDirectory</a></h4>
      <section><p>Expert: A <a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a> instance that switches files between
two other <a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a> instances.</p>
<p><p>Files with the specified extensions are placed in the
primary directory; others are placed in the secondary
directory.  The provided <span class="xref">ISet{string}</span> must not change once passed
to this class, and must allow multiple threads to call
contains at once.
<p>
<div class="lucene-block lucene-experimental">This is a Lucene.NET EXPERIMENTAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Store.FilterDirectory.html">FilterDirectory</a></h4>
      <section><p>Directory implementation that delegates calls to another directory.
This class can be used to add limitations on top of an existing
<a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a> implementation such as
rate limiting (<a class="xref" href="Lucene.Net.Store.RateLimitedDirectoryWrapper.html">RateLimitedDirectoryWrapper</a>) or to add additional
sanity checks for tests. However, if you plan to write your own
<a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a> implementation, you should consider extending directly
<a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a> or <a class="xref" href="Lucene.Net.Store.BaseDirectory.html">BaseDirectory</a> rather than try to reuse
functionality of existing <a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a>s by extending this class.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Store.FlushInfo.html">FlushInfo</a></h4>
      <section><p>A FlushInfo provides information required for a FLUSH context.
It is used as part of an <a class="xref" href="Lucene.Net.Store.IOContext.html">IOContext</a> in case of FLUSH context.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.FSDirectory.html">FSDirectory</a></h4>
      <section><p>Base class for <a class="xref" href="Lucene.Net.Store.FSDirectory.html#Lucene_Net_Store_FSDirectory_Directory">Directory</a> implementations that store index
files in the file system.
<p>
There are currently three core
subclasses:</p>
<ul><li> <a class="xref" href="Lucene.Net.Store.SimpleFSDirectory.html">SimpleFSDirectory</a> is a straightforward
        implementation using <span class="xref">System.IO.FileStream</span>.
        However, it has poor concurrent performance
        (multiple threads will bottleneck) as it
        synchronizes when multiple threads read from the
        same file.</li><li> <a class="xref" href="Lucene.Net.Store.NIOFSDirectory.html">NIOFSDirectory</a> uses java.nio&apos;s
        FileChannel&apos;s positional io when reading to avoid
        synchronization when reading from the same file.
        Unfortunately, due to a Windows-only <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6265734">Sun
        JRE bug</a> this is a poor choice for Windows, but
        on all other platforms this is the preferred
        choice. Applications using <span class="xref">System.Threading.Thread.Interrupt</span> or
<span class="xref">System.Threading.Tasks.Task&lt;TResult&gt;</span> should use
<a class="xref" href="Lucene.Net.Store.SimpleFSDirectory.html">SimpleFSDirectory</a> instead. See <a class="xref" href="Lucene.Net.Store.NIOFSDirectory.html">NIOFSDirectory</a> java doc
for details.</li><li> <a class="xref" href="Lucene.Net.Store.MMapDirectory.html">MMapDirectory</a> uses memory-mapped IO when
reading. This is a good choice if you have plenty
of virtual memory relative to your index size, eg
if you are running on a 64 bit runtime, or you are
running on a 32 bit runtime but your index sizes are
small enough to fit into the virtual memory space.
<p>
Applications using <span class="xref">System.Threading.Thread.Interrupt</span> or
<span class="xref">System.Threading.Tasks.Task</span> should use
<a class="xref" href="Lucene.Net.Store.SimpleFSDirectory.html">SimpleFSDirectory</a> instead. See <a class="xref" href="Lucene.Net.Store.MMapDirectory.html">MMapDirectory</a>
doc for details.</li></ul>

<p>Unfortunately, because of system peculiarities, there is
no single overall best implementation.  Therefore, we&apos;ve
added the <a class="xref" href="Lucene.Net.Store.FSDirectory.html#Lucene_Net_Store_FSDirectory_Open_System_String_">Open(String)</a> method  (or one of its overloads), to allow Lucene to choose
the best <a class="xref" href="Lucene.Net.Store.FSDirectory.html">FSDirectory</a> implementation given your
environment, and the known limitations of each
implementation.  For users who have no reason to prefer a
specific implementation, it&apos;s best to simply use 
<a class="xref" href="Lucene.Net.Store.FSDirectory.html#Lucene_Net_Store_FSDirectory_Open_System_String_">Open(String)</a>  (or one of its overloads).  For all others, you should instantiate the
desired implementation directly.</p>
<p><p>The locking implementation is by default 
<a class="xref" href="Lucene.Net.Store.NativeFSLockFactory.html">NativeFSLockFactory</a>, but can be changed by
passing in a custom <a class="xref" href="Lucene.Net.Store.LockFactory.html">LockFactory</a> instance.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.FSDirectory.FSIndexOutput.html">FSDirectory.FSIndexOutput</a></h4>
      <section><p>Writes output with <span class="xref">System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)</span></p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.FSLockFactory.html">FSLockFactory</a></h4>
      <section><p>Base class for file system based locking implementation.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.IndexInput.html">IndexInput</a></h4>
      <section><p>Abstract base class for input from a file in a <a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a>.  A
random-access input stream.  Used for all Lucene index input operations.</p>
<p><p><a class="xref" href="Lucene.Net.Store.IndexInput.html">IndexInput</a> may only be used from one thread, because it is not
thread safe (it keeps internal state like file position). To allow
multithreaded use, every <a class="xref" href="Lucene.Net.Store.IndexInput.html">IndexInput</a> instance must be cloned before
used in another thread. Subclasses must therefore implement <a class="xref" href="Lucene.Net.Store.IndexInput.html#Lucene_Net_Store_IndexInput_Clone">Clone()</a>,
returning a new <a class="xref" href="Lucene.Net.Store.IndexInput.html">IndexInput</a> which operates on the same underlying
resource, but positioned independently. Lucene never closes cloned
<a class="xref" href="Lucene.Net.Store.IndexInput.html">IndexInput</a>s, it will only do this on the original one.
The original instance must take care that cloned instances throw
<span class="xref">System.ObjectDisposedException</span> when the original one is closed.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.IndexOutput.html">IndexOutput</a></h4>
      <section><p>Abstract base class for output to a file in a <a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a>.  A random-access
output stream.  Used for all Lucene index output operations.</p>
<p><p><a class="xref" href="Lucene.Net.Store.IndexOutput.html">IndexOutput</a> may only be used from one thread, because it is not
thread safe (it keeps internal state like file position).</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.InputStreamDataInput.html">InputStreamDataInput</a></h4>
      <section><p>A <a class="xref" href="Lucene.Net.Store.DataInput.html">DataInput</a> wrapping a plain <span class="xref">System.IO.Stream</span>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.IOContext.html">IOContext</a></h4>
      <section><a class="xref" href="Lucene.Net.Store.IOContext.html">IOContext</a> holds additional details on the merge/search context. A <a class="xref" href="Lucene.Net.Store.IOContext.html">IOContext</a>
object can never be initialized as null as passed as a parameter to either
<a class="xref" href="Lucene.Net.Store.Directory.html#Lucene_Net_Store_Directory_OpenInput_System_String_Lucene_Net_Store_IOContext_">OpenInput(String, IOContext)</a> or
<a class="xref" href="Lucene.Net.Store.Directory.html#Lucene_Net_Store_Directory_CreateOutput_System_String_Lucene_Net_Store_IOContext_">CreateOutput(String, IOContext)</a>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.Lock.html">Lock</a></h4>
      <section><p>An interprocess mutex lock.
<p>Typical use might look like:</p>
<pre><code>    var result = Lock.With.NewAnonymous&lt;string>(
        @lock: directory.MakeLock(&quot;my.lock&quot;), 
        lockWaitTimeout: Lock.LOCK_OBTAIN_WAIT_FOREVER, 
        doBody: () =>
    {
        //... code to execute while locked ...
        return &quot;the result&quot;;
    }).Run();</code></pre>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.Lock.With-1.html">Lock.With&lt;T&gt;</a></h4>
      <section><p>Utility class for executing code with exclusive access. </p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.LockFactory.html">LockFactory</a></h4>
      <section><p>Base class for Locking implementation.  <a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a> uses
instances of this class to implement locking.</p>

<p>Lucene uses <a class="xref" href="Lucene.Net.Store.NativeFSLockFactory.html">NativeFSLockFactory</a> by default for
<a class="xref" href="Lucene.Net.Store.FSDirectory.html">FSDirectory</a>-based index directories.</p>

<p>Special care needs to be taken if you change the locking
implementation: First be certain that no writer is in fact
writing to the index otherwise you can easily corrupt
your index. Be sure to do the <a class="xref" href="Lucene.Net.Store.LockFactory.html">LockFactory</a> change on all Lucene
instances and clean up all leftover lock files before starting
the new configuration for the first time. Different implementations
can not work together!</p>

<p>If you suspect that some <a class="xref" href="Lucene.Net.Store.LockFactory.html">LockFactory</a> implementation is
not working properly in your environment, you can easily
test it by using <a class="xref" href="Lucene.Net.Store.VerifyingLockFactory.html">VerifyingLockFactory</a>, 
<a class="xref" href="Lucene.Net.Store.LockVerifyServer.html">LockVerifyServer</a> and <a class="xref" href="Lucene.Net.Store.LockStressTest.html">LockStressTest</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.LockObtainFailedException.html">LockObtainFailedException</a></h4>
      <section><p>This exception is thrown when the <code>write.lock</code>
could not be acquired.  This
happens when a writer tries to open an index
that another writer already has open. </p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.LockReleaseFailedException.html">LockReleaseFailedException</a></h4>
      <section><p>This exception is thrown when the <code>write.lock</code>
could not be released. </p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.LockStressTest.html">LockStressTest</a></h4>
      <section><p>Simple standalone tool that forever acquires &amp; releases a
lock using a specific <a class="xref" href="Lucene.Net.Store.LockFactory.html">LockFactory</a>.  Run without any args
to see usage.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.LockVerifyServer.html">LockVerifyServer</a></h4>
      <section><p>Simple standalone server that must be running when you
use <a class="xref" href="Lucene.Net.Store.VerifyingLockFactory.html">VerifyingLockFactory</a>.  This server simply
verifies at most one process holds the lock at a time.
Run without any args to see usage.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.MergeInfo.html">MergeInfo</a></h4>
      <section><p>A MergeInfo provides information required for a MERGE context.
It is used as part of an <a class="xref" href="Lucene.Net.Store.IOContext.html">IOContext</a> in case of MERGE context.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.MMapDirectory.html">MMapDirectory</a></h4>
      <section><p>File-based <a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a> implementation that uses
<span class="xref">System.IO.MemoryMappedFiles.MemoryMappedFile</span> for reading, and
<a class="xref" href="Lucene.Net.Store.FSDirectory.FSIndexOutput.html">FSDirectory.FSIndexOutput</a> for writing.</p>
<p><strong>NOTE</strong>: memory mapping uses up a portion of the
virtual memory address space in your process equal to the
size of the file being mapped.  Before using this class,
be sure your have plenty of virtual address space, e.g. by
using a 64 bit runtime, or a 32 bit runtime with indexes that are
guaranteed to fit within the address space.
On 32 bit platforms also consult <a class="xref" href="Lucene.Net.Store.MMapDirectory.html#Lucene_Net_Store_MMapDirectory__ctor_System_IO_DirectoryInfo_Lucene_Net_Store_LockFactory_System_Int32_">MMapDirectory(DirectoryInfo, LockFactory, Int32)</a>
if you have problems with mmap failing because of fragmented
address space. If you get an <span class="xref">System.OutOfMemoryException</span>, it is recommended
to reduce the chunk size, until it works.
<p>
<strong>NOTE:</strong> Accessing this class either directly or
indirectly from a thread while it&apos;s interrupted can close the
underlying channel immediately if at the same time the thread is
blocked on IO. The channel will remain closed and subsequent access
to <a class="xref" href="Lucene.Net.Store.MMapDirectory.html">MMapDirectory</a> will throw a <span class="xref">System.ObjectDisposedException</span>.
</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.MMapDirectory.MMapIndexInput.html">MMapDirectory.MMapIndexInput</a></h4>
      <section></section>
      <h4><a class="xref" href="Lucene.Net.Store.NativeFSLockFactory.html">NativeFSLockFactory</a></h4>
      <section><p>Implements <a class="xref" href="Lucene.Net.Store.LockFactory.html">LockFactory</a> using native OS file
locks.  For NFS based access to an index, it&apos;s
recommended that you try <a class="xref" href="Lucene.Net.Store.SimpleFSLockFactory.html">SimpleFSLockFactory</a>
first and work around the one limitation that a lock file
could be left when the runtime exits abnormally.</p>

<p>The primary benefit of <a class="xref" href="Lucene.Net.Store.NativeFSLockFactory.html">NativeFSLockFactory</a> is
that locks (not the lock file itsself) will be properly
removed (by the OS) if the runtime has an abnormal exit.</p>

<p>Note that, unlike <a class="xref" href="Lucene.Net.Store.SimpleFSLockFactory.html">SimpleFSLockFactory</a>, the existence of
leftover lock files in the filesystem is fine because the OS
will free the locks held against these files even though the
files still remain. Lucene will never actively remove the lock
files, so although you see them, the index may not be locked.</p>

<p>Special care needs to be taken if you change the locking
implementation: First be certain that no writer is in fact
writing to the index otherwise you can easily corrupt
your index. Be sure to do the <a class="xref" href="Lucene.Net.Store.LockFactory.html">LockFactory</a> change on all Lucene
instances and clean up all leftover lock files before starting
the new configuration for the first time. Different implementations
can not work together!</p>

<p>If you suspect that this or any other <a class="xref" href="Lucene.Net.Store.LockFactory.html">LockFactory</a> is
not working properly in your environment, you can easily
test it by using <a class="xref" href="Lucene.Net.Store.VerifyingLockFactory.html">VerifyingLockFactory</a>,
<a class="xref" href="Lucene.Net.Store.LockVerifyServer.html">LockVerifyServer</a> and <a class="xref" href="Lucene.Net.Store.LockStressTest.html">LockStressTest</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.NIOFSDirectory.html">NIOFSDirectory</a></h4>
      <section><p>An <a class="xref" href="Lucene.Net.Store.FSDirectory.html">FSDirectory</a> implementation that uses <span class="xref">System.IO.FileStream</span>&apos;s
positional read, which allows multiple threads to read from the same file
without synchronizing.
<p>
This class only uses <span class="xref">System.IO.FileStream</span> when reading; writing is achieved with
<a class="xref" href="Lucene.Net.Store.FSDirectory.FSIndexOutput.html">FSDirectory.FSIndexOutput</a>.
<p>
<strong>NOTE</strong>: <a class="xref" href="Lucene.Net.Store.NIOFSDirectory.html">NIOFSDirectory</a> is not recommended on Windows because of a bug in
how FileChannel.read is implemented in Sun&apos;s JRE. Inside of the
implementation the position is apparently synchronized. See <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6265734">here</a>
for details.
</p>
<p>
<font color="red"><strong>NOTE:</strong> Accessing this class either directly or
indirectly from a thread while it&apos;s interrupted can close the
underlying file descriptor immediately if at the same time the thread is
blocked on IO. The file descriptor will remain closed and subsequent access
to <a class="xref" href="Lucene.Net.Store.NIOFSDirectory.html">NIOFSDirectory</a> will throw a <span class="xref">System.ObjectDisposedException</span>. If
your application uses either <span class="xref">System.Threading.Thread.Interrupt</span> or
<span class="xref">System.Threading.Tasks.Task</span> you should use <a class="xref" href="Lucene.Net.Store.SimpleFSDirectory.html">SimpleFSDirectory</a> in
favor of <a class="xref" href="Lucene.Net.Store.NIOFSDirectory.html">NIOFSDirectory</a>.</font>
</p></p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.NIOFSDirectory.NIOFSIndexInput.html">NIOFSDirectory.NIOFSIndexInput</a></h4>
      <section><p>Reads bytes with the <span class="xref">Lucene.Net.Support.IO.StreamExtensions.Read(System.IO.Stream,J2N.IO.ByteBuffer,System.Int64)</span>
extension method for <span class="xref">System.IO.Stream</span>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.NoLockFactory.html">NoLockFactory</a></h4>
      <section><p>Use this <a class="xref" href="Lucene.Net.Store.LockFactory.html">LockFactory</a> to disable locking entirely.
Only one instance of this lock is created.  You should call 
<a class="xref" href="Lucene.Net.Store.NoLockFactory.html#Lucene_Net_Store_NoLockFactory_GetNoLockFactory">GetNoLockFactory()</a> to get the instance.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.NRTCachingDirectory.html">NRTCachingDirectory</a></h4>
      <section><p>Wraps a <a class="xref" href="Lucene.Net.Store.RAMDirectory.html">RAMDirectory</a>
around any provided delegate directory, to
be used during NRT search.</p>
<p>This class is likely only useful in a near-real-time
context, where indexing rate is lowish but reopen
rate is highish, resulting in many tiny files being
written.  This directory keeps such segments (as well as
the segments produced by merging them, as long as they
are small enough), in RAM.</p>

<p>This is safe to use: when your app calls <a class="xref" href="Lucene.Net.Index.IndexWriter.html#Lucene_Net_Index_IndexWriter_Commit">Commit()</a>,
all cached files will be flushed from the cached and sync&apos;d.</p>

<p><p>Here&apos;s a simple example usage:</p>
<pre><code>    Directory fsDir = FSDirectory.Open(new DirectoryInfo(&quot;/path/to/index&quot;));
    NRTCachingDirectory cachedFSDir = new NRTCachingDirectory(fsDir, 5.0, 60.0);
    IndexWriterConfig conf = new IndexWriterConfig(Version.LUCENE_48, analyzer);
    IndexWriter writer = new IndexWriter(cachedFSDir, conf);</code></pre>

<p><p>This will cache all newly flushed segments, all merges
whose expected segment size is &lt;= 5 MB, unless the net
cached bytes exceeds 60 MB at which point all writes will
not be cached (until the net bytes falls below 60 MB).</p>
<p>
<div class="lucene-block lucene-experimental">This is a Lucene.NET EXPERIMENTAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Store.OutputStreamDataOutput.html">OutputStreamDataOutput</a></h4>
      <section><p>A <a class="xref" href="Lucene.Net.Store.DataOutput.html">DataOutput</a> wrapping a plain <span class="xref">System.IO.Stream</span>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.RAMDirectory.html">RAMDirectory</a></h4>
      <section><p>A memory-resident <a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a> implementation.  Locking
implementation is by default the <a class="xref" href="Lucene.Net.Store.SingleInstanceLockFactory.html">SingleInstanceLockFactory</a>
but can be changed with <a class="xref" href="Lucene.Net.Store.Directory.html#Lucene_Net_Store_Directory_SetLockFactory_Lucene_Net_Store_LockFactory_">SetLockFactory(LockFactory)</a>.</p>
<p><p><strong>Warning:</strong> This class is not intended to work with huge
indexes. Everything beyond several hundred megabytes will waste
resources (GC cycles), because it uses an internal buffer size
of 1024 bytes, producing millions of <span class="xref">byte[1024]</span> arrays.
This class is optimized for small memory-resident indexes.
It also has bad concurrency on multithreaded environments.</p>
<p><p>It is recommended to materialize large indexes on disk and use
<a class="xref" href="Lucene.Net.Store.MMapDirectory.html">MMapDirectory</a>, which is a high-performance directory
implementation working directly on the file system cache of the
operating system, so copying data to heap space is not useful.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.RAMFile.html">RAMFile</a></h4>
      <section><p>Represents a file in RAM as a list of <span class="xref">byte[]</span> buffers.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Store.RAMInputStream.html">RAMInputStream</a></h4>
      <section><p>A memory-resident <a class="xref" href="Lucene.Net.Store.IndexInput.html">IndexInput</a> implementation.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Store.RAMOutputStream.html">RAMOutputStream</a></h4>
      <section><p>A memory-resident <a class="xref" href="Lucene.Net.Store.IndexOutput.html">IndexOutput</a> implementation.
<p>
<div class="lucene-block lucene-internal">This is a Lucene.NET INTERNAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Store.RateLimitedDirectoryWrapper.html">RateLimitedDirectoryWrapper</a></h4>
      <section><p>A <a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a> wrapper that allows <a class="xref" href="Lucene.Net.Store.IndexOutput.html">IndexOutput</a> rate limiting using
IO context (<a class="xref" href="Lucene.Net.Store.IOContext.UsageContext.html">IOContext.UsageContext</a>) specific rate limiters (<a class="xref" href="Lucene.Net.Store.RateLimiter.html">RateLimiter</a>).
<p>
<div class="lucene-block lucene-experimental">This is a Lucene.NET EXPERIMENTAL API, use at your own risk</div></section>
      <h4><a class="xref" href="Lucene.Net.Store.RateLimiter.html">RateLimiter</a></h4>
      <section><p>Abstract base class to rate limit IO.  Typically implementations are
shared across multiple <a class="xref" href="Lucene.Net.Store.IndexInput.html">IndexInput</a>s or <a class="xref" href="Lucene.Net.Store.IndexOutput.html">IndexOutput</a>s (for example
those involved all merging).  Those <a class="xref" href="Lucene.Net.Store.IndexInput.html">IndexInput</a>s and
<a class="xref" href="Lucene.Net.Store.IndexOutput.html">IndexOutput</a>s would call <a class="xref" href="Lucene.Net.Store.RateLimiter.html#Lucene_Net_Store_RateLimiter_Pause_System_Int64_">Pause(Int64)</a> whenever they
want to read bytes or write bytes.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.RateLimiter.SimpleRateLimiter.html">RateLimiter.SimpleRateLimiter</a></h4>
      <section><p>Simple class to rate limit IO.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.SimpleFSDirectory.html">SimpleFSDirectory</a></h4>
      <section><p>A straightforward implementation of <a class="xref" href="Lucene.Net.Store.FSDirectory.html">FSDirectory</a>
using <span class="xref">System.IO.FileStream</span>.  However, this class has
poor concurrent performance (multiple threads will
bottleneck) as it synchronizes when multiple threads
read from the same file.  It&apos;s usually better to use
<a class="xref" href="Lucene.Net.Store.NIOFSDirectory.html">NIOFSDirectory</a> or <a class="xref" href="Lucene.Net.Store.MMapDirectory.html">MMapDirectory</a> instead.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.SimpleFSDirectory.SimpleFSIndexInput.html">SimpleFSDirectory.SimpleFSIndexInput</a></h4>
      <section><p>Reads bytes with <span class="xref">System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)</span> followed by
<span class="xref">System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)</span>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.SimpleFSLockFactory.html">SimpleFSLockFactory</a></h4>
      <section><p>Implements <a class="xref" href="Lucene.Net.Store.LockFactory.html">LockFactory</a> using 
<span class="xref">System.IO.File.WriteAllText(System.String,System.String,System.Text.Encoding)</span> 
(writes the file with UTF8 encoding and no byte order mark).</p>

<p>Special care needs to be taken if you change the locking
implementation: First be certain that no writer is in fact
writing to the index otherwise you can easily corrupt
your index. Be sure to do the <a class="xref" href="Lucene.Net.Store.LockFactory.html">LockFactory</a> change to all Lucene
instances and clean up all leftover lock files before starting
the new configuration for the first time. Different implementations
can not work together!</p>

<p>If you suspect that this or any other <a class="xref" href="Lucene.Net.Store.LockFactory.html">LockFactory</a> is
not working properly in your environment, you can easily
test it by using <a class="xref" href="Lucene.Net.Store.VerifyingLockFactory.html">VerifyingLockFactory</a>, 
<a class="xref" href="Lucene.Net.Store.LockVerifyServer.html">LockVerifyServer</a> and <a class="xref" href="Lucene.Net.Store.LockStressTest.html">LockStressTest</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.SingleInstanceLockFactory.html">SingleInstanceLockFactory</a></h4>
      <section><p>Implements <a class="xref" href="Lucene.Net.Store.LockFactory.html">LockFactory</a> for a single in-process instance,
meaning all locking will take place through this one instance.
Only use this <a class="xref" href="Lucene.Net.Store.LockFactory.html">LockFactory</a> when you are certain all
<a class="xref" href="Lucene.Net.Index.IndexReader.html">IndexReader</a>s and <a class="xref" href="Lucene.Net.Index.IndexWriter.html">IndexWriter</a>s for a given index are running
against a single shared in-process <a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a> instance.  This is
currently the default locking for <a class="xref" href="Lucene.Net.Store.RAMDirectory.html">RAMDirectory</a>.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.TrackingDirectoryWrapper.html">TrackingDirectoryWrapper</a></h4>
      <section><p>A delegating <a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a> that records which files were
written to and deleted.</p>
</section>
      <h4><a class="xref" href="Lucene.Net.Store.VerifyingLockFactory.html">VerifyingLockFactory</a></h4>
      <section><p>A <a class="xref" href="Lucene.Net.Store.LockFactory.html">LockFactory</a> that wraps another 
<a class="xref" href="Lucene.Net.Store.LockFactory.html">LockFactory</a> and verifies that each lock obtain/release
is &quot;correct&quot; (never results in two processes holding the
lock at the same time).  It does this by contacting an
external server (<a class="xref" href="Lucene.Net.Store.LockVerifyServer.html">LockVerifyServer</a>) to assert that
at most one process holds the lock at a time.  To use
this, you should also run <a class="xref" href="Lucene.Net.Store.LockVerifyServer.html">LockVerifyServer</a> on the
host &amp; port matching what you pass to the constructor.</p>
</section>
    <h3 id="enums">Enums
  </h3>
      <h4><a class="xref" href="Lucene.Net.Store.IOContext.UsageContext.html">IOContext.UsageContext</a></h4>
      <section><p><a class="xref" href="Lucene.Net.Store.IOContext.UsageContext.html">IOContext.UsageContext</a> is a enumeration which specifies the context in which the <a class="xref" href="Lucene.Net.Store.Directory.html">Directory</a>
is being used for.
<p>
NOTE: This was Context in Lucene</p>
</section>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/apache/lucenenet/blob/docs/4.8.0-beta00008/src/Lucene.Net/Store/package.md/#L2" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            Copyright © 2020 Licensed to the Apache Software Foundation (ASF)
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
